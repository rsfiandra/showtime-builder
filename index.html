<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Showtime Builder</title>
  <!-- All styles are embedded inline so the app works offline without external dependencies. -->
  <style>
*{box-sizing:border-box;}
body{margin:0;font-family:Inter,system-ui,-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;background-color:#f9fafb;color:#1f2937;}
table{border-collapse:collapse;width:100%;}
th,td{border:1px solid #e5e7eb;padding:0.5rem;text-align:left;}
button{font-family:inherit;}
.absolute {position:absolute;}
.backdrop-blur {backdrop-filter:blur(8px);}
.bg-blue-700 {background-color:#1d4ed8;}
.bg-gray-100 {background-color:#f3f4f6;}
.bg-gray-200 {background-color:#e5e7eb;}
.bg-gray-300 {background-color:#d1d5db;}
.bg-gray-50 {background-color:#f9fafb;}
.bg-gray-500 {background-color:#6b7280;}
.bg-green-700 {background-color:#047857;}
.bg-indigo-700 {background-color:#4338ca;}
.bg-red-500 {background-color:#ef4444;}
.bg-red-700 {background-color:#b91c1c;}
.bg-white {background-color:#ffffff;}
.bg-white\/60 {background-color:rgba(255,255,255,0.6);}
.bg-white\/70 {background-color:rgba(255,255,255,0.7);}
.bg-white\/90 {background-color:rgba(255,255,255,0.9);}
.bg-yellow-100 {background-color:#fef3c7;}
.bg-yellow-200 {background-color:#fde68a;}
.border {border-width:1px;}
.border-2 {border-width:2px;}
.border-b {border-bottom-width:1px;}
.border-gray-200 {border-color:#e5e7eb;}
.border-gray-300 {border-color:#d1d5db;}
.border-gray-400 {border-color:#9ca3af;}
.border-l {border-left-width:1px;}
.border-r {border-right-width:1px;}
.border-t {border-top-width:1px;}
.bottom-0 {bottom:0;}
.cursor-grab {cursor:grab;}
.fixed {position:fixed;}
.flex {display:flex;}
.flex-1 {flex:1 1 0%;}
.flex-col {flex-direction:column;}
.flex-grow {flex-grow:1;}
.flex-none {flex:none;}
.flex-nowrap {flex-wrap:nowrap;}
.flex-wrap {flex-wrap:wrap;}
.font-bold {font-weight:700;}
.font-medium {font-weight:500;}
.font-mono {font-family:'SFMono-Regular',ui-monospace,Menlo,Monaco,Consolas,'Liberation Mono','Courier New',monospace;}
.font-semibold {font-weight:600;}
.gap-2 {gap:0.5rem;}
.gap-3 {gap:0.75rem;}
.gap-4 {gap:1rem;}
.gap-8 {gap:2rem;}
.grid {display:grid;}
.grid-cols-1 {display:grid;grid-template-columns:repeat(1,minmax(0,1fr));}
.h-1\/2 {height:50%;}
.h-6 {height:1.5rem;}
.h-full {height:100%;}
.hidden {display:none;}
.inline-flex {display:inline-flex;}
.items-center {align-items:center;}
.items-stretch {align-items:stretch;}
.justify-between {justify-content:space-between;}
.justify-end {justify-content:flex-end;}
.left-0 {left:0;}
.list-disc {list-style-type:disc;}
.max-w-5xl {max-width:64rem;}
.mb-1 {margin-bottom:0.25rem;}
.mb-2 {margin-bottom:0.5rem;}
.mb-3 {margin-bottom:0.75rem;}
.mb-4 {margin-bottom:1rem;}
.min-w-full {min-width:100%;}
.ml-1 {margin-left:0.25rem;}
.ml-2 {margin-left:0.5rem;}
.ml-auto {margin-left:auto;}
.mr-1 {margin-right:0.25rem;}
.mr-2 {margin-right:0.5rem;}
.mt-2 {margin-top:0.5rem;}
.mt-3 {margin-top:0.75rem;}
.mt-4 {margin-top:1rem;}
.mt-6 {margin-top:1.5rem;}
.mt-8 {margin-top:2rem;}
.mx-auto {margin-left:auto;margin-right:auto;}
.opacity-60 {opacity:0.6;}
.overflow-hidden {overflow:hidden;}
.overflow-x-auto {overflow-x:auto;}
.overflow-y-auto {overflow-y:auto;}
.p-0 {padding:0rem;}
.p-1 {padding:0.25rem;}
.p-2 {padding:0.5rem;}
.p-3 {padding:0.75rem;}
.p-4 {padding:1rem;}
.p-6 {padding:1.5rem;}
.pb-2 {padding-bottom:0.5rem;}
.pb-6 {padding-bottom:1.5rem;}
.pl-1 {padding-left:0.25rem;}
.pl-5 {padding-left:1.25rem;}
.pl-6 {padding-left:1.5rem;}
.pr-1 {padding-right:0.25rem;}
.pt-4 {padding-top:1rem;}
.px-1 {padding-left:0.25rem;padding-right:0.25rem;}
.px-2 {padding-left:0.5rem;padding-right:0.5rem;}
.px-3 {padding-left:0.75rem;padding-right:0.75rem;}
.px-4 {padding-left:1rem;padding-right:1rem;}
.px-6 {padding-left:1.5rem;padding-right:1.5rem;}
.py-0.5 {padding-top:0.125rem;padding-bottom:0.125rem;}
.py-1 {padding-top:0.25rem;padding-bottom:0.25rem;}
.py-2 {padding-top:0.5rem;padding-bottom:0.5rem;}
.py-3 {padding-top:0.75rem;padding-bottom:0.75rem;}
.relative {position:relative;}
.ring-1 {box-shadow:0 0 0 1px rgba(15,23,42,0.08);}
.ring-2 {box-shadow:0 0 0 2px rgba(15,23,42,0.1);}
.ring-slate-200 {box-shadow:0 0 0 1px #e2e8f0;}
.rounded {border-radius:0.25rem;}
.rounded-full {border-radius:9999px;}
.rounded-l {border-top-left-radius:0.25rem;border-bottom-left-radius:0.25rem;}
.rounded-l-lg {border-top-left-radius:0.5rem;border-bottom-left-radius:0.5rem;}
.rounded-lg {border-radius:0.5rem;}
.rounded-md {border-radius:0.375rem;}
.rounded-r {border-top-right-radius:0.25rem;border-bottom-right-radius:0.25rem;}
.rounded-t-lg {border-top-left-radius:0.5rem;border-top-right-radius:0.5rem;}
.rounded-xl {border-radius:0.75rem;}
.select-none {user-select:none;}
.shadow {box-shadow:0 10px 15px -3px rgba(15,23,42,0.1),0 4px 6px -4px rgba(15,23,42,0.1);}
.shadow-lg {box-shadow:0 20px 25px -5px rgba(15,23,42,0.1),0 10px 10px -5px rgba(15,23,42,0.04);}
.shadow-sm {box-shadow:0 1px 2px 0 rgba(15,23,42,0.08);}
.space-x-1 > :not([hidden]) ~ :not([hidden]) {margin-left:0.25rem;}
.space-x-2 > :not([hidden]) ~ :not([hidden]) {margin-left:0.5rem;}
.space-y-1 > :not([hidden]) ~ :not([hidden]) {margin-top:0.25rem;}
.space-y-2 > :not([hidden]) ~ :not([hidden]) {margin-top:0.5rem;}
.space-y-4 > :not([hidden]) ~ :not([hidden]) {margin-top:1rem;}
.space-y-8 > :not([hidden]) ~ :not([hidden]) {margin-top:2rem;}
.sticky {position:sticky;}
.text-2xl {font-size:1.5rem;line-height:2rem;}
.text-black {color:#000000;}
.text-gray-600 {color:#4b5563;}
.text-gray-700 {color:#374151;}
.text-gray-800 {color:#1f2937;}
.text-green-700 {color:#047857;}
.text-lg {font-size:1.125rem;line-height:1.75rem;}
.text-red-600 {color:#dc2626;}
.text-red-700 {color:#b91c1c;}
.text-sm {font-size:0.875rem;line-height:1.25rem;}
.text-white {color:#ffffff;}
.text-white\/90 {color:rgba(255,255,255,0.9);}
.text-xl {font-size:1.25rem;line-height:1.75rem;}
.text-xs {font-size:0.75rem;line-height:1rem;}
.top-0 {top:0;}
.top-1\/4 {top:25%;}
.tracking-wide {letter-spacing:0.05em;}
.truncate {overflow:hidden;text-overflow:ellipsis;white-space:nowrap;}
.uppercase {text-transform:uppercase;}
.w-12 {width:3rem;}
.w-14 {width:3.5rem;}
.w-16 {width:4rem;}
.w-20 {width:5rem;}
.w-24 {width:6rem;}
.w-40 {width:10rem;}
.w-\[34rem\] {width:34rem;}
.w-full {width:100%;}
.whitespace-nowrap {white-space:nowrap;}
.z-10 {z-index:10;}
.z-20 {z-index:20;}
.z-50 {z-index:50;}
.hover\:bg-blue-700:hover {background-color:#1d4ed8;}
.hover\:bg-blue-800:hover {background-color:#1e40af;}
.hover\:bg-gray-200:hover {background-color:#e5e7eb;}
.hover\:bg-gray-50:hover {background-color:#f9fafb;}
.hover\:bg-gray-600:hover {background-color:#4b5563;}
.hover\:bg-green-800:hover {background-color:#065f46;}
.hover\:bg-indigo-800:hover {background-color:#3730a3;}
.hover\:bg-red-800:hover {background-color:#991b1b;}
.hover\:bg-sky-50:hover {background-color:#f0f9ff;}
.hover\:text-gray-200:hover {color:#e5e7eb;}
.hover\:text-red-800:hover {color:#991b1b;}
.focus\:outline-none:focus {outline:2px solid transparent;outline-offset:2px;}
.focus\:ring:focus {box-shadow:0 0 0 3px rgba(59,130,246,0.45);}
.divide-y > :not([hidden]) ~ :not([hidden]) {border-top:1px solid var(--divide-color,#e5e7eb);}
.divide-gray-200 {--divide-color:#e5e7eb;}
.text-blue-700 {color:#1d4ed8;}
.text-yellow-600 {color:#ca8a04;}
.text-yellow-700 {color:#b45309;}
.text-[0.625rem] {font-size:0.625rem;line-height:1rem;}
.text-[0.65rem] {font-size:0.65rem;line-height:1rem;}
.text-[10px] {font-size:10px;line-height:1rem;}
.nav-link {padding-left:1rem;padding-right:1rem;padding-top:0.5rem;padding-bottom:0.5rem;border-radius:0.5rem;font-size:0.875rem;font-weight:500;display:inline-block;background:transparent;border:none;color:inherit;cursor:pointer;}
.nav-link:focus-visible {outline:2px solid rgba(255,255,255,0.7);outline-offset:2px;}
.nav-link.active-nav {background-color:rgba(255,255,255,0.2);}
.summary-bar-wrapper {display:flex;flex-direction:column;align-items:flex-end;gap:0.25rem;}
.summary-bar-value {font-weight:600;font-size:0.85rem;}
.summary-bar-track {width:100%;height:0.5rem;background-color:#e5e7eb;border-radius:9999px;overflow:hidden;}
.summary-bar {height:100%;background-image:linear-gradient(to right,var(--brand-from),var(--brand-to));}
@media (min-width:768px){.md\:grid-cols-2 {display:grid;grid-template-columns:repeat(2,minmax(0,1fr));}}
@media (min-width:1280px){.xl\:grid-cols-4 {display:grid;grid-template-columns:repeat(4,minmax(0,1fr));}}
@media (min-width:768px){.grid-cols-1 {display:grid;grid-template-columns:repeat(1,minmax(0,1fr));}.grid-cols-2 {display:grid;grid-template-columns:repeat(2,minmax(0,1fr));}}
@media (min-width:1280px){.grid-cols-4 {display:grid;grid-template-columns:repeat(4,minmax(0,1fr));}}

.w-14 {
  max-width: 3.5rem;
}

/*
 * Override film highlight styling for better visibility.
 * We append this rule at the end of the stylesheet so it takes
 * precedence over earlier definitions of .film-highlight.  The
 * semi‑dark pink colour uses a higher opacity for stronger contrast
 * and forces the text colour to black.  Clearing the background
 * image ensures gradients do not bleed through the highlight.
 */
.film-highlight {
  background-color: rgba(245, 142, 182, 0.6) !important;
  background-image: none !important;
  color: #000 !important;
}

/* Hide the film highlight dropdown on pages that declare the `no-highlight`
   class on the <body>.  Including a placeholder on every page prevents the
   navigation bar from shifting when switching tabs, but the select itself
   should not appear on pages where film highlighting is not relevant.  The
   placeholder remains visible to reserve space; the select is hidden. */
.no-highlight #filmHighlightSelect {
  display: none !important;
}
.no-highlight #filmHighlightPlaceholder {
  display: inline-block;
  min-width: 9rem;
}

/* Reserve space for the film highlight dropdown on all pages.  The
   placeholder span is used to inject the select on pages that need it,
   but it should occupy a consistent width even when empty so that
   controls do not shift left or right between tabs. */
#filmHighlightPlaceholder {
  display: inline-block;
  min-width: 9rem;
}

/* Ensure the highlight dropdown itself occupies the same width as the
   placeholder when present.  Allow it to grow up to a reasonable
   maximum so longer film titles do not push other controls around. */
#filmHighlightSelect {
  min-width: 9rem;
  max-width: 14rem;
}

/* Ensure the order panel toggle button has a consistent width whether
   showing "Show Order" or "Hide Order".  Without this rule, the
   button's width changes when its label changes, causing nearby
   controls to shift.  Center the text so both labels look balanced. */
#orderPanelToggleBtn {
  min-width: 8rem;
  text-align: center;
}
:root {
  /* Default brand colours: darkened blue and indigo tones for a more
     subdued, richer look.  These values can still be overridden by
     the colour swatches in theme.js. */
  --brand-from: #1e3a8a;
  --brand-to: #312e81;
}
/* Apply the selected gradient colours to table headers. This class should be used on <thead> elements. */
/* Solid header background for tables: use the primary swatch colour on all
   header cells instead of a gradient.  Gradients can clash on certain
   colour combinations, so a solid colour ensures consistent appearance. */
.grad-header {
  background-color: var(--brand-from);
  color: #ffffff;
  /* Remove any background image to avoid mixing gradients */
  background-image: none;
}
/* Apply the selected gradient colours to show bars on the Gantt timeline.  When a bar
   is not active or in conflict, it receives this class.  Highlighting an
   active bar will remove this class in gantt.js so the purple highlight can
   show through. */
.grad-bar {
  background-image: linear-gradient(to right, var(--brand-from), var(--brand-to));
  color: #ffffff;
}
/* Flex-wrap navigation bar. Allows nav items and the theme picker to wrap neatly and prevents overlap on narrow screens. */
/* Navigation bar wrapper
   Keep the top-level navigation items on a single row so they remain
   visible across pages.  Prevent the nav items from wrapping by
   disabling flex-wrap; if the combined width exceeds the viewport the
   bar will scroll horizontally instead of pushing items to a second
   line.  A small gap between items preserves spacing.  Align items
   vertically centered to match the existing design. */
/*
  Navigation wrapper

  Arrange the main navigation bar into a flexible container that can
  wrap its children onto multiple lines.  This prevents important
  links from being pushed off‑screen when additional controls (like
  date selectors or a film highlight dropdown) are present.  The nav
  links are grouped into a separate flex container inside each page’s
  markup; controls such as first/last selectors, date pickers, copy
  buttons and the optional film highlight dropdown live in a second
  container.  By allowing the wrapper to wrap, the links remain on
  the first row and the controls move to a new row as needed.

  The wrapper no longer scrolls horizontally; instead content will
  wrap naturally when it exceeds the viewport width.  Align items to
  the start so that multi‑row content flows from the left edge.
*/
.nav-wrap {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
  align-items: flex-start;
}

/* When a navigation bar uses the grad-nav class, make nav links inherit the text
   colour from the parent.  This ensures the links remain visible on top of the
   gradient background.  Hover styles defined in the HTML (e.g. hover:bg-blue-600)
   still apply but will use the inherited white text. */
.grad-nav .nav-link {
  color: inherit;
}

/* Apply the selected gradient colours to the navigation bar.  This allows the
   theme swatch to colour the nav header just like the table headers.  The
   nav inherits the global text colour (white) so links remain legible. */
.grad-nav {
  background-image: linear-gradient(to right, var(--brand-from), var(--brand-to));
  color: #ffffff;
}
/* Small colour swatches used for the theme picker. */
.swatch {
  height: 20px;
  width: 20px;
  border-radius: 9999px;
  border: 1px solid rgba(0, 0, 0, 0.25);
  cursor: pointer;
}

/* Provide basic styling for nav-link anchors. These mimic the Tailwind
   utility classes px-4 py-2 rounded-md text-sm font-medium. Because
   these pages are static, we can't rely on Tailwind's JIT to create a
   custom class. Defining nav-link here ensures that all pages share
   consistent spacing and typography. */
/* Style navigation links with slightly more rounded corners than the default
   Tailwind `rounded-md` (0.375rem). Using a 0.5rem radius gives
   buttons a softer, more pill‑like appearance without drastically
   changing the layout. All other spacing and font sizes remain the
   same. */
.nav-link {
  padding-left: 1rem;
  padding-right: 1rem;
  padding-top: 0.5rem;
  padding-bottom: 0.5rem;
  border-radius: 0.5rem;
  font-size: 0.875rem;
  font-weight: 500;
  display: inline-block;
}

/* Keep the group of navigation links on a single row.  This prevents
   important tabs (e.g. Dashboard) from being pushed to a new line
   when additional controls are present.  Horizontal scrolling is
   enabled if the available width is insufficient. */
.nav-links {
  flex-wrap: nowrap !important;
  overflow-x: auto;
}

/*
 * Temporary highlight applied when navigating to a specific auditorium row
 * via the dashboard's flagged issues list.  Rows with this class will
 * briefly flash a yellow background, then fade back to transparent.
 */
.jump-highlight {
  animation: jumpFlash 1.0s ease-in-out;
}
@keyframes jumpFlash {
  0% { background-color: rgba(253, 224, 71, 0.6); }
  50% { background-color: rgba(253, 224, 71, 0.3); }
  100% { background-color: transparent; }
}

/* Dense table styles
   Some tables (Auditoriums, Bookings and Prime schedule) should present more
   information in a compact form.  The `dense-table` class reduces the
   vertical padding on table header and body cells so that rows occupy
   less height without affecting readability.  Use this class on the
   <table> element to opt‑in to the denser layout. */
.dense-table th,
.dense-table td {
  padding-top: 2px !important;
  padding-bottom: 2px !important;
}

/* When the body has the `dense` class, reduce table cell padding and font size
   globally.  This class is toggled via dense-toggle.js and provides a
   compact layout similar to the alternate Viewer application.  The
   !important declarations ensure that these rules override Tailwind
   utility classes applied directly to the tables. */
body.dense table th,
body.dense table td {
  padding-top: 2px !important;
  padding-bottom: 2px !important;
  padding-left: 0.35rem !important;
  padding-right: 0.35rem !important;
  font-size: 0.75rem !important;
}

/*
  Hide the native dropdown arrow on all <select> elements and adjust padding.
  The original deployed application used custom dropdown styling without the
  default caret, which allowed narrower columns. Removing the default arrow
  brings our static pages closer to that look. The appearance rules target
  all browsers, and the background-image is cleared to hide any default
  indicators. We also reduce the right padding slightly since there is no
  arrow occupying space.
*/
select {
  /* Remove the native dropdown arrow.  Use !important to override any
     Tailwind forms plugin defaults that may reintroduce a custom arrow.
     Without !important some embedded styles can override the appearance
     properties on certain browsers. */
  -moz-appearance: none !important;
  -webkit-appearance: none !important;
  appearance: none !important;
  /* Remove any background image that might contain an arrow. */
  background-image: none !important;
  /* Slightly reduce right padding since there is no arrow occupying space. */
  padding-right: 0.5rem;
}

/* Limit the maximum width of common Tailwind width classes to avoid overly
   wide columns on pages that use selects or time inputs.  The original
   deployed version kept dropdowns compact by hiding the native arrow and
   restricting the width.  By clamping these widths we prevent the columns
   from growing when content is short.  We explicitly enumerate the widths
   used throughout the app so they remain responsive when needed but never
   exceed the specified size. */
.w-12 {
  max-width: 3rem;
}
.w-16 {
  max-width: 4rem;
}
.w-20 {
  max-width: 5rem;
}
.w-24 {
  max-width: 6rem;
}
.w-28 {
  max-width: 7rem;
}
.w-32 {
  max-width: 8rem;
}

/* Highlight style for film names when a movie is selected from the
   header dropdown.  Use a semi‑dark pinkish background with some
   transparency so the text remains legible.  The rgba colour
   (245, 142, 182, 0.4) results in a medium pink overlay that stands
   out without overpowering the existing table colours. */
/* Highlight style for film names and Gantt bars when a movie is selected.
   Use a semi‑dark pinkish overlay on top of existing elements.  Setting
   background-image to none ensures that gradient bars are overridden by
   the solid highlight colour.  The !important flags are necessary to
   override inline styles and other utility classes. */
.film-highlight {
  /* Use a darker pink overlay for better contrast on the Gantt bars and tables.  A higher
     alpha value (0.6) provides sufficient differentiation without turning the
     text red.  Also override the text colour to black so content remains
     legible when highlighted. */
  background-color: rgba(245, 142, 182, 0.6) !important;
  background-image: none !important;
  color: #000 !important;
}

/* --- Themed Buttons ------------------------------------------------------ */
.btn {
  border-radius: 0.5rem;
  padding: 0.25rem 0.75rem;
  font-weight: 600;
  font-size: 0.875rem; /* text-sm */
  line-height: 1.25rem;
}
.btn-primary {
  background-image: linear-gradient(to right, var(--brand-from), var(--brand-to));
  color: #ffffff;
}
.btn-danger {
  background-color: #b91c1c; /* red-700 */
  color: #ffffff;
}
.btn-outline {
  border: 1px solid rgba(255,255,255,0.7);
  color: #ffffff;
  background: transparent;
}
/* Make header (nav) buttons follow the active swatch by default */
.grad-nav button:not(.btn-danger) {
  background-image: linear-gradient(to right, var(--brand-from), var(--brand-to)) !important;
  color: #ffffff !important;
  border-radius: 0.5rem !important;
  padding: 0.25rem 0.75rem !important;
}

/* === Global Button Theming (swatch-driven) ================================ */
/* Make all <button> and .btn elements follow the active swatch gradient */
button, .btn {
  border-radius: 0.5rem;
  padding: 0.25rem 0.75rem;
  font-weight: 600;
  font-size: 0.875rem; /* text-sm */
  line-height: 1.25rem;
  background-image: linear-gradient(to right, var(--brand-from, #1e3a8a), var(--brand-to, #312e81));
  color: #ffffff;
  border: none;
}

/* ---------------------------------------------------------------------------
   Schedule grid header override

   The schedule grid uses the dense-schedule class on its card-table to
   support compact rows.  However, by default all card-table headers have a
   gradient background defined by the `.card-table thead th` rule.  This
   causes each time column header to receive its own mini-gradient, which
   creates a striped appearance across the header row.  To match the
   Prime tab (which uses a solid header), override the gradient on dense
   schedule tables so the entire header row is a single solid colour.

   Use higher specificity (`.card-table.dense-schedule thead th`) and place
   this rule after the global card-table styles so it takes precedence.
*/
.card-table.dense-schedule thead th {
  background-image: none !important;
  background-color: var(--brand-from) !important;
  color: #ffffff !important;
}

/* Apply a solid header background to any card-table header row that uses
   the grad-header class.  The default card-table rule applies a
   gradient to each <th>, but when the developer explicitly adds
   class="grad-header" to the <thead>, we want a single solid colour
   across the entire header (matching the active swatch).  This rule
   overrides the gradient on all table header cells within the
   grad-header element. */
.card-table .grad-header th {
  background-image: none !important;
  background-color: var(--brand-from) !important;
  color: #ffffff !important;
}

/* Dark pink style for explicit clear actions */
.btn-clear {
  background-image: linear-gradient(to right, #be185d, #db2777) !important; /* pink-700 -> pink-600 */
  color: #ffffff !important;
}

/* Auto-style any button with id/class containing 'clear' */
button[id*="clear"], button[class*="clear"] {
  background-image: linear-gradient(to right, #be185d, #db2777) !important;
  color: #ffffff !important;
}

/* Keep an explicit danger style available */
.btn-danger {
  background-color: #b91c1c !important; /* red-700 */
  background-image: none !important;
  color: #ffffff !important;
}

/* ===== Card-style grid tables with sticky headers and focus states ===== */
/* These styles provide a compact, card-like look for editable tables,
   similar to the employee scheduler. The table is wrapped in a
   `.card-table` container which applies a border, rounded corners,
   subtle shadow and zebra striping. The header sticks to the top and
   uses the active gradient colours. Rows alternate background colours
   and highlight on hover. Cells with focused inputs get an outline
   for easy keyboard navigation. */
.card-table {
  /* Use a light grey border and a larger radius so the card table is
     clearly separated from the page.  A fixed colour instead of
     rgba() ensures the border remains visible on light backgrounds. */
  /* Use a darker light-grey border so the card outline stands out
     against the page background. */
  border: 1px solid #d1d5db; /* slate-300 */
  border-radius: 0.75rem;
  overflow: hidden;
  background: #fff;
  /* Increase shadow slightly to accentuate the card appearance */
  /* Use a slightly larger drop shadow to emphasise the card container */
  box-shadow: 0 6px 12px rgba(0, 0, 0, 0.1);
}
.card-table table {
  width: 100%;
  border-collapse: separate;
  border-spacing: 0;
}
.card-table thead th {
  position: sticky;
  top: 0;
  z-index: 1;
  /* Use the active swatch for the header gradient */
  background-image: linear-gradient(to right, var(--brand-from), var(--brand-to));
  color: #fff;
  text-align: left;
  font-weight: 600;
  font-size: 0.75rem;
  padding: 0.5rem 0.625rem;
  border-bottom: 1px solid rgba(255, 255, 255, 0.25);
}
.card-table tbody td {
  padding: 0.375rem 0.5rem;
  border-bottom: 1px solid rgba(0, 0, 0, 0.06);
  font-size: 0.875rem;
}
.card-table tbody tr:nth-child(odd) td {
  /* Use a soft grey for odd rows.  The contrast is more pronounced so
     zebra striping is visible even on light backgrounds. */
  background: #f3f4f6;
}
.card-table tbody tr:nth-child(even) td {
  /* Keep even rows white for clear zebra striping */
  background: #ffffff;
}
.card-table tbody tr:hover td {
  /* Provide a stronger hover colour so focused rows stand out */
  background: #e0e7ff;
}
.card-table input[type="text"],
.card-table input[type="number"],
.card-table select {
  width: 100%;
  min-height: 28px;
  box-sizing: border-box;
  /* Remove borders on inputs to allow the table's row stripes to define
     the grid.  This makes the table resemble a spreadsheet where
     cell boundaries are implied rather than drawn explicitly. */
  border: none;
  border-radius: 0;
  padding: 0.125rem 0.25rem;
  background: transparent;
}

/* Remove the default browser outline from inputs/selects in card tables.
   The parent td receives a custom focus outline via the navcell class. */
.card-table input[type="text"]:focus,
.card-table input[type="number"]:focus,
.card-table select:focus {
  outline: none;
}
/* Highlight any navcell when a descendant control has focus */
.card-table .navcell:focus-within,
.card-table .navcell.navfocus {
  outline: 2px solid rgba(63, 131, 248, 0.6);
  outline-offset: -2px;
}

/* Reduce row height for the schedule grid. When the card-table wrapper
   has the dense-schedule class, shrink the vertical padding on
   header and body cells so the grid appears more compact. */
/* Reduce vertical padding even more for schedule grid cells.  These values
   apply only when the card-table wrapper has the dense-schedule class. */
.card-table.dense-schedule thead th {
  /* Eliminate top and bottom padding on header cells in the dense schedule grid
     to tighten the header row. */
  padding-top: 0rem;
  padding-bottom: 0rem;
}
/* Style schedule grid cells (dense-schedule) to support two-line content (start and end times).
   We enlarge the row height and reduce the font size slightly so that
   both the start time input and end time label fit comfortably on
   separate lines without overlapping.  Previously the row height was
   too small, causing the end time to overlap the start time for some
   rows.  Use at least 2rem (32px) to ensure there is ample vertical
   space for both lines plus a small gap. */
/*
   Default styling for dense-schedule table cells.  We allocate enough vertical
   space for two lines (start time and end time) plus some breathing room
   when end times are visible.  When end times are hidden (condensed mode),
   the sg-condensed class is applied to the body which overrides these
   heights to a more compact value.
*/
.card-table.dense-schedule tbody td {
  padding-top: 0 !important;
  padding-bottom: 0 !important;
  font-size: 0.875rem;
  line-height: 1rem;
  /* Allocate 3rem (≈48px) for two lines when end times are visible. */
  height: 3rem;
  min-height: 3rem;
  vertical-align: top;
}

/* Inputs inside a dense schedule grid inherit the cell font size. Remove
   vertical padding and set a one-line height so the input and label
   stack neatly.  We leave the height at 1rem so that the cell height
   (2rem) still allocates enough space for the end time label below. */
.card-table.dense-schedule input[type="text"] {
  font-size: 0.875rem;
  padding-top: 0;
  padding-bottom: 0;
  line-height: 1rem;
  height: 1rem;
}

/* The container <div> inside each navcell now stacks its children vertically.
   Allow it to expand to accommodate both lines but enforce a minimum
   height equal to the row height (2rem) to keep rows consistent across the grid. */
/* The container <div> inside each navcell stacks its children vertically.  It
   inherits the row height to ensure that the input and end time label
   always have enough space. */
.card-table.dense-schedule td.navcell > div {
  height: 3rem;
  min-height: 3rem;
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  justify-content: flex-start;
}

/* In condensed mode (when end times are hidden), shrink the row heights
   significantly.  The sg-condensed class is toggled on the body by
   schedule-grid.js when the user clicks "Hide End Times".  This
   overrides the default 3rem height above. */
body.sg-condensed .card-table.dense-schedule tbody td {
  height: 1.5rem;
  min-height: 1.5rem;
}
body.sg-condensed .card-table.dense-schedule td.navcell > div {
  height: 1.5rem;
  min-height: 1.5rem;
}

  /* Additional Tailwind utility shims to restore original visuals */
  .accent-blue-600 {accent-color:#2563eb;}
  .align-middle {vertical-align:middle;}
  .align-top {vertical-align:top;}
  .appearance-none {-moz-appearance:none;-webkit-appearance:none;appearance:none;background-image:none;}
  .bg-purple-50 {background-color:#f5f3ff;}
  .bg-slate-50 {background-color:#f8fafc;}
  .border-dashed {border-style:dashed;}
  .border-gray-100 {border-color:#f3f4f6;}
  .border-purple-500 {border-color:#a855f7;}
  .border-slate-100 {border-color:#f1f5f9;}
  .border-slate-200 {border-color:#e2e8f0;}
  .dt-overlay {border-radius:0.5rem;pointer-events:none;}
  .even\:bg-gray-50:nth-child(even) {background-color:#f9fafb;}
  .even\:bg-slate-50:nth-child(even) {background-color:#f8fafc;}
  .hover\:text-red-900:hover {color:#7f1d1d;}
  .invisible {visibility:hidden;}
  .last\:border-0:last-child {border-bottom-width:0;}
  .late-first-badge {display:inline-flex;align-items:center;font-weight:600;line-height:1;border-radius:0.25rem;}
  .md\:grid-cols-1 {display:grid;grid-template-columns:repeat(1,minmax(0,1fr));}
  .md\:grid-cols-2 {display:grid;grid-template-columns:repeat(2,minmax(0,1fr));}
  .nav-controls {display:flex;flex-wrap:wrap;align-items:center;gap:0.75rem;width:100%;}
  .odd\:bg-white:nth-child(odd) {background-color:#ffffff;}
  .table-fixed {table-layout:fixed;}
  .tabular-nums {font-variant-numeric:tabular-nums;font-feature-settings:'tnum';}
  .text-center {text-align:center;}
  .text-left {text-align:left;}
  .text-right {text-align:right;}
  .transition-colors {transition-property:color,background-color,border-color,text-decoration-color,fill,stroke;transition-duration:150ms;transition-timing-function:cubic-bezier(0.4,0,0.2,1);}
  .xl\:grid-cols-4 {display:grid;grid-template-columns:repeat(4,minmax(0,1fr));}

  /* Ring helpers rely on CSS variables so colour utilities stack correctly */
  :root {--ring-offset-color:#ffffff;}
  .ring-1 {box-shadow:0 0 0 calc(1px + var(--ring-offset-width,0px)) var(--ring-color,rgba(15,23,42,0.12)),0 0 0 var(--ring-offset-width,0px) var(--ring-offset-color,#ffffff);}
  .ring-2 {box-shadow:0 0 0 calc(2px + var(--ring-offset-width,0px)) var(--ring-color,rgba(15,23,42,0.15)),0 0 0 var(--ring-offset-width,0px) var(--ring-offset-color,#ffffff);}
  .ring-offset-1 {--ring-offset-width:1px;}
  .ring-blue-400 {--ring-color:#60a5fa;}
  .ring-purple-400 {--ring-color:#c084fc;}
  .ring-slate-200 {--ring-color:#e2e8f0;}

  @media (min-width:768px){.md\:grid-cols-1 {display:grid;grid-template-columns:repeat(1,minmax(0,1fr));}.md\:grid-cols-2 {display:grid;grid-template-columns:repeat(2,minmax(0,1fr));}}
  @media (min-width:1280px){.xl\:grid-cols-4 {display:grid;grid-template-columns:repeat(4,minmax(0,1fr));}}
  </style>
</head>
<body class="bg-gray-50 text-gray-800">
  <nav class="nav-wrap grad-nav px-4 py-3">
    <!-- First row: navigation links.  These anchors remain on a single line. -->
    <div class="nav-links flex flex-nowrap items-center gap-2">
      <button type="button" class="nav-link hover:bg-blue-700" data-view-target="home">Home</button>
      <button type="button" class="nav-link hover:bg-blue-700" data-view-target="auditoriums" data-fallback-href="aud.html">Auditoriums</button>
      <button type="button" class="nav-link hover:bg-blue-700" data-view-target="bookings" data-fallback-href="bookings.html">Bookings</button>
      <button type="button" class="nav-link hover:bg-blue-700" data-view-target="prime" data-fallback-href="prime.html">Prime</button>
      <!-- Rename the grid tab to Schedule and add a Gantt tab -->
      <button type="button" class="nav-link hover:bg-blue-700" data-view-target="schedule" data-fallback-href="schedule-grid.html">Schedule</button>
      <button type="button" class="nav-link hover:bg-blue-700" data-view-target="order" data-fallback-href="order.html">Order</button>
      <button type="button" class="nav-link hover:bg-blue-700" data-view-target="gantt" data-fallback-href="gantt.html">Gantt</button>
      <!-- Dashboard tab: show charts summarising schedules -->
      <button type="button" class="nav-link hover:bg-blue-700" data-view-target="dashboard" data-fallback-href="dashboard.html">Dashboard</button>
      <!-- Removed separate Data tab; its functionality is now part of the Home page -->
      <button type="button" class="nav-link hover:bg-blue-700" data-view-target="audit" data-fallback-href="audit.html">Audit</button>
    </div>
    <!-- Second row: controls.  Include a placeholder to reserve space for the
         film highlight dropdown even though the home page hides it.  Wrap
         controls onto their own line and take the full width of the nav. -->
    <div class="nav-controls flex flex-wrap items-center gap-3 w-full mt-2">
      <span id="filmHighlightPlaceholder"></span>
      <label class="flex items-center space-x-1 text-white text-sm">
        <span>First</span>
        <select id="firstShowGlobalSelect" class="border border-gray-300 rounded px-2 py-1 text-sm text-gray-800"></select>
      </label>
      <label class="flex items-center space-x-1 text-white text-sm">
        <span>Last</span>
        <select id="lastShowGlobalSelect" class="border border-gray-300 rounded px-2 py-1 text-sm text-gray-800"></select>
      </label>
      <label class="flex items-center space-x-1 text-white text-sm">
        <span>Date</span>
        <div class="flex items-center">
          <button id="prevDateGlobalBtn" type="button" class="px-2 py-1 border border-gray-300 rounded-l bg-white text-gray-800" title="Previous day">&larr;</button>
          <input type="text" id="scheduleDateGlobal" placeholder="MM/DD/YYYY" class="border-t border-b border-gray-300 px-2 py-1 text-sm text-gray-800" />
          <button id="nextDateGlobalBtn" type="button" class="px-2 py-1 border border-gray-300 rounded-r bg-white text-gray-800" title="Next day">&rarr;</button>
        </div>
      </label>
      <button id="copyScheduleGlobalBtn" onclick="openCopyPanel(this, 'scheduleDateGlobal')" class="px-3 py-1 bg-blue-700 text-white rounded-lg hover:bg-blue-800 text-sm">Copy</button>
    </div>
    <!-- Swatches removed from navigation bar; they will appear below the header -->
  </nav>
  <!-- Colour swatch row: place below the navigation bar on the home page -->
  <!-- Right‑align the colour swatches under the navigation bar -->
  <div class="flex flex-wrap gap-2 px-4 py-2 justify-end">
    <button class="swatch" data-brand-from="#3b82f6" data-brand-to="#4f46e5" style="background-image: linear-gradient(to right,#3b82f6,#4f46e5);"></button>
    <button class="swatch" data-brand-from="#1e3a8a" data-brand-to="#312e81" style="background-image: linear-gradient(to right,#1e3a8a,#312e81);"></button>
    <button class="swatch" data-brand-from="#ff8a00" data-brand-to="#ff6a00" style="background-image: linear-gradient(to right,#ff8a00,#ff6a00);"></button>
    <button class="swatch" data-brand-from="#c2410c" data-brand-to="#a53e0a" style="background-image: linear-gradient(to right,#c2410c,#a53e0a);"></button>
    <button class="swatch" data-brand-from="#10b981" data-brand-to="#22c55e" style="background-image: linear-gradient(to right,#10b981,#22c55e);"></button>
    <button class="swatch" data-brand-from="#065f46" data-brand-to="#064e3b" style="background-image: linear-gradient(to right,#065f46,#064e3b);"></button>
    <button class="swatch" data-brand-from="#8b5cf6" data-brand-to="#7c3aed" style="background-image: linear-gradient(to right,#8b5cf6,#7c3aed);"></button>
    <button class="swatch" data-brand-from="#6d28d9" data-brand-to="#4c1d95" style="background-image: linear-gradient(to right,#6d28d9,#4c1d95);"></button>
  </div>
  <main id="viewHost" class="p-6 max-w-5xl mx-auto" data-current-view="home">
    <section data-view="home">
      <h1 class="text-2xl font-bold mb-4">Welcome to Showtime Builder</h1>
      <p class="mb-4">Select a tab above to manage auditoriums, bookings, build prime schedules or view the schedule grid.</p>
      <ul class="list-disc pl-6">
        <li><strong>Auditoriums</strong>: Manage the list of theaters.</li>
        <li><strong>Bookings</strong>: Assign films to slots for the current week.</li>
        <li><strong>Prime</strong>: Choose prime times and build cycles for each booking.</li>
        <li><strong>Schedule</strong>: Interactive grid to adjust individual show times, add manual shows and view the schedule.</li>
        <li><strong>Order</strong>: View all shows sorted by start time and nudge their start earlier or later in 5‑minute increments.</li>
        <li><strong>Gantt</strong>: Visual timeline by auditorium to view and drag shows horizontally to adjust start times or vertically to change auditoriums.</li>
        <li><strong>Audit</strong>: View static reports such as the schedule by film title with gaps between shows.</li>
      </ul>

      <div class="mt-6 bg-white/70 border border-slate-200 rounded-xl shadow-sm p-4">
        <h2 class="text-lg font-semibold mb-3">Single-file migration checklist</h2>
        <ul class="space-y-2 text-sm text-gray-700">
          <li class="flex items-center gap-2"><input type="checkbox" checked disabled class="accent-blue-600" /><span>Navigation shell &amp; home view</span></li>
          <li class="flex items-center gap-2"><input type="checkbox" checked disabled class="accent-blue-600" /><span>Auditoriums view inlined</span></li>
          <li class="flex items-center gap-2"><input type="checkbox" checked disabled class="accent-blue-600" /><span>Bookings view inlined</span></li>
          <li class="flex items-center gap-2"><input type="checkbox" checked disabled class="accent-blue-600" /><span>Prime schedule view inlined</span></li>
          <li class="flex items-center gap-2"><input type="checkbox" checked disabled class="accent-blue-600" /><span>Schedule grid view inlined</span></li>
          <li class="flex items-center gap-2"><input type="checkbox" checked disabled class="accent-blue-600" /><span>Start-time order view inlined</span></li>
          <li class="flex items-center gap-2"><input type="checkbox" checked disabled class="accent-blue-600" /><span>Gantt timeline view inlined</span></li>
          <li class="flex items-center gap-2"><input type="checkbox" checked disabled class="accent-blue-600" /><span>Dashboard analytics view inlined</span></li>
          <li class="flex items-center gap-2"><input type="checkbox" checked disabled class="accent-blue-600" /><span>Audit reports view inlined</span></li>
          <li class="flex items-center gap-2"><input type="checkbox" checked disabled class="accent-blue-600" /><span>Restore per-view control bars inside unified layout</span></li>
          <li class="flex items-center gap-2"><input type="checkbox" checked disabled class="accent-blue-600" /><span>Merge external scripts &amp; styles into single-file bundle</span></li>
        </ul>
      </div>

      <!-- Site information entry: allows the user to specify the cinema site name and number.
           These values are saved in the application state and included in JSON exports.
           When importing a JSON file that contains site information, the fields are pre‑filled. -->
      <div class="mt-8">
        <h2 class="text-xl font-semibold mb-4">Site Information</h2>
        <div class="flex flex-wrap gap-4">
          <label class="flex items-center space-x-2">
            <span class="font-medium">Site Name:</span>
            <input id="siteNameInput" type="text" class="border border-gray-300 rounded px-2 py-1 text-sm" placeholder="Enter site name" />
          </label>
          <label class="flex items-center space-x-2">
            <span class="font-medium">Site Number:</span>
            <input id="siteNumberInput" type="text" class="border border-gray-300 rounded px-2 py-1 text-sm" placeholder="Enter site number" />
          </label>
        </div>
      </div>

      <!-- Data Export/Import controls formerly on the Data tab.  Placing them here
           consolidates functionality on the Home page without adding another tab.
           Users can export their current schedule, import a saved schedule or
           generate a shows CSV. -->
      <div class="mt-8">
        <h2 class="text-xl font-semibold mb-4">Data Export / Import</h2>
        <p class="mb-4">Export your current schedule to a JSON or CSV file, or import a previously saved JSON file to restore your schedule.</p>
        <div class="space-y-4">
          <!-- Standardised button sizing; buttons match those used throughout the app -->
          <button id="exportJsonBtn" class="px-3 py-1 bg-blue-700 text-white rounded-lg hover:bg-blue-800 text-sm">Export JSON</button>
          <!-- Add a CSV export button to download a list of all shows across all dates. -->
          <button id="exportCsvBtn" class="px-3 py-1 bg-green-700 text-white rounded-lg hover:bg-green-800 text-sm">Export CSV</button>
          <!-- Import JSON file input -->
          <div class="flex flex-col gap-2">
            <div>
              <label class="mr-2 font-medium" for="importFileInput">Import JSON (file):</label>
              <input id="importFileInput" type="file" accept=".json" class="border border-gray-300 rounded-lg p-1" />
            </div>
          </div>
          <!-- Add buttons to clear schedules and bookings across all dates. Place them side by side. -->
          <div class="mt-4 flex flex-wrap gap-2">
            <button id="clearAllSchedulesBtn" class="px-3 py-1 bg-red-700 text-white rounded-lg hover:bg-red-800 text-sm">Clear All Schedules</button>
            <button id="clearBookingsTimesBtn" class="px-3 py-1 bg-red-700 text-white rounded-lg hover:bg-red-800 text-sm">Clear Bookings and Times</button>
          </div>
        </div>

        <!-- Removed theme colour examples section as per user request.  The colour swatch selector remains in the navigation bar above. -->
      </div>
      <!-- Bulk Bookings Input: allow users to paste film title, format, runtime and slot
           separated by commas or tabs.  Format is optional; when omitted, leave it
           blank.  Runtime and slot must be provided.  Trailer and cleanup times
           default to 20 minutes.  Each line in the textarea corresponds to one
           booking.  After clicking the Add button, bookings will be added to
           the Bookings tab.  Existing blank rows will be reused before
           appending new rows. -->
      <div class="mt-8">
        <h2 class="text-xl font-semibold mb-2">Bulk Bookings Input</h2>
        <p class="text-sm mb-2 text-gray-600">Paste each booking on a new line in the format:<br>
          <code>Title, Format (optional), Runtime (minutes), Slot</code><br>
          For example: <code>The Big Show,IMAX,120,4</code> or <code>The Big Show,120,4</code>.<br>
          Trailers and clean times will default to 20 minutes.</p>
        <textarea id="bulkBookingsInput" rows="5" class="w-full border border-gray-300 rounded-lg p-2" placeholder="Paste bookings here..."></textarea>
        <button id="addBulkBookingsBtn" class="mt-2 px-3 py-1 bg-blue-700 text-white rounded-lg hover:bg-blue-800 text-sm">Add to Bookings</button>
      </div>
    </section>

    <section data-view="auditoriums" hidden>
      <!-- Expand the page content to the full width and reserve space on the right for the
           Start-time Order panel (28rem). Removing the max-width ensures there is no
           dead space on the left side of the table when the panel is closed. -->
      <!-- Remove reserved right margin so content expands when the order panel is hidden.  The
           order-panel script will shift the page when the panel is open. -->
      <div class="px-6 pt-4 pb-6">
        <h2 class="text-xl font-semibold mb-4">Auditoriums</h2>
        <!-- Standardise button sizing across pages -->
        <button id="addAudBtn" class="mb-3 px-3 py-1 bg-blue-700 text-white rounded-lg hover:bg-blue-800 text-sm">Add Auditorium</button>
        <!-- Button to clear all auditoriums.  Placed next to Add Auditorium for quick bulk removal. -->
        <button id="clearAudBtn" class="mb-3 ml-2 px-3 py-1 bg-red-700 text-white rounded-lg hover:bg-red-800 text-sm">Clear Auditoriums</button>
        <!-- Wrap the auditorium table in a card-table container for card-like styling -->
        <div class="card-table">
          <table>
            <!-- Apply grad-header to ensure the header background matches the theme colour (solid, not gradient) -->
            <thead class="grad-header">
            <tr>
              <!-- Double the column widths from 10ch to 20ch for all auditorium fields. -->
              <th class="px-2 py-1 text-left" style="width:20ch;max-width:20ch;">ID</th>
              <th class="px-2 py-1 text-left" style="width:20ch;max-width:20ch;">Name</th>
              <th class="px-2 py-1 text-left" style="width:20ch;max-width:20ch;">Format</th>
              <th class="px-2 py-1 text-left" style="width:20ch;max-width:20ch;">Seats</th>
              <!-- Column for per-row delete actions.  Narrower width to save space. -->
              <th class="px-2 py-1 text-left" style="width:10ch;max-width:10ch;">Delete</th>
            </tr>
            </thead>
            <tbody id="audBody">
            <!-- rows inserted via JS -->
            </tbody>
          </table>
        </div>
      </div>
    </section>

    <section data-view="bookings" hidden>
      <!-- Expand to full width and reserve space for the Start-time Order panel (28rem).
           Removing the max-width eliminates dead space on the left. -->
      <!-- Remove reserved right margin so the table can use the full width when the order panel is hidden -->
      <div class="px-6 pt-4 pb-6">
        <h2 class="text-xl font-semibold mb-4">Bookings</h2>
        <!-- Add and Clear buttons: the Add button remains in the markup for compatibility but is hidden via JS.  -->
        <!-- Standardise button sizing across pages -->
        <button id="addBookingBtn" class="mb-3 px-3 py-1 bg-blue-700 text-white rounded-lg hover:bg-blue-800 text-sm">Add Booking</button>
        <button id="clearBookingsBtn" class="mb-3 ml-2 px-3 py-1 bg-red-700 text-white rounded-lg hover:bg-red-800 text-sm">Clear Bookings</button>
        <div class="overflow-x-auto">
          <!-- Wrap the bookings table in a card-table container for card-like styling -->
          <div class="card-table">
            <table>
              <!-- Apply grad-header so bookings table header uses a solid colour matching the theme -->
              <thead class="grad-header">
              <tr>
                <!-- Reorder columns so that Slot appears first.  Widths remain unchanged. -->
                <th class="px-2 py-1 text-left">Slot</th>
                <th class="px-2 py-1 text-left">Film Title</th>
                <th class="px-2 py-1 text-left">Format</th>
                <th class="px-2 py-1 text-left">Runtime</th>
                <th class="px-2 py-1 text-left">Trailer</th>
                <th class="px-2 py-1 text-left">Priority</th>
                <th class="px-2 py-1 text-left">Rating</th>
                <th class="px-2 py-1 text-left">Notes &#8211; Policy/Comments</th>
                <th class="px-2 py-1 text-left">Week&#35;</th>
                <th class="px-2 py-1 text-left">Clean&nbsp;up</th>
                <th class="px-2 py-1 text-left">Delete</th>
              </tr>
              </thead>
              <tbody id="bookingBody">
              <!-- rows inserted via JS -->
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </section>

    <section data-view="prime" hidden>
      <div class="px-6 pt-4 pb-6 space-y-4">
        <header class="flex flex-wrap items-center gap-3 bg-white/60 rounded-xl px-4 py-3 shadow">
          <div class="flex items-center gap-2">
            <label class="flex items-center gap-2 text-sm">
              <span class="font-medium">First</span>
              <select id="firstShowPrimeSelect" class="border border-gray-300 rounded px-2 py-1 text-sm text-gray-800"></select>
            </label>
            <label class="flex items-center gap-2 text-sm">
              <span class="font-medium">Last</span>
              <select id="lastShowPrimeSelect" class="border border-gray-300 rounded px-2 py-1 text-sm text-gray-800"></select>
            </label>
          </div>
          <div class="flex items-center gap-2 text-sm">
            <span class="font-medium">Date</span>
            <div class="flex items-center">
              <button id="prevDatePrimeBtn" type="button" class="px-2 py-1 border border-gray-300 rounded-l bg-white text-gray-800" title="Previous day">&larr;</button>
              <input type="text" id="scheduleDatePrime" placeholder="MM/DD/YYYY" class="border-t border-b border-gray-300 px-2 py-1 text-sm text-gray-800" />
              <button id="nextDatePrimeBtn" type="button" class="px-2 py-1 border border-gray-300 rounded-r bg-white text-gray-800" title="Next day">&rarr;</button>
            </div>
          </div>
          <div class="flex items-center gap-2 ml-auto">
            <button id="clearTimesBtn" class="px-3 py-1 bg-red-700 text-white rounded-lg hover:bg-red-800 text-sm">Clear Times</button>
            <button id="copyScheduleBtn" onclick="openCopyPanel(this, 'scheduleDatePrime')" class="px-3 py-1 bg-blue-700 text-white rounded-lg hover:bg-blue-800 text-sm">Copy</button>
          </div>
        </header>
        <div>
          <h2 class="text-xl font-semibold mb-4">Build Prime Schedule</h2>
          <div class="overflow-x-auto">
            <!-- Use table-auto so column widths adjust to their content. Removing the fixed layout
                 allows pre and post time columns to expand naturally instead of crowding. -->
            <!-- Apply dense-table class to make prime schedule rows more compact -->
            <table class="dense-table min-w-full w-full rounded-xl overflow-hidden ring-1 ring-slate-200 shadow bg-white">
              <!-- Use gradient styling similar to the original Showtime Builder header.  We split the pre and post columns
                   into eight individual cells to prevent long strings of times from crowding together.  The first pre
                   and post cell are labelled; the rest are empty to maintain alignment. -->
              <!-- Header: apply the gradient across the entire row so all column labels are legible.  The
                   text colour is forced to white via the grad-header class.  Each pre and post
                   column is given an explicit width in ch units to align with the times displayed in
                   the body.  We label only the first pre and post cells; the rest are blank for
                   alignment. -->
              <thead class="grad-header text-xs">
                <tr>
                  <th class="px-2 py-1 text-left align-middle whitespace-nowrap">Aud</th>
                  <th class="px-2 py-1 text-left align-middle whitespace-nowrap">Slot</th>
                  <th class="px-2 py-1 text-left align-middle whitespace-nowrap">Film Title</th>
                  <th class="px-2 py-1 text-left align-middle whitespace-nowrap">Turnkey</th>
                  <!-- Pre time headers: first labelled, subsequent blanks -->
                  <th class="px-2 py-1 text-center align-middle whitespace-nowrap">Pre</th>
                  <th class="px-2 py-1"></th>
                  <th class="px-2 py-1"></th>
                  <th class="px-2 py-1"></th>
                  <th class="px-2 py-1"></th>
                  <th class="px-2 py-1"></th>
                  <th class="px-2 py-1"></th>
                  <th class="px-2 py-1"></th>
                  <!-- Prime column header: styled like the rest of the row; we rely on the gradient
                       for visual emphasis rather than a different background.  -->
                  <th class="px-2 py-1 text-center align-middle whitespace-nowrap">Prime</th>
                  <!-- Post time headers: first labelled, subsequent blanks -->
                  <th class="px-2 py-1 text-center align-middle whitespace-nowrap">Post</th>
                  <th class="px-2 py-1"></th>
                  <th class="px-2 py-1"></th>
                  <th class="px-2 py-1"></th>
                  <th class="px-2 py-1"></th>
                  <th class="px-2 py-1"></th>
                  <th class="px-2 py-1"></th>
                  <th class="px-2 py-1"></th>
                </tr>
              </thead>
              <tbody id="primeBody" class="divide-y divide-gray-200 odd:bg-white even:bg-gray-50 text-sm">
                <!-- rows inserted via JS -->
              </tbody>
            </table>
          </div>
          <p class="text-sm text-gray-600 mt-3">Select a prime time for each booking. Pre and post times are automatically calculated. Duplicate prime times across auditoriums are highlighted.</p>
        </div>
      </div>
    </section>

    <section data-view="schedule" hidden>
      <div class="px-6 pt-4 pb-6 space-y-4">
        <header class="flex flex-wrap items-center gap-3 bg-white/60 rounded-xl px-4 py-3 shadow">
          <div class="flex items-center gap-2">
            <label class="flex items-center gap-2 text-sm">
              <span class="font-medium">First</span>
              <select id="firstShowSelect" class="border border-gray-300 rounded px-2 py-1 text-sm text-gray-800"></select>
            </label>
            <label class="flex items-center gap-2 text-sm">
              <span class="font-medium">Last</span>
              <select id="lastShowSelect" class="border border-gray-300 rounded px-2 py-1 text-sm text-gray-800"></select>
            </label>
          </div>
          <div class="flex items-center gap-2 text-sm">
            <span class="font-medium">Date</span>
            <div class="flex items-center">
              <button id="prevDateGridBtn" type="button" class="px-2 py-1 border border-gray-300 rounded-l bg-white text-gray-800" title="Previous day">&larr;</button>
              <input type="text" id="scheduleDateGrid" placeholder="MM/DD/YYYY" class="border-t border-b border-gray-300 px-2 py-1 text-sm text-gray-800" />
              <button id="nextDateGridBtn" type="button" class="px-2 py-1 border border-gray-300 rounded-r bg-white text-gray-800" title="Next day">&rarr;</button>
            </div>
          </div>
          <div class="flex items-center gap-2 ml-auto">
            <button id="clearTimesGridBtn" class="px-3 py-1 bg-red-700 text-white rounded-lg hover:bg-red-800 text-sm">Clear Times</button>
            <button id="copyScheduleGridBtn" onclick="openCopyPanel(this, 'scheduleDateGrid')" class="px-3 py-1 bg-blue-700 text-white rounded-lg hover:bg-blue-800 text-sm">Copy</button>
          </div>
        </header>
        <div class="flex flex-wrap items-center gap-3">
          <button id="addRowBtn" class="px-3 py-1 bg-blue-700 text-white rounded-lg hover:bg-blue-800 text-sm">Add Row</button>
          <button id="toggleEndBtn" class="px-3 py-1 bg-blue-700 text-white rounded-lg hover:bg-blue-800 text-sm">Hide End Times</button>
          <button id="undoBtn" class="px-3 py-1 bg-blue-700 text-white rounded-lg hover:bg-blue-800 text-sm">Undo</button>
          <button id="sortRowsBtn" class="px-3 py-1 bg-blue-700 text-white rounded-lg hover:bg-blue-800 text-sm">Sort Auds</button>
        </div>
        <div class="overflow-x-auto">
          <div class="card-table dense-schedule" data-nav-grid>
            <table>
              <thead id="gridHead" class="grad-header text-sm"></thead>
              <tbody id="gridBody"></tbody>
            </table>
          </div>
        </div>
        <p class="text-xs text-gray-600">Type a time (e.g., 7a or 705a) in an empty cell to add a manual show at that time. Changing a time only affects that show, not the entire row. Use Undo to revert the most recent change.</p>
      </div>
    </section>

    <section data-view="order" hidden>
      <div class="px-6 pt-4 pb-6">
        <div class="overflow-x-auto">
          <table class="w-full rounded-xl overflow-hidden ring-1 ring-slate-200 shadow bg-white text-sm text-gray-800">
            <thead class="grad-header text-xs uppercase tracking-wide sticky top-0 z-10 text-white/90">
              <tr>
                <th class="px-2 py-1 text-left">Start</th>
                <th class="px-2 py-1 text-left">Clean</th>
                <th class="px-2 py-1 text-left">Aud</th>
                <th class="px-2 py-1 text-left">Film</th>
                <th class="px-2 py-1 text-left">Nudge</th>
              </tr>
            </thead>
            <tbody id="orderBody" class="text-sm"></tbody>
          </table>
        </div>
        <p class="text-sm text-gray-600 mt-3">Use the ▲/▼ buttons to nudge show start times earlier or later in 5‑minute increments. These changes persist across all views.</p>
      </div>
    </section>

    <section data-view="gantt" hidden>
      <div class="px-6 pt-4 pb-2">
        <div class="flex flex-wrap items-center gap-3 bg-white/60 rounded-xl px-4 py-3 shadow">
          <label class="flex items-center gap-2 text-sm">
            <span class="font-medium">First</span>
            <select id="firstShowGanttSelect" class="border border-gray-300 rounded px-2 py-1 text-sm text-gray-800"></select>
          </label>
          <label class="flex items-center gap-2 text-sm">
            <span class="font-medium">Last</span>
            <select id="lastShowGanttSelect" class="border border-gray-300 rounded px-2 py-1 text-sm text-gray-800"></select>
          </label>
          <label class="flex items-center gap-2 text-sm">
            <span class="font-medium">Date</span>
            <div class="flex items-center">
              <button id="prevDateGanttBtn" type="button" class="px-2 py-1 border border-gray-300 rounded-l bg-white text-gray-800" title="Previous day">&larr;</button>
              <input type="text" id="scheduleDateGantt" placeholder="MM/DD/YYYY" class="border-t border-b border-gray-300 px-2 py-1 text-sm text-gray-800" />
              <button id="nextDateGanttBtn" type="button" class="px-2 py-1 border border-gray-300 rounded-r bg-white text-gray-800" title="Next day">&rarr;</button>
            </div>
          </label>
          <div class="flex items-center gap-2 ml-auto">
            <button id="clearTimesGanttBtn" class="px-3 py-1 bg-red-700 text-white rounded-lg hover:bg-red-800 text-sm">Clear Times</button>
            <button id="copyScheduleGanttBtn" onclick="openCopyPanel(this, 'scheduleDateGantt')" class="px-3 py-1 bg-blue-700 text-white rounded-lg hover:bg-blue-800 text-sm">Copy</button>
          </div>
        </div>
      </div>
      <div class="px-6 pb-6">
        <div id="filmTray" class="sticky top-0 z-20 bg-white/90 backdrop-blur border-b p-2 flex flex-wrap gap-2"></div>
        <h2 class="text-xl font-semibold mb-3">Gantt Timeline</h2>
        <div class="overflow-x-auto">
          <div id="ganttContainer" class="relative rounded-xl overflow-hidden ring-1 ring-slate-200 shadow bg-white"></div>
        </div>
      </div>
    </section>

    <section data-view="dashboard" hidden>
      <div class="p-6 space-y-8">
        <h1 class="text-2xl font-bold">Dashboard</h1>
        <p class="text-sm text-gray-600">Summary charts showing the distribution of showtimes by film, auditorium and start time for the selected date.</p>
        <div class="grid md:grid-cols-2 gap-8">
          <div class="bg-white shadow rounded-lg p-4">
            <h2 class="text-lg font-semibold mb-2">Shows by Film</h2>
            <table class="min-w-full table-fixed w-full rounded-lg overflow-hidden ring-1 ring-slate-200">
              <thead class="grad-header text-xs">
                <tr>
                  <th class="px-2 py-1 text-left">Film</th>
                  <th class="px-2 py-1 text-right">Shows</th>
                </tr>
              </thead>
              <tbody id="filmSummaryBody" class="divide-y divide-gray-200 text-sm"></tbody>
            </table>
          </div>
          <div class="bg-white shadow rounded-lg p-4">
            <h2 class="text-lg font-semibold mb-2">Shows by Auditorium</h2>
            <table class="min-w-full table-fixed w-full rounded-lg overflow-hidden ring-1 ring-slate-200">
              <thead class="grad-header text-xs">
                <tr>
                  <th class="px-2 py-1 text-left">Auditorium</th>
                  <th class="px-2 py-1 text-right">Shows</th>
                </tr>
              </thead>
              <tbody id="audSummaryBody" class="divide-y divide-gray-200 text-sm"></tbody>
            </table>
          </div>
        </div>
        <div class="grid md:grid-cols-1 gap-8 mt-8">
          <div class="bg-white shadow rounded-lg p-4">
            <h2 class="text-lg font-semibold mb-2">Start &amp; End Time Distribution (per hour)</h2>
            <table class="min-w-full table-fixed w-full rounded-lg overflow-hidden ring-1 ring-slate-200">
              <thead class="grad-header text-xs">
                <tr>
                  <th class="px-2 py-1 text-left">Hour</th>
                  <th class="px-2 py-1 text-right">Starts</th>
                  <th class="px-2 py-1 text-right">Seats</th>
                  <th class="px-2 py-1 text-right">Ends</th>
                </tr>
              </thead>
              <tbody id="timeSummaryBody" class="divide-y divide-gray-200 text-sm"></tbody>
            </table>
          </div>
        </div>
        <div class="grid md:grid-cols-1 gap-8 mt-8">
          <div class="bg-white shadow rounded-lg p-4">
            <h2 class="text-lg font-semibold mb-2">Auditorium Utilisation</h2>
            <table class="min-w-full table-fixed w-full rounded-lg overflow-hidden ring-1 ring-slate-200">
              <thead class="grad-header text-xs">
                <tr>
                  <th class="px-2 py-1 text-left">Auditorium</th>
                  <th class="px-2 py-1 text-right">Utilisation</th>
                </tr>
              </thead>
              <tbody id="utilSummaryBody" class="divide-y divide-gray-200 text-sm"></tbody>
            </table>
          </div>
        </div>
        <div class="bg-white shadow rounded-lg p-4">
          <h2 class="text-lg font-semibold mb-2">Flagged Issues</h2>
          <ul id="flaggedList" class="list-disc pl-5 space-y-1 text-sm text-gray-700"></ul>
        </div>
      </div>
    </section>

    <section data-view="audit" hidden>
      <div class="px-6 pt-4 pb-2">
        <div class="flex flex-wrap items-center gap-3 bg-white/60 rounded-xl px-4 py-3 shadow">
          <label class="flex items-center gap-2 text-sm">
            <span class="font-medium">First</span>
            <select id="firstShowAuditSelect" class="border border-gray-300 rounded px-2 py-1 text-sm text-gray-800"></select>
          </label>
          <label class="flex items-center gap-2 text-sm">
            <span class="font-medium">Last</span>
            <select id="lastShowAuditSelect" class="border border-gray-300 rounded px-2 py-1 text-sm text-gray-800"></select>
          </label>
          <label class="flex items-center gap-2 text-sm">
            <span class="font-medium">Date</span>
            <div class="flex items-center">
              <button id="prevDateAuditBtn" type="button" class="px-2 py-1 border border-gray-300 rounded-l bg-white text-gray-800" title="Previous day">&larr;</button>
              <input type="text" id="scheduleDateAudit" placeholder="MM/DD/YYYY" class="border-t border-b border-gray-300 px-2 py-1 text-sm text-gray-800" />
              <button id="nextDateAuditBtn" type="button" class="px-2 py-1 border border-gray-300 rounded-r bg-white text-gray-800" title="Next day">&rarr;</button>
            </div>
          </label>
          <div class="flex items-center gap-2 ml-auto">
            <button id="clearTimesAuditBtn" class="px-3 py-1 bg-red-700 text-white rounded-lg hover:bg-red-800 text-sm">Clear Times</button>
            <button id="copyScheduleAuditBtn" onclick="openCopyPanel(this, 'scheduleDateAudit')" class="px-3 py-1 bg-blue-700 text-white rounded-lg hover:bg-blue-800 text-sm">Copy</button>
          </div>
        </div>
      </div>
      <div class="px-6 pb-6">
        <h2 class="text-xl font-semibold mb-4">Audit</h2>
        <div class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-4 gap-4">
          <div>
            <h3 class="text-lg font-semibold mb-2">Schedule by Film</h3>
            <div>
              <table class="min-w-full table-fixed w-full rounded-xl overflow-hidden ring-1 ring-slate-200 shadow bg-white">
                <thead class="grad-header text-xs">
                  <tr>
                    <th class="px-2 py-1 text-left">Film</th>
                    <th class="px-2 py-1 text-left">Start</th>
                    <th class="px-2 py-1 text-left">Auditorium</th>
                    <th class="px-2 py-1 text-left">Gap</th>
                  </tr>
                </thead>
                <tbody id="auditByFilmBody" class="divide-y divide-gray-200 odd:bg-white even:bg-gray-50 text-sm"></tbody>
              </table>
            </div>
          </div>
          <div>
            <h3 class="text-lg font-semibold mb-2">House Placement Audit</h3>
            <div>
              <table class="min-w-full table-fixed w-full rounded-xl overflow-hidden ring-1 ring-slate-200 shadow bg-white">
                <thead class="grad-header text-xs">
                  <tr>
                    <th class="px-2 py-1 text-left">Film</th>
                    <th class="px-2 py-1 text-left">Auditoriums</th>
                  </tr>
                </thead>
                <tbody id="housePlacementBody" class="divide-y divide-gray-200 odd:bg-white even:bg-gray-50 text-sm"></tbody>
              </table>
            </div>
          </div>
          <div>
            <h3 class="text-lg font-semibold mb-2">Shows per Aud</h3>
            <div>
              <table class="min-w-full table-fixed w-full rounded-xl overflow-hidden ring-1 ring-slate-200 shadow bg-white">
                <thead class="grad-header text-xs">
                  <tr>
                    <th class="px-2 py-1 text-left">Auditorium</th>
                    <th class="px-2 py-1 text-left">Seats</th>
                    <th class="px-2 py-1 text-left">Shows</th>
                    <th class="px-2 py-1 text-left">First Show</th>
                    <th class="px-2 py-1 text-left">Last Show</th>
                  </tr>
                </thead>
                <tbody id="showsPerAudBody" class="divide-y divide-gray-200 odd:bg-white even:bg-gray-50 text-sm"></tbody>
              </table>
            </div>
          </div>
          <div>
            <h3 class="text-lg font-semibold mb-2">Shows per Feature</h3>
            <div>
              <table class="min-w-full table-fixed w-full rounded-xl overflow-hidden ring-1 ring-slate-200 shadow bg-white">
                <thead class="grad-header text-xs">
                  <tr>
                    <th class="px-2 py-1 text-left">Film</th>
                    <th class="px-2 py-1 text-left">Prints</th>
                    <th class="px-2 py-1 text-left">Shows</th>
                    <th class="px-2 py-1 text-left">First Show</th>
                    <th class="px-2 py-1 text-left">Last Show</th>
                  </tr>
                </thead>
                <tbody id="showsPerFeatureBody" class="divide-y divide-gray-200 odd:bg-white even:bg-gray-50 text-sm"></tbody>
              </table>
            </div>
          </div>
        </div>
      </div>
    </section>
  </main>
  <script>
    (function() {
      function initNavigationController() {
        const host = document.getElementById('viewHost');
        const sections = host ? Array.from(host.querySelectorAll('[data-view]')) : [];
        const navButtons = Array.from(document.querySelectorAll('[data-view-target]'));
        const knownViews = new Set(sections.map(section => section.dataset.view));

        function activate(view) {
          if (!host || !view) return false;
          let matched = false;
          sections.forEach(section => {
            const isMatch = section.dataset.view === view;
            section.hidden = !isMatch;
            if (isMatch) {
              matched = true;
            }
          });
          if (matched) {
            host.dataset.currentView = view;
            navButtons.forEach(btn => {
              btn.classList.toggle('active-nav', btn.dataset.viewTarget === view);
            });
            try {
              window.dispatchEvent(new CustomEvent('showtimeViewActivated', { detail: { view } }));
            } catch (err) {
              const evt = document.createEvent('Event');
              evt.initEvent('showtimeViewActivated', true, true);
              evt.view = view;
              window.dispatchEvent(evt);
            }
          }
          return matched;
        }

        navButtons.forEach(btn => {
          btn.addEventListener('click', () => {
            const view = btn.dataset.viewTarget;
            if (knownViews.has(view)) {
              activate(view);
            } else {
              const fallback = btn.dataset.fallbackHref;
              if (fallback) {
                window.location.href = fallback;
              }
            }
          });
        });

        const initialView = (host && host.dataset.currentView) || (sections[0] && sections[0].dataset.view);
        if (initialView) {
          activate(initialView);
        }
      }

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initNavigationController);
      } else {
        initNavigationController();
      }
    })();
  </script>
      <script>
// app.js
// Global state and utilities for the showtime builder application.
// This script is included on every page. It exposes a ShowtimeState
// object on the window with current state and helper methods. State is
// persisted to localStorage under a single key. Pages should call
// ShowtimeState.load() on load and then use ShowtimeState.state to
// read the current values. Mutating functions automatically save and
// optionally trigger callbacks.

(function(){
  const LOCAL_KEY = "showtime:persist";

  // Default seeds for auditoriums, films and bookings. These mirror
  // the original React seeds but can be extended by the user.
  const defaultState = {
    auds: [
      {id: 1, name: "Aud 1", format: "Standard", seats: 200},
      {id: 2, name: "Aud 2", format: "Standard", seats: 190},
      {id: 3, name: "Aud 3", format: "3D", seats: 150},
      {id: 4, name: "Aud 4", format: "Laser", seats: 210},
      {id: 5, name: "Aud 5", format: "Standard", seats: 140},
      {id: 6, name: "Aud 6", format: "Standard", seats: 140},
    ],
    films: [
      {id: "F1", title: "Thunder Road", rating: "PG-13", runtime: 124, trailer: 18, clean: 20, priority: 1},
      {id: "F2", title: "Moon Harbor", rating: "R", runtime: 108, trailer: 16, clean: 20, priority: 2},
      {id: "F3", title: "Galaxy Kids 3D", rating: "PG", runtime: 97, trailer: 15, clean: 15, priority: 3},
    ],
    // Bookings tie films to slots and weeks. Week values are numeric and may
    // be ignored by this app; they are placeholders for extension. A slot
    // simply labels a booking and is shown on the prime page.
    bookings: [
      {id: "B1", week: 34, slot: "1", filmId: "F1", notes: "", weeksOut: 1},
      {id: "B2", week: 34, slot: "2", filmId: "F2", notes: "", weeksOut: 1},
      {id: "B3", week: 34, slot: "3", filmId: "F3", notes: "", weeksOut: 1},
    ],
    // Prime rows mirror bookings with selected prime times. Each entry
    // references a booking by id and stores an auditorium assignment and
    // prime time. The prime time is stored as an HM string (HH:MM). New
    // bookings without a prime time remain blank until selected on the
    // prime page or schedule grid.
    primeRows: [],
    // Extra rows are user‑added rows that behave like prime rows but are
    // not backed by a booking. They have a unique rowId beginning with
    // "EX-", a slot (string) and references to filmId, audId and
    // primeHM. They allow building custom cycles beyond the bookings.
    extraRows: [],
    // Manual shows are single show instances created directly on the
    // schedule grid. They do not participate in cycling like prime rows and
    // persist independently. Each has its own id, rowId, audId, audName,
    // filmId, filmTitle, start (Date), end (Date), runtime, trailer,
    // clean and cycle. They can be deleted by hiding the show (selecting
    // blank in the dropdown).
    manualShows: [],
    // Overrides allow editing individual show start times or auditorium
    // assignments without altering the base schedule. The key is the show
    // id (rowId:offset) and the value is an object with optional
    // start (Date), audId (number) and filmId (string). An override
    // leaves all other fields of the base show untouched.
    overrides: {},
    // Hidden shows are shows removed from the schedule grid. They remain
    // in state for undo but are filtered out of the showtime list. Keys
    // are show ids and values are true.
    hiddenShows: {},
    // When multi-date support is enabled, schedule data for each date is stored
    // under scheduleByDate. Each entry keyed by a date string (YYYY-MM-DD)
    // contains the arrays of primeRows, extraRows, manualShows, overrides,
    // hiddenShows and undoStack for that specific date. This allows
    // switching between schedules without losing data. If undefined, the
    // app operates in single-date mode using top-level fields. See
    // initDateSupport() and setDate() for details.
    scheduleByDate: {},
    // The currently selected date for the schedule. When null, the app
    // will default to today's date on first initialisation. The date
    // string must be in ISO format (YYYY-MM-DD) so that lexical sorting
    // matches chronological order.
    currentDate: null,
    // The currently configured first and last show times. These are HM
    // strings. The lastShowHM may represent a time after midnight (e.g.
    // "02:00"). In such cases, code that compares dates must treat the
    // last show as belonging to the next day. See dtFromHM below.
    firstShowHM: "07:00", // 7:00a
    lastShowHM: "23:00",  // 11:00p
    // Whether to display end times beneath start times on the schedule
    // grid. Toggled via Hide End Times button.
    showEndTimes: true,
    // Stack of undo operations. Each entry has a type and data needed to
    // revert. For now, only edits to show start times and manual show
    // additions are recorded.
    undoStack: [],
    // Controls whether the Start‑time Order panel is open. When true,
    // order-panel.js will show the side panel by default and leave the
    // main content shifted left. Persisting this flag allows the panel
    // to remain open across tab navigations.
    showOrderPanel: true,
  };

  // Local copy of state. Loaded on first access. All modifications should
  // go through setState or dedicated mutators to ensure persistence.
  let state = null;

  // Helper: pad single digit to two digits.
  function pad(n) { return n.toString().padStart(2, "0"); }

  // Convert HH:MM string to a Date representing today at that time. If the
  // time is between 0:00 and 4:59, treat it as belonging to the next day
  // only for end-of-day comparisons. Consumers must handle this where
  // relevant. This function never rolls over the date by itself; it
  // always returns today at the given time.
  function dtFromHM(hm) {
    if (typeof hm !== 'string') hm = '0:00';
    const m = hm.match(/^(\d{1,2}):(\d{1,2})$/);
    let H = 0, M = 0;
    if (m) {
      H = Math.min(23, Math.max(0, parseInt(m[1], 10) || 0));
      M = Math.min(59, Math.max(0, parseInt(m[2], 10) || 0));
    }
    const d = new Date();
    d.setHours(H, M, 0, 0);
    return d;
  }

  // Convert a Date to HH:MM string in 24‑hour format.
  function hmFromDate(d) { return pad(d.getHours()) + ":" + pad(d.getMinutes()); }

  // Add minutes to a date, returning a new Date.
  function addMins(d, mins) { const nd = new Date(d.getTime()); nd.setMinutes(nd.getMinutes() + mins); return nd; }

  // Difference in minutes between two dates (a - b).
  function diffMins(a, b) { return Math.round((a.getTime() - b.getTime()) / 60000); }

  // Round a number up to the nearest multiple of five.
  function roundUp5(x) { return Math.ceil(x / 5) * 5; }

  // Convert a date to a 12‑hour time with am/pm suffix (e.g. "10:30p").
  function to12(d) {
    // Format a Date to 12‑hour time with am/pm suffix.
    // Hours 0‑11 are AM and 12‑23 are PM. Midnight should be 12:MMam and noon 12:MMpm.
    let h = d.getHours();
    const m = pad(d.getMinutes());
    const isPm = h >= 12;
    // Convert to 12‑hour format (0 becomes 12, 13 becomes 1).
    h = h % 12 || 12;
    // Use explicit am/pm suffix rather than a single letter. This improves readability
    // for time pickers and selectors.
    const suffix = isPm ? 'pm' : 'am';
    return `${h}:${m}${suffix}`;
  }

  // Given a film object, compute the total minutes of a show cycle (runtime + trailer + clean),
  // rounded up to the nearest 5 minutes.
  function cycleMinutes(film) {
    if (!film) return 0;
    const total = (film.runtime || 0) + (film.trailer || 0) + (film.clean || 0);
    return roundUp5(total);
  }

  // Compute the end time of a show given a start and film definition.
  function endOfMovie(start, film) {
    return addMins(start, (film.runtime || 0) + (film.trailer || 0));
  }

  // Format duration (minutes) to H:MM (e.g. 2:10).
  function fmtDur(mins) {
    return `${Math.floor(mins / 60)}:${pad(mins % 60)}`;
  }

  // Convert an ISO date string (YYYY-MM-DD) to MM/DD/YYYY format. If the
  // input is invalid, return the original string. Note that this
  // utility does not change the underlying date object; it merely
  // reformats the string for display. This is useful for rendering
  // dates in the US style (e.g. 2025-08-19 -> 08/19/2025).
  function isoToMMDD(dateStr) {
    if (!dateStr || typeof dateStr !== 'string') return dateStr;
    const parts = dateStr.split('-');
    if (parts.length !== 3) return dateStr;
    const [y, m, d] = parts;
    return `${m}/${d}/${y}`;
  }

  // Convert a MM/DD/YYYY string to ISO format (YYYY-MM-DD). If the
  // input is invalid or cannot be parsed, returns null. This helper
  // splits on either '/' or '-' for robustness. Leading zeros are
  // added to the month and day parts. The year must be four digits.
  function mmddToIso(mmdd) {
    if (!mmdd || typeof mmdd !== 'string') return null;
    // Split on common separators
    const parts = mmdd.trim().split(/[\/-]/);
    if (parts.length !== 3) return null;
    let [m, d, y] = parts;
    // Ensure year has four digits
    if (y.length !== 4) return null;
    // Pad month and day to two digits
    m = m.padStart(2, '0');
    d = d.padStart(2, '0');
    // Basic validation
    const mm = parseInt(m, 10);
    const dd = parseInt(d, 10);
    const yyyy = parseInt(y, 10);
    if (
      isNaN(mm) || isNaN(dd) || isNaN(yyyy) ||
      mm < 1 || mm > 12 ||
      dd < 1 || dd > 31 ||
      yyyy < 1000 || yyyy > 9999
    ) {
      return null;
    }
    return `${y}-${m}-${d}`;
  }

  // Convert HM string to 12‑hour display format (e.g. "14:00" -> "2:00p").
  function fmtHM(hm) {
    return to12(dtFromHM(hm));
  }

  // Load persisted state from localStorage. Merge with defaults to fill in
  // any missing keys. Called automatically on first access.
  function load() {
    if (state) return state;
    let loaded = {};
    try {
      const raw = localStorage.getItem(LOCAL_KEY);
      if (raw) loaded = JSON.parse(raw);
    } catch (e) {
      console.error('Failed to parse saved state', e);
    }
    state = { ...defaultState, ...loaded };
    // When rehydrating from localStorage, convert any serialized Dates back
    // into Date objects. Otherwise fields like manualShows.start/end or
    // overrides.start will remain strings and later property accesses
    // (e.g. getTime()) will throw. Iterate through collections and
    // hydrate strings into Date instances. This only runs once during
    // initial load.
    // Convert manual show start/end strings to Dates
    if (state.manualShows && Array.isArray(state.manualShows)) {
      state.manualShows.forEach(ms => {
        if (ms && typeof ms.start === 'string') {
          const d = new Date(ms.start);
          if (!isNaN(d)) ms.start = d;
        }
        if (ms && typeof ms.end === 'string') {
          const d2 = new Date(ms.end);
          if (!isNaN(d2)) ms.end = d2;
        }
      });
    }
    // Convert override start strings to Dates
    if (state.overrides && typeof state.overrides === 'object') {
      Object.values(state.overrides).forEach(ov => {
        if (ov && typeof ov.start === 'string') {
          const d = new Date(ov.start);
          if (!isNaN(d)) ov.start = d;
        }
      });
    }
    // Ensure primeRows and extraRows are arrays
    if (!Array.isArray(state.primeRows)) state.primeRows = [];
    if (!Array.isArray(state.extraRows)) state.extraRows = [];
    if (!Array.isArray(state.manualShows)) state.manualShows = [];
    if (!state.overrides || typeof state.overrides !== 'object') state.overrides = {};
    if (!state.hiddenShows || typeof state.hiddenShows !== 'object') state.hiddenShows = {};
    if (!Array.isArray(state.undoStack)) state.undoStack = [];

    // Ensure siteName and siteNumber fields exist. These identify the theatre
    // or site and are included in exported JSON. When not provided, default
    // to empty strings so that input fields bind to valid values.
    if (state.siteName === undefined || state.siteName === null) state.siteName = '';
    if (state.siteNumber === undefined || state.siteNumber === null) state.siteNumber = '';
    return state;
  }

  // Persist current state to localStorage. Certain transient keys may be
  // excluded here if needed (e.g. undoStack), but currently everything is
  // persisted.
  function save() {
    // When multi‑date support is enabled and a current date is set,
    // update the scheduleByDate entry for the current date before
    // persisting. This ensures that changes to primeRows, extraRows,
    // manualShows, overrides, hiddenShows and undoStack are captured
    // under the currentDate key. This is safe because JSON.stringify
    // will serialise Date objects to ISO strings. If scheduleByDate
    // doesn't exist, create it.
    if (state && state.currentDate) {
      if (!state.scheduleByDate || typeof state.scheduleByDate !== 'object') {
        state.scheduleByDate = {};
      }
      state.scheduleByDate[state.currentDate] = {
        primeRows: Array.isArray(state.primeRows) ? state.primeRows : [],
        extraRows: Array.isArray(state.extraRows) ? state.extraRows : [],
        manualShows: Array.isArray(state.manualShows) ? state.manualShows : [],
        overrides: state.overrides || {},
        hiddenShows: state.hiddenShows || {},
        undoStack: Array.isArray(state.undoStack) ? state.undoStack : [],
      };
      // Keep only the most recent 7 dates to avoid unbounded growth
      pruneOldSchedules();
    }
    try {
      localStorage.setItem(LOCAL_KEY, JSON.stringify(state));
    } catch (e) {
      console.error('Failed to save state', e);
    }
    // Notify listeners within the same tab that the state has changed. The
    // native 'storage' event only fires on other tabs; dispatching a
    // custom event allows components like the start‑time order panel to
    // react immediately without polling or page navigation. The event name
    // is namespaced to avoid collisions.
    try {
      const evt = new Event('showtimeStateUpdated');
      window.dispatchEvent(evt);
    } catch (err) {
      // Older browsers may not support Event constructor; ignore.
    }
  }

  // Helper to clone an object (shallow) using JSON. Only used for
  // simple clones of state prior to modification when pushing to undo.
  function clone(obj) {
    return JSON.parse(JSON.stringify(obj));
  }

  // Retrieve film by id.
  function filmById(id) {
    return state.films.find(f => f.id === id) || null;
  }

  // Retrieve auditorium by id.
  function audById(id) {
    return state.auds.find(a => a.id === id) || null;
  }

  // Compute all showtime records for a single row based on its primeHM,
  // filmId and audId. A record contains id, rowId, offset, film info and
  // computed start/end times. Only shows within the first/last show
  // window are included.
  function buildRowShowtimes(row) {
    const film = filmById(row.filmId);
    const aud = audById(row.audId);
    if (!film || !aud || !row.primeHM) return [];
    const first = dtFromHM(state.firstShowHM);
    const last = dtFromHM(state.lastShowHM);
    // If last show is between midnight and 4:59, treat as next day
    if (last.getHours() < 5) last.setDate(last.getDate() + 1);
    const prime = dtFromHM(row.primeHM);
    // Determine cycle length
    const cycle = cycleMinutes(film);
    // Guard against zero or negative cycles (e.g., films with 0 runtime/trailer/clean).
    // A zero cycle would cause divide‑by‑zero in preCount/postCount calculations and hang the grid.
    if (!cycle || cycle <= 0) {
      return [];
    }
    const out = [];
    // Determine how many pre and post shows fit in the window
    const preCount = Math.floor(diffMins(prime, first) / cycle);
    const postCount = Math.floor(diffMins(last, prime) / cycle);
    for (let i = preCount; i >= 1; i--) {
      const st = addMins(prime, -i * cycle);
      if (st < first) continue;
      out.push(makeRec(row, -i, st, film, aud));
    }
    // Always include the prime show itself regardless of the first/last
    // window. Without this, rows whose primeHM falls outside the
    // configured start/end window disappear from the schedule grid.  We
    // still filter pre/post shows relative to the window below.
    out.push(makeRec(row, 0, prime, film, aud));
    for (let i = 1; i <= postCount; i++) {
      const st = addMins(prime, i * cycle);
      if (st > last) continue;
      out.push(makeRec(row, i, st, film, aud));
    }
    return out;
  }

  // Helper to build a single show record from row and offset.
  function makeRec(row, off, start, film, aud) {
    return {
      id: `${row.rowId}:${off}`,
      rowId: row.rowId,
      offset: off,
      audId: aud.id,
      audName: aud.name,
      filmId: film.id,
      // Include film format in the display title if present.  If a film has a
      // non‑empty format (e.g. "3D"), append it to the film title.  This
      // ensures that downstream consumers like the schedule and Gantt pages
      // display the parent film name together with its format.
      filmTitle: film.title + (film.format ? ' ' + film.format : ''),
      start: start,
      end: endOfMovie(start, film),
      runtime: film.runtime,
      trailer: film.trailer,
      clean: film.clean,
      cycle: cycleMinutes(film),
      source: 'Prime',
    };
  }

  // Compute a flattened array of all shows, applying overrides and
  // excluding hidden shows. Includes manual shows at their specified
  // times. If an override exists for a show id, its start or
  // auditorium assignment is updated accordingly. Overrides on filmId
  // are also applied.
  function getAllShows() {
    const shows = [];
    // Build from prime and extra rows
    const rows = (state.primeRows || []).concat(state.extraRows || []);
    rows.forEach(row => {
      buildRowShowtimes(row).forEach(rec => {
        shows.push(rec);
      });
    });
    // Include manual shows
    (state.manualShows || []).forEach(ms => {
      shows.push({ ...ms, source: 'Manual' });
    });
    // Apply overrides and filter hidden shows
    const mapped = shows
      .filter(r => !state.hiddenShows[r.id])
      .map(r => {
        const ov = state.overrides[r.id];
        if (!ov) return r;
        const updated = { ...r };
        // Apply start override
        if (ov.start) {
          updated.start = new Date(ov.start);
          const film = filmById(ov.filmId || r.filmId);
          updated.end = endOfMovie(updated.start, film);
        }
        // Apply auditorium override
        if (ov.audId) {
          updated.audId = ov.audId;
          const a = audById(ov.audId);
          updated.audName = a ? a.name : updated.audName;
        }
        // Apply film override
        if (ov.filmId && ov.filmId !== r.filmId) {
          const film = filmById(ov.filmId);
          if (film) {
            updated.filmId = film.id;
            // Append the film format to the display title when applying a
            // film override.  This mirrors makeRec() so that the film title
            // consistently includes its format across all contexts.
            updated.filmTitle = film.title + (film.format ? ' ' + film.format : '');
            updated.runtime = film.runtime;
            updated.trailer = film.trailer;
            updated.clean = film.clean;
            updated.cycle = cycleMinutes(film);
            updated.end = endOfMovie(updated.start, film);
          }
        }
        // Determine dynamic row grouping: if the override changed auditorium or film relative to base, group by dest auditorium and film
        if ((ov.audId && ov.audId !== r.audId) || (ov.filmId && ov.filmId !== r.filmId)) {
          // Use updated audId and filmId values after applying overrides to build the group id
          const destAud = updated.audId || r.audId;
          const destFilm = updated.filmId || r.filmId;
          updated.rowId = `OV-${destAud}-${destFilm}`;
          updated.source = 'Override';
        }
        return updated;
      });
    // Deduplicate shows by start time, auditorium and film.  In some
    // scenarios (e.g. entering times outside the first/last window or
    // overriding a show to the same time as another show) multiple
    // records can exist with identical start, auditorium and film.  To
    // prevent duplicate entries from appearing in the Gantt or Start‑Time
    // Order views, remove duplicates while preserving the first occurrence.
    mapped.sort((a, b) => a.start - b.start);
    const unique = [];
    const seen = new Set();
    mapped.forEach(rec => {
      // Use milliseconds for start time; fall back to number if not a Date
      const startTime = rec.start instanceof Date ? rec.start.getTime() : new Date(rec.start).getTime();
      const key = `${startTime}_${rec.audId}_${rec.filmId}`;
      if (!seen.has(key)) {
        seen.add(key);
        unique.push(rec);
      }
    });
    return unique;
  }

  // Generate options (HM strings) around a given show start time. Options
  // are 5‑minute increments within ±90 minutes of the start. Times
  // outside of the first/last show window are excluded.
  function optionsAround(start) {
    const opts = [];
    const first = dtFromHM(state.firstShowHM);
    const last = dtFromHM(state.lastShowHM);
    if (last.getHours() < 5) last.setDate(last.getDate() + 1);
    const base = new Date(start);
    for (let m = -90; m <= 90; m += 5) {
      const t = addMins(base, m);
      if (t < first || t > last) continue;
      opts.push(hmFromDate(t));
    }
    // Remove duplicates and sort ascending
    return [...new Set(opts)].sort();
  }

  // Update the start time of a specific show via override. This affects
  // only the given show id and does not alter other shows in the same
  // row. The previous override or base start time is pushed onto
  // undoStack so the change can be reverted. Passing an empty string
  // hides the show instead of changing its start.
  function updateShowStart(showId, hm) {
    load();
    const shows = getAllShows();
    const rec = shows.find(r => r.id === showId);
    if (!rec) return;
    // If hm is empty string, hide the show
    if (hm === '') {
      // Save previous hidden status for undo
      state.undoStack.push({ type: 'hide', showId: showId, prevHidden: !!state.hiddenShows[showId] });
      state.hiddenShows[showId] = true;
      save();
      return;
    }
    // Determine previous start override or base start
    const prevStart = state.overrides[showId]?.start || rec.start;
    state.undoStack.push({ type: 'edit', showId: showId, prevStart: prevStart });
    // Set new override start
    const newStart = dtFromHM(hm);
    if (state.overrides[showId]) {
      state.overrides[showId].start = newStart;
    } else {
      state.overrides[showId] = { start: newStart };
    }
    save();
  }

  // Update the auditorium assignment of a specific show via override.  This
  // function mirrors updateShowStart but for the auditorium (audId). It
  // records the previous auditorium on the undo stack so the change can
  // be reverted. Passing a null or empty value resets the override to
  // the base auditorium. Moving shows between auditoriums is needed for
  // the Gantt view to support vertical drag operations.
  function updateShowAud(showId, audId) {
    load();
    const shows = getAllShows();
    const rec = shows.find(r => r.id === showId);
    if (!rec) return;
    const newAud = (audId !== undefined && audId !== null && audId !== '') ? parseInt(audId, 10) : null;
    // Determine previous override or base auditorium
    const prevAud = state.overrides[showId]?.audId || rec.audId;
    // Special handling for manual shows: update the manual show record
    // directly instead of using overrides. Manual shows have a source
    // property set to 'Manual'. This ensures moving a manual show
    // between auditoriums updates its own audId/audName fields and
    // supports undo. Overrides are better suited for shows derived
    // from prime/extra rows.
    if (rec.source === 'Manual') {
      const msIdx = state.manualShows.findIndex(x => x.id === showId);
      if (msIdx !== -1) {
        // If clearing, revert to previous auditorium
        const targetAud = newAud === null ? prevAud : newAud;
        // If no change, do nothing
        if (targetAud === prevAud) return;
        // Push undo entry
        state.undoStack.push({ type: 'moveAud', showId: showId, prevAudId: prevAud });
        state.manualShows[msIdx].audId = targetAud;
        const audObj = audById(targetAud);
        state.manualShows[msIdx].audName = audObj ? audObj.name : '';
        save();
        return;
      }
    }
    // For non‑manual shows, use overrides
    if (newAud === null) {
      // Only act if an override currently exists for this show
      if (state.overrides[showId] && Object.prototype.hasOwnProperty.call(state.overrides[showId], 'audId')) {
        // Push undo entry
        state.undoStack.push({ type: 'moveAud', showId: showId, prevAudId: prevAud });
        delete state.overrides[showId].audId;
        if (Object.keys(state.overrides[showId]).length === 0) {
          delete state.overrides[showId];
        }
        save();
      }
      return;
    }
    // If the new auditorium matches the current assignment, do nothing
    if (newAud === prevAud) return;
    // Push undo entry
    state.undoStack.push({ type: 'moveAud', showId: showId, prevAudId: prevAud });
    if (!state.overrides[showId]) {
      state.overrides[showId] = { audId: newAud };
    } else {
      state.overrides[showId].audId = newAud;
    }
    save();
  }

  /**
   * Update the film assignment of a specific show via override. This mirrors
   * updateShowAud but for the film. If a manual show is edited, the
   * manual show record is updated directly (filmId, filmTitle, runtime,
   * trailer, clean, cycle, end). For non‑manual shows, a filmId
   * override is written to state.overrides. Passing a null or empty
   * value clears the override and reverts to the base film. Undo
   * operations are recorded so edits can be reverted.
   * @param {string} showId
   * @param {string|null} filmId
   */
  function updateShowFilm(showId, filmId) {
    load();
    const shows = getAllShows();
    const rec = shows.find(r => r.id === showId);
    if (!rec) return;
    const newFilmId = filmId === '' || filmId === null || filmId === undefined ? null : filmId;
    // Determine previous film assignment (override or base)
    const prevFilmId = state.overrides[showId]?.filmId || rec.filmId;
    // If nothing changes, do nothing
    if (newFilmId === prevFilmId) return;
    // Manual shows: update record directly
    if (rec.source === 'Manual') {
      const msIdx = state.manualShows.findIndex(x => x.id === showId);
      if (msIdx !== -1) {
        // Push undo entry
        state.undoStack.push({ type: 'editFilm', showId: showId, prevFilmId: prevFilmId });
        if (newFilmId === null) {
          // Clearing override for manual shows reverts to previous film; nothing to do
          save();
          return;
        }
        // Lookup film and update manual show fields
        const filmObj = filmById(newFilmId);
        if (!filmObj) return;
        const ms = state.manualShows[msIdx];
        ms.filmId = filmObj.id;
        // Include format when updating the film title for a manual show
        ms.filmTitle = filmObj.title + (filmObj.format ? ' ' + filmObj.format : '');
        ms.runtime = filmObj.runtime;
        ms.trailer = filmObj.trailer;
        ms.clean = filmObj.clean;
        ms.cycle = cycleMinutes(filmObj);
        // Recompute end based on existing start and new film runtime/trailer
        ms.end = endOfMovie(ms.start, filmObj);
        save();
        return;
      }
    }
    // Non‑manual shows: write override or clear override
    if (newFilmId === null) {
      // Remove film override if it exists
      if (state.overrides[showId] && Object.prototype.hasOwnProperty.call(state.overrides[showId], 'filmId')) {
        // Record undo
        state.undoStack.push({ type: 'editFilm', showId: showId, prevFilmId: prevFilmId });
        delete state.overrides[showId].filmId;
        if (Object.keys(state.overrides[showId]).length === 0) {
          delete state.overrides[showId];
        }
        save();
      }
      return;
    }
    // Otherwise set override
    // Record undo entry
    state.undoStack.push({ type: 'editFilm', showId: showId, prevFilmId: prevFilmId });
    if (!state.overrides[showId]) {
      state.overrides[showId] = { filmId: newFilmId };
    } else {
      state.overrides[showId].filmId = newFilmId;
    }
    save();
  }

  // Remove (unhide) a show by id. Used when undoing a hide operation.
  function unhideShow(showId, prevHidden) {
    if (!prevHidden) {
      // Remove the hidden flag
      delete state.hiddenShows[showId];
    } else {
      // Restore previous hidden state
      state.hiddenShows[showId] = true;
    }
  }

  // Remove or revert override for a show. Used when undoing an edit.
  function revertOverride(showId, prevStart) {
    if (!state.overrides[showId]) {
      state.overrides[showId] = { start: prevStart };
    } else {
      state.overrides[showId].start = prevStart;
    }
  }

  // Undo the most recent edit or manual show creation. Pops from
  // undoStack and applies the inverse operation.
  function undo() {
    load();
    const entry = state.undoStack.pop();
    if (!entry) return;
    if (entry.type === 'edit') {
      revertOverride(entry.showId, entry.prevStart);
    } else if (entry.type === 'hide') {
      unhideShow(entry.showId, entry.prevHidden);
    } else if (entry.type === 'manual') {
      // Remove a manual show entirely
      const idx = state.manualShows.findIndex(x => x.id === entry.show.id);
      if (idx !== -1) state.manualShows.splice(idx, 1);
    } else if (entry.type === 'moveAud') {
      // Revert an auditorium move.  If the previous auditorium matches the
      // base row assignment (i.e. no override was originally set), then
      // remove the override; otherwise restore the previous override value.
      const sid = entry.showId;
      const prev = entry.prevAudId;
      const currentBase = getAllShows().find(r => r.id === sid)?.audId;
      if (prev === currentBase) {
        // Remove audId override entirely
        if (state.overrides[sid]) {
          delete state.overrides[sid].audId;
          // If override becomes empty object, remove it
          if (Object.keys(state.overrides[sid]).length === 0) {
            delete state.overrides[sid];
          }
        }
      } else {
        if (!state.overrides[sid]) {
          state.overrides[sid] = { audId: prev };
        } else {
          state.overrides[sid].audId = prev;
        }
      }
    }

    // Revert film edit
    else if (entry.type === 'editFilm') {
      const sid = entry.showId;
      const prevFilm = entry.prevFilmId;
      // If rec is a manual show, revert manual show directly
      const msIdx = state.manualShows.findIndex(x => x.id === sid);
      if (msIdx !== -1) {
        const ms = state.manualShows[msIdx];
        const filmObj = filmById(prevFilm);
        if (filmObj) {
          ms.filmId = filmObj.id;
          // When reverting a film edit, restore the film title with its format if present
          ms.filmTitle = filmObj.title + (filmObj.format ? ' ' + filmObj.format : '');
          ms.runtime = filmObj.runtime;
          ms.trailer = filmObj.trailer;
          ms.clean = filmObj.clean;
          ms.cycle = cycleMinutes(filmObj);
          ms.end = endOfMovie(ms.start, filmObj);
        }
      } else {
        // For overrides, restore previous filmId or remove override
        if (!prevFilm || prevFilm === (getAllShows().find(r => r.id === sid)?.filmId)) {
          // Remove film override
          if (state.overrides[sid] && state.overrides[sid].filmId) {
            delete state.overrides[sid].filmId;
            if (Object.keys(state.overrides[sid]).length === 0) {
              delete state.overrides[sid];
            }
          }
        } else {
          if (!state.overrides[sid]) {
            state.overrides[sid] = { filmId: prevFilm };
          } else {
            state.overrides[sid].filmId = prevFilm;
          }
        }
      }
    }
    save();
  }

  // Create a new manual show at the selected time in the specified row.
  // The filmId and audId are taken from the row. Records an undo entry.
  function addManualShow(rowId, hm) {
    load();
    const row = state.primeRows.concat(state.extraRows).find(r => r.rowId === rowId);
    if (!row) return;
    const film = filmById(row.filmId);
    const aud = audById(row.audId);
    if (!film || !aud) return;
    const start = dtFromHM(hm);
    const end = endOfMovie(start, film);
    const id = `M-${Date.now()}-${Math.floor(Math.random()*1000)}`;
    const rec = {
      id: id,
      rowId: rowId,
      audId: aud.id,
      audName: aud.name,
      filmId: film.id,
      // Include the film format in the title for manual shows
      filmTitle: film.title + (film.format ? ' ' + film.format : ''),
      start: start,
      end: end,
      runtime: film.runtime,
      trailer: film.trailer,
      clean: film.clean,
      cycle: cycleMinutes(film),
      source: 'Manual'
    };
    state.manualShows.push(rec);
    state.undoStack.push({ type: 'manual', show: rec });
    save();
  }

  // Add a new extra row (manual row). Returns the new row object. Row ids
  // are unique strings starting with "EX-" followed by timestamp.
  function addExtraRow() {
    load();
    const id = `EX-${Date.now()}-${Math.floor(Math.random()*1000)}`;
    const slot = String((state.primeRows.length + state.extraRows.length) + 1);
    const row = { rowId: id, bookingId: null, slot: slot, audId: null, filmId: null, primeHM: '' };
    state.extraRows.push(row);
    save();
    return row;
  }

  // Set a field on a row (prime or extra). field is 'audId', 'filmId' or
  // 'primeHM'. For primeHM this does not cascade to show overrides; it
  // simply updates the cycle start time for that row.
  function setRowField(rowId, field, value) {
    load();
    let row = state.primeRows.find(r => r.rowId === rowId);
    if (!row) row = state.extraRows.find(r => r.rowId === rowId);
    if (!row) return;
    row[field] = value;
    // When editing row-level auditorium or film, propagate changes to manual
    // shows associated with this row. Manual shows are single show
    // instances created directly on the schedule grid. They copy the
    // row's auditorium and film at creation time, so they can fall out of
    // sync when the row is later edited. To mirror the behaviour of the
    // original React app, update manual show records when the row's
    // auditorium or film changes. This keeps the Start‑time Order panel
    // consistent with the schedule grid.
    if (field === 'audId') {
      const newAudId = value ? parseInt(value, 10) : null;
      (state.manualShows || []).forEach(ms => {
        if (ms.rowId === rowId) {
          ms.audId = newAudId;
          const aud = audById(newAudId);
          ms.audName = aud ? aud.name : '';
        }
      });
    } else if (field === 'filmId') {
      const newFilmId = value || null;
      (state.manualShows || []).forEach(ms => {
        if (ms.rowId === rowId) {
          const film = filmById(newFilmId);
          if (film) {
            ms.filmId = film.id;
            // When updating the film of a manual show, update the title to include the
            // format so that it appears consistently across the UI
            ms.filmTitle = film.title + (film.format ? ' ' + film.format : '');
            ms.runtime = film.runtime;
            ms.trailer = film.trailer;
            ms.clean = film.clean;
            ms.cycle = cycleMinutes(film);
            // update end time based on new film runtime and trailer; clean
            const totalMins = (film.runtime || 0) + (film.trailer || 0);
            ms.end = addMins(ms.start, totalMins);
          } else {
            // if no film, clear film-related fields
            ms.filmId = null;
            ms.filmTitle = '';
            ms.runtime = 0;
            ms.trailer = 0;
            ms.clean = 0;
            ms.cycle = 0;
            ms.end = ms.start;
          }
        }
      });
    }
    save();
  }

  // Hide or reveal end times on the grid
  function toggleEndTimes() {
    load();
    state.showEndTimes = !state.showEndTimes;
    save();
  }

  // Clear all showtimes across the application. This resets prime times,
  // removes all overrides and manual shows, and clears hidden shows. It
  // preserves the structure of primeRows and extraRows so that users can
  // assign new times from scratch. This is useful for starting over.
  function clearAllTimes() {
    load();
    // Reset prime times on prime and extra rows
    if (Array.isArray(state.primeRows)) {
      state.primeRows.forEach(r => { r.primeHM = ''; });
    }
    if (Array.isArray(state.extraRows)) {
      state.extraRows.forEach(r => { r.primeHM = ''; });
    }
    // Remove all overrides and manual shows and hidden shows
    state.overrides = {};
    state.manualShows = [];
    state.hiddenShows = {};
    // Also reset undo stack
    state.undoStack = [];
    save();
  }

  /**
   * Ensure that multi‑date support is initialised. When called, this will
   * initialise the scheduleByDate and currentDate fields on the state if
   * they are missing. It will also migrate any existing top‑level
   * schedule fields (primeRows, extraRows, manualShows, overrides,
   * hiddenShows and undoStack) into the schedule entry for the current
   * date. Once initialised, it loads the schedule for the current date
   * into the top‑level fields so that the rest of the app continues
   * operating as before. If no currentDate is present, today's date
   * (local time) is used. Finally it persists the changes to storage.
   */
  function initDateSupport() {
    load();
    // Create the scheduleByDate container if missing
    if (!state.scheduleByDate || typeof state.scheduleByDate !== 'object') {
      state.scheduleByDate = {};
    }
    // Determine the current date; if not set, default to today's date
    if (!state.currentDate) {
      const today = new Date();
      const dateStr = today.toISOString().split('T')[0];
      state.currentDate = dateStr;
    }
    // If there is no schedule stored for the current date, migrate the
    // existing top‑level schedule fields into a new entry. This ensures
    // users upgrading from a single‑date state keep their existing
    // schedule as the schedule for the current date.
    if (!state.scheduleByDate[state.currentDate]) {
      state.scheduleByDate[state.currentDate] = {
        primeRows: Array.isArray(state.primeRows) ? state.primeRows : [],
        extraRows: Array.isArray(state.extraRows) ? state.extraRows : [],
        manualShows: Array.isArray(state.manualShows) ? state.manualShows : [],
        overrides: state.overrides || {},
        hiddenShows: state.hiddenShows || {},
        undoStack: Array.isArray(state.undoStack) ? state.undoStack : [],
      };
    }
    // Load the schedule for the current date into top‑level fields
    loadSchedule(state.currentDate);
    // Persist the state so that currentDate and scheduleByDate are saved
    save();
  }

  /**
   * Persist the current schedule into the scheduleByDate map. The schedule
   * fields (primeRows, extraRows, manualShows, overrides, hiddenShows,
   * undoStack) are saved under the key of state.currentDate. Manual
   * shows are stored with their start/end fields preserved as Date
   * objects; these will be serialised to ISO strings when persisted via
   * save(). A retention policy keeps only the most recent 7 dates to
   * avoid unbounded growth.
   */
  function saveCurrentSchedule() {
    load();
    if (!state.currentDate) return;
    if (!state.scheduleByDate || typeof state.scheduleByDate !== 'object') {
      state.scheduleByDate = {};
    }
    state.scheduleByDate[state.currentDate] = {
      primeRows: Array.isArray(state.primeRows) ? state.primeRows : [],
      extraRows: Array.isArray(state.extraRows) ? state.extraRows : [],
      manualShows: Array.isArray(state.manualShows) ? state.manualShows : [],
      overrides: state.overrides || {},
      hiddenShows: state.hiddenShows || {},
      undoStack: Array.isArray(state.undoStack) ? state.undoStack : [],
    };
    pruneOldSchedules();
  }

  /**
   * Load the schedule for a given date into the top‑level schedule fields.
   * If the specified date does not yet have a schedule entry, a new
   * blank schedule is created. This function does not persist the
   * change; callers should invoke save() after calling loadSchedule() if
   * they want the change to be stored. Dates must be provided as
   * strings in ISO format (YYYY-MM-DD).
   * @param {string} date 
   */
  function loadSchedule(date) {
    load();
    if (!state.scheduleByDate || typeof state.scheduleByDate !== 'object') {
      state.scheduleByDate = {};
    }
    if (!date) {
      // If no date provided, fall back to currentDate or today's date
      if (!state.currentDate) {
        const today = new Date();
        date = today.toISOString().split('T')[0];
      } else {
        date = state.currentDate;
      }
    }
    // Ensure there is a schedule entry for this date
    if (!state.scheduleByDate[date]) {
      state.scheduleByDate[date] = {
        primeRows: [],
        extraRows: [],
        manualShows: [],
        overrides: {},
        hiddenShows: {},
        undoStack: [],
      };
    }
    // Copy schedule fields into top‑level state
    const sched = state.scheduleByDate[date];
    state.primeRows = Array.isArray(sched.primeRows) ? sched.primeRows : [];
    state.extraRows = Array.isArray(sched.extraRows) ? sched.extraRows : [];
    // Deep copy manual shows, converting start/end strings to Date objects
    state.manualShows = Array.isArray(sched.manualShows) ? sched.manualShows.map(ms => {
      const copy = { ...ms };
      if (typeof copy.start === 'string') {
        const d = new Date(copy.start);
        if (!isNaN(d)) copy.start = d;
      }
      if (typeof copy.end === 'string') {
        const d2 = new Date(copy.end);
        if (!isNaN(d2)) copy.end = d2;
      }
      return copy;
    }) : [];
    state.overrides = sched.overrides ? { ...sched.overrides } : {};
    state.hiddenShows = sched.hiddenShows ? { ...sched.hiddenShows } : {};
    state.undoStack = Array.isArray(sched.undoStack) ? sched.undoStack : [];
    state.currentDate = date;
  }

  /**
   * Remove old schedules to maintain only the most recent N dates. We
   * extend the retention window from 7 to 14 entries so that copying
   * schedules across multiple days does not inadvertently drop the
   * source day or newly copied dates. The keys are sorted
   * lexicographically (which corresponds to chronological order for
   * ISO‑8601 strings) and the oldest keys beyond the retention limit
   * are deleted. If the total number of keys is less than or equal
   * to the retention limit, nothing is deleted.
   */
  function pruneOldSchedules() {
    if (!state.scheduleByDate || typeof state.scheduleByDate !== 'object') return;
    const keys = Object.keys(state.scheduleByDate);
    // Retain up to this many schedules (roughly two weeks). Adjust if
    // you need a larger or smaller window.
    const retention = 14;
    if (keys.length <= retention) return;
    keys.sort();
    const toDelete = keys.slice(0, keys.length - retention);
    toDelete.forEach(k => {
      delete state.scheduleByDate[k];
    });
  }

  /**
   * Change the current schedule date. This will first save the current
   * schedule under state.currentDate, then load the schedule for the
   * specified date and update the state accordingly. Finally it
   * persists the changes and dispatches a custom event to allow
   * listeners to react to the date change. If the provided date is
   * empty or null, this function returns without action.
   * @param {string} date  The new date in YYYY-MM-DD format
   */
  function setDate(date) {
    if (!date) return;
    load();
    // Save the current schedule before switching
    saveCurrentSchedule();
    // Load the new schedule
    loadSchedule(date);
    // Persist changes
    save();
    // Notify listeners that the date has changed
    try {
      const evt = new Event('showtimeDateChanged');
      window.dispatchEvent(evt);
    } catch (err) {}
  }

  /**
   * Copy a schedule from one date to one or more target dates.  This will
   * first ensure that the current schedule is saved, then duplicate the
   * schedule data (primeRows, extraRows, manualShows, overrides,
   * hiddenShows) for each target date provided.  If a target date
   * already exists, it will be overwritten.  The undoStack is
   * intentionally cleared on the copied schedules because undo history
   * should not carry over between days.  After copying, changes are
   * persisted.  If fromDate is falsy or targetDates is not an array,
   * the function returns without doing anything.
   *
   * @param {string} fromDate
   *   The date to copy from (YYYY-MM-DD).  If null, the current date
   *   (state.currentDate) will be used.
   * @param {string[]} targetDates
   *   An array of target dates (YYYY-MM-DD) to copy the schedule to.
   */
  function copySchedule(fromDate, targetDates) {
    load();
    if (!Array.isArray(targetDates) || targetDates.length === 0) return;
    // Determine the source date.  If fromDate is not provided, use the current date.
    const sourceDate = fromDate || state.currentDate;
    if (!sourceDate) return;
    // Ensure the current schedule is saved before copying
    saveCurrentSchedule();
    const srcSched = state.scheduleByDate[sourceDate];
    if (!srcSched) return;
    // Deep copy helper for rows (primeRows/extraRows)
    const deepCopyRows = (rows) => rows.map(r => JSON.parse(JSON.stringify(r)));
    // Deep copy manual shows: copy object and ensure Date fields are actual Date objects
    const deepCopyManualShows = (ms) => ms.map(show => {
      const c = { ...show };
      c.start = show.start instanceof Date ? new Date(show.start) : new Date(show.start);
      c.end = show.end instanceof Date ? new Date(show.end) : new Date(show.end);
      return c;
    });
    targetDates.forEach(targetDate => {
      if (!targetDate) return;
      // Ensure scheduleByDate exists
      if (!state.scheduleByDate || typeof state.scheduleByDate !== 'object') {
        state.scheduleByDate = {};
      }
      // Assign deep copies to target date
      state.scheduleByDate[targetDate] = {
        primeRows: Array.isArray(srcSched.primeRows) ? deepCopyRows(srcSched.primeRows) : [],
        extraRows: Array.isArray(srcSched.extraRows) ? deepCopyRows(srcSched.extraRows) : [],
        manualShows: Array.isArray(srcSched.manualShows) ? deepCopyManualShows(srcSched.manualShows) : [],
        overrides: srcSched.overrides ? { ...srcSched.overrides } : {},
        hiddenShows: srcSched.hiddenShows ? { ...srcSched.hiddenShows } : {},
        // Reset undo stack on copied schedules
        undoStack: [],
      };
    });
    // Persist changes
    save();
  }

  /**
   * Clear the schedule for a specific date. If no date is provided, the
   * current date is cleared. This resets primeRows, extraRows,
   * manualShows, overrides, hiddenShows and undoStack for that date.
   * If the cleared date is the currently selected date, the top‑level
   * collections are also emptied so the UI reflects the changes
   * immediately. After clearing, the state is saved. Use this to
   * quickly remove all shows from a single day without deleting
   * auditoriums or bookings.
   * @param {string|null} date
   */
  function clearSchedule(date) {
    load();
    const iso = date || state.currentDate;
    if (!iso) return;
    if (!state.scheduleByDate || typeof state.scheduleByDate !== 'object') {
      state.scheduleByDate = {};
    }
    state.scheduleByDate[iso] = {
      primeRows: [],
      extraRows: [],
      manualShows: [],
      overrides: {},
      hiddenShows: {},
      undoStack: [],
    };
    // If clearing the current date, also reset top-level schedule arrays
    if (iso === state.currentDate) {
      state.primeRows = [];
      state.extraRows = [];
      state.manualShows = [];
      state.overrides = {};
      state.hiddenShows = {};
      state.undoStack = [];
    }
    save();
  }

  /**
   * Clear schedules for all dates. This iterates over scheduleByDate
   * entries and replaces each schedule with an empty one. It also
   * clears the top‑level schedule fields to reflect the currently
   * selected date (if any). After clearing, the state is saved.
   */
  function clearAllSchedules() {
    load();
    if (!state.scheduleByDate || typeof state.scheduleByDate !== 'object') {
      state.scheduleByDate = {};
    }
    Object.keys(state.scheduleByDate).forEach((d) => {
      state.scheduleByDate[d] = {
        primeRows: [],
        extraRows: [],
        manualShows: [],
        overrides: {},
        hiddenShows: {},
        undoStack: [],
      };
    });
    // Clear top‑level schedule arrays
    state.primeRows = [];
    state.extraRows = [];
    state.manualShows = [];
    state.overrides = {};
    state.hiddenShows = {};
    state.undoStack = [];
    save();
  }

  /**
   * Clear all bookings and all schedule data across every date. This
   * helper removes every booking entry and resets all schedule
   * collections (primeRows, extraRows, manualShows, overrides,
   * hiddenShows and undoStack) both at the top level and for each
   * date in scheduleByDate. It preserves auditorium and film
   * definitions. After clearing, the state is saved. Use this when
   * you need to start over with a completely blank schedule and
   * bookings list.
   */
  function clearBookingsAndTimes() {
    load();
    // Clear bookings list
    state.bookings = [];
    // Clear top‑level schedule arrays
    state.primeRows = [];
    state.extraRows = [];
    state.manualShows = [];
    state.overrides = {};
    state.hiddenShows = {};
    state.undoStack = [];
    // Clear schedule entries for every date if multi‑date support is enabled
    if (state.scheduleByDate && typeof state.scheduleByDate === 'object') {
      Object.keys(state.scheduleByDate).forEach((d) => {
        state.scheduleByDate[d] = {
          primeRows: [],
          extraRows: [],
          manualShows: [],
          overrides: {},
          hiddenShows: {},
          undoStack: [],
        };
      });
    }
    save();
  }

  /**
   * Return a sorted array of all dates present in scheduleByDate. Dates are
   * returned in ascending order (oldest first).
   */
  function listDates() {
    load();
    if (!state.scheduleByDate || typeof state.scheduleByDate !== 'object') return [];
    return Object.keys(state.scheduleByDate).sort();
  }

  /**
   * Return the currently selected date. If null, returns null.
   */
  function getCurrentDate() {
    load();
    return state.currentDate || null;
  }

  // Expose the state and helper methods on window.ShowtimeState
  window.ShowtimeState = {
    get state() { return load(); },
    load,
    save,
    filmById,
    audById,
    buildRowShowtimes,
    getAllShows,
    optionsAround,
    updateShowStart,
    updateShowAud,
    updateShowFilm,
    addManualShow,
    addExtraRow,
    setRowField,
    toggleEndTimes,
    clearAllTimes,
    // Clear the schedule for the current date or a specific date
    clearSchedule,
    // Clear schedules for all dates
    clearAllSchedules,
    // Clear all bookings and times across every date
    clearBookingsAndTimes,
    undo,
    fmtHM,
    to12,
    hmFromDate,
    dtFromHM,
    cycleMinutes,
    fmtDur,
    // Date support API
    initDateSupport,
    saveCurrentSchedule,
    loadSchedule,
    setDate,
    listDates,
    getCurrentDate,
    copySchedule,
    // Expose date formatting helpers so pages can convert between
    // ISO strings and MM/DD/YYYY. These do not modify the state.
    isoToMMDD,
    mmddToIso,
  };

  /**
   * Prompt the user for one or more target dates and copy the current schedule
   * to those dates.  This helper uses a simple comma‑separated list input
   * rather than a complex multi‑date picker to minimise UI clutter.  After
   * copying, a confirmation alert is displayed.  If no input is provided,
   * the function returns without making any changes.
   */
  window.copyScheduleUI = function () {
    const currentDate = ShowtimeState.getCurrentDate();
    if (!currentDate) {
      alert('No date selected.');
      return;
    }
    const input = prompt(
      'Enter one or more target dates (YYYY‑MM‑DD) separated by commas:',
      ''
    );
    if (!input) return;
    const dates = input
      .split(',')
      .map((d) => d.trim())
      .filter((d) => d);
    if (dates.length === 0) return;
    ShowtimeState.copySchedule(currentDate, dates);
    alert(
      `Schedule for ${currentDate} copied to: ${dates.join(', ')}. You can switch dates to view changes.`
    );
  };

  /**
   * Film highlight selector and highlighting logic
   *
   * On every page that includes a <nav> element this code will inject a
   * dropdown to select a film by title. Selecting a film will persist
   * the selection in state.highlightFilmId, fire a custom
   * `filmHighlightChange` event and apply a pink highlight to every
   * element marked with a `data-filmid` attribute matching the
   * selected film.  The highlight uses a semi‑dark pinkish colour
   * defined in theme.css via the .film-highlight class.
   */
  function onReady(fn) {
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', fn);
    } else {
      fn();
    }
  }

  onReady(() => {
    try {
      const nav = document.querySelector('nav');
      if (!nav) return;
      const state = ShowtimeState.state;
      // Create select for highlighting films
      const select = document.createElement('select');
      select.id = 'filmHighlightSelect';
      // Style the film highlight dropdown to stand out against the dark nav background.
      // Use a white background and dark text so the options are legible.
      select.className = 'ml-2 px-2 py-1 border border-gray-300 rounded text-sm bg-white text-gray-800';
      // Placeholder option
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'Highlight Film';
      select.appendChild(placeholder);
      // Function to refresh option list from current films
      function refreshOptions() {
        // Remove all options except the placeholder
        while (select.options.length > 1) {
          select.remove(1);
        }
        // Compute the set of filmIds that are currently in use across
        // bookings, prime rows, extra rows and manual shows.  Only
        // films that are actually scheduled or booked should appear in
        // the highlight dropdown.  This prevents long lists of unused
        // films from cluttering the UI.
        // Only collect film IDs that are currently referenced on the Bookings
        // page.  Exclude prime rows, extra rows and manual shows so that
        // old films cleared from the bookings list do not linger in the
        // highlight dropdown.
        const usedIds = new Set();
        try {
          const st = ShowtimeState.state || state;
          (st.bookings || []).forEach(b => {
            if (b && b.filmId) usedIds.add(String(b.filmId));
          });
        } catch (_) {}
        // Map titles to a single film record to avoid duplicates when
        // multiple film objects share the same title (e.g. different
        // formats).  Keys are lowercase trimmed titles.
        const filmMap = {};
        usedIds.forEach(fid => {
          let f = null;
          try {
            if (ShowtimeState && typeof ShowtimeState.filmById === 'function') {
              f = ShowtimeState.filmById(fid);
            }
          } catch (_) {}
          if (!f) {
            // fallback to scanning state.films
            const st = ShowtimeState.state || state;
            if (st && st.films) {
              f = st.films.find(item => String(item.id) === fid);
            }
          }
          if (f && f.title) {
            const key = (f.title || '').toLowerCase().trim();
            if (!filmMap[key]) {
              filmMap[key] = f;
            }
          }
        });
        const films = Object.values(filmMap);
        films.sort((a, b) => a.title.localeCompare(b.title));
        films.forEach(f => {
          const opt = document.createElement('option');
          opt.value = String(f.id);
          opt.textContent = f.title;
          select.appendChild(opt);
        });
        // Restore previous selection if still present; otherwise clear
        if (state.highlightFilmId) {
          const exists = films.some(f => String(f.id) === state.highlightFilmId);
          if (exists) {
            select.value = state.highlightFilmId;
          } else {
            // Clear highlight if the previously selected film is no longer in use
            state.highlightFilmId = '';
            ShowtimeState.save();
            select.value = '';
          }
        }
      }
      refreshOptions();
      // After initially populating the dropdown with all films, override
      // the refresh logic to filter the list to only those films that
      // are currently used in the schedule.  This helper computes a
      // set of used film IDs from bookings, prime rows, extra rows and
      // manual shows, then deduplicates by film title.  The existing
      // highlight selection is cleared if the film is no longer used.
      function refreshUsedFilmOptions() {
        // Remove all options except the placeholder
        while (select.options.length > 1) {
          select.remove(1);
        }
        // Only collect film IDs referenced in bookings. Exclude primeRows,
        // extraRows and manualShows so that films cleared from bookings do
        // not linger in the dropdown.  If state is undefined, usedIds
        // remains empty.
        const usedIds = new Set();
        try {
          const st = ShowtimeState.state;
          (st.bookings || []).forEach(b => {
            if (b && b.filmId != null && b.filmId !== '') usedIds.add(String(b.filmId));
          });
        } catch (e) {
          // ignore errors when computing used ids
        }
        const filmMap = new Map();
        (state.films || []).forEach(f => {
          if (!f || !f.title) return;
          const idStr = String(f.id);
          if (!usedIds.has(idStr)) return;
          if (!filmMap.has(f.title)) filmMap.set(f.title, f);
        });
        const films = Array.from(filmMap.values()).sort((a, b) => a.title.localeCompare(b.title));
        films.forEach(f => {
          const opt = document.createElement('option');
          opt.value = String(f.id);
          opt.textContent = f.title;
          select.appendChild(opt);
        });
        // If the current highlight film is no longer used, clear it
        if (state.highlightFilmId && !usedIds.has(String(state.highlightFilmId))) {
          state.highlightFilmId = '';
          ShowtimeState.save();
        }
        // Restore previous selection if still valid
        if (state.highlightFilmId) {
          select.value = state.highlightFilmId;
        } else {
          select.value = '';
        }
      }
      // Override the global refresh function with the used-films version
      window.refreshFilmHighlightOptions = refreshUsedFilmOptions;
      // Immediately repopulate the dropdown using only used films
      refreshUsedFilmOptions();
      // Persist highlight selection and apply highlight on change
      select.addEventListener('change', () => {
        state.highlightFilmId = select.value || '';
        ShowtimeState.save();
        // Dispatch an event to notify page scripts of the change
        try {
          const evt = new CustomEvent('filmHighlightChange', { detail: { filmId: state.highlightFilmId } });
          window.dispatchEvent(evt);
        } catch {}
        // Apply highlight on the current page immediately
        if (typeof window.applyFilmHighlight === 'function') {
          window.applyFilmHighlight();
        }
      });
      // Insert the select into a designated placeholder if present.  Pages
      // can include a <span id="filmHighlightPlaceholder"></span> in
      // their navigation markup to control where the highlight dropdown
      // appears.  If no placeholder exists, fall back to inserting the
      // select immediately after the last navigation link as before.
      try {
        const placeholder = document.getElementById('filmHighlightPlaceholder');
        if (placeholder) {
          // Clear any existing children and append the select.  Keeping the
          // placeholder element allows future refreshes to target the same
          // container.
          while (placeholder.firstChild) {
            placeholder.removeChild(placeholder.firstChild);
          }
          placeholder.appendChild(select);
        } else {
          // If no placeholder exists, do not insert the highlight dropdown on
          // this page.  The absence of a placeholder indicates the page
          // does not wish to display the film highlight control (e.g. the
          // Prime schedule).  Simply skip insertion here.  Pages that
          // require the dropdown should include a #filmHighlightPlaceholder
          // element in their navigation markup.
          return;
        }
      } catch (_) {
        nav.appendChild(select);
      }
      // Expose refresh function globally so pages can repopulate the
      // options when films change (e.g. via bulk bookings).  The
      // refreshUsedFilmOptions function ensures only films referenced on
      // the Bookings tab are listed.  This assignment intentionally
      // overrides any previous assignments on window.
      window.refreshFilmHighlightOptions = refreshUsedFilmOptions;
      // Ensure highlightFilmId exists in state
      if (state.highlightFilmId === undefined) {
        state.highlightFilmId = '';
        ShowtimeState.save();
      }
      // Apply any existing highlight once after the first render cycle.
      // We wait briefly to allow page-specific render functions to run.
      setTimeout(() => {
        if (typeof window.applyFilmHighlight === 'function') {
          window.applyFilmHighlight();
        }
      }, 100);

      // When the underlying localStorage state changes (e.g. when
      // bookings are cleared or films are added on another page),
      // refresh the options list.  The storage event normally only
      // fires across different documents, but we trigger it manually
      // after saving state to keep pages in sync.
      window.addEventListener('storage', () => {
        try {
          if (typeof window.refreshFilmHighlightOptions === 'function') {
            window.refreshFilmHighlightOptions();
          }
        } catch (_) {}
      });
    } catch (err) {
      // Suppress errors to avoid breaking page load if nav is missing
    }
  });

  // Global helper to apply film highlight on the current page.  This
  // function iterates over all elements with a data-filmid attribute and
  // toggles the 'film-highlight' class based on whether the value
  // matches the currently selected highlightFilmId stored in state. It
  // also highlights Gantt bars (divs with data-filmid) if present.
  window.applyFilmHighlight = function() {
    try {
      const state = ShowtimeState.state;
      const highlightId = state.highlightFilmId || '';
      // If no film is selected, remove all highlights
      if (!highlightId) {
        document.querySelectorAll('[data-filmid]').forEach(el => {
          el.classList.remove('film-highlight');
        });
        return;
      }
      // Look up the selected film's title.  If not found, clear highlights.
      let highlightTitle = '';
      try {
        const film = ShowtimeState.filmById(highlightId);
        if (film && film.title) {
          highlightTitle = (film.title || '').toLowerCase().trim();
        }
      } catch (_) {}
      if (!highlightTitle) {
        document.querySelectorAll('[data-filmid]').forEach(el => {
          el.classList.remove('film-highlight');
        });
        return;
      }
      // For each element with data-filmid, compare its film's title to the highlight title
      const els = document.querySelectorAll('[data-filmid]');
      els.forEach(el => {
        const fid = el.dataset.filmid;
        if (!fid) {
          el.classList.remove('film-highlight');
          return;
        }
        let f2;
        try {
          f2 = ShowtimeState.filmById(fid);
        } catch (_) {}
        const t = f2 && f2.title ? f2.title.toLowerCase().trim() : '';
        if (t && t === highlightTitle) {
          el.classList.add('film-highlight');
        } else {
          el.classList.remove('film-highlight');
        }
      });
    } catch (err) {}
  };

  /**
   * Refresh the film highlight dropdown based on currently used films.
   *
   * This function inspects bookings, prime rows, extra rows, manual shows
   * and multi‑date schedule entries to determine which films are
   * actively referenced in the schedule.  It rebuilds the list of
   * options in the #filmHighlightSelect element, removes duplicates
   * and unused films, and clears the selection if the highlighted
   * film is no longer used.  The placeholder option is preserved.
   */
  window.refreshFilmHighlightOptions = function() {
    try {
      const state = ShowtimeState.state;
      const select = document.getElementById('filmHighlightSelect');
      if (!select) return;
      // Remove all options except the first (placeholder)
      while (select.options.length > 1) {
        select.remove(1);
      }
      // Determine which film IDs are currently referenced on the Bookings page.
      // We only consider films attached to bookings (not primeRows, extraRows or manual shows)
      // so the highlight dropdown contains unique titles from the bookings tab.
      const usedIds = new Set();
      const st = state || {};
      const bookings = Array.isArray(st.bookings) ? st.bookings : [];
      bookings.forEach(item => {
        if (item && item.filmId) usedIds.add(String(item.filmId));
      });
      // Look up film objects for each used ID
      const allFilms = Array.isArray(st.films) ? st.films : [];
      const usedFilms = [];
      usedIds.forEach(fid => {
        const film = allFilms.find(f => f && String(f.id) === fid);
        if (film && film.title) usedFilms.push(film);
      });
      // Sort alphabetically by title and build option elements
      usedFilms.sort((a, b) => a.title.localeCompare(b.title));
      usedFilms.forEach(f => {
        const opt = document.createElement('option');
        opt.value = String(f.id);
        opt.textContent = f.title;
        select.appendChild(opt);
      });
      // If the current highlight film is no longer used, clear the selection
      if (state.highlightFilmId && !usedIds.has(state.highlightFilmId)) {
        state.highlightFilmId = '';
        ShowtimeState.save();
      }
      select.value = state.highlightFilmId || '';
    } catch (e) {
      // ignore errors to avoid breaking the page
    }
  };

  // After the document has loaded, refresh the film highlight list using
  // the latest schedule data.  Use a slight delay to allow page‑specific
  // render functions to populate tables before computing the used films.
  onReady(() => {
    setTimeout(() => {
      if (typeof window.refreshFilmHighlightOptions === 'function') {
        window.refreshFilmHighlightOptions();
      }
    }, 200);
  });
  // Whenever the schedule state is updated, refresh the film highlight list
  // so that the dropdown reflects any newly added or removed bookings.
  window.addEventListener('showtimeStateUpdated', () => {
    try {
      if (typeof window.refreshFilmHighlightOptions === 'function') {
        window.refreshFilmHighlightOptions();
      }
    } catch (_) {}
  });

  /**
   * Generate an array of date strings (YYYY-MM-DD) representing the previous three
   * days and the next ten days relative to the provided date.  The given date
   * is excluded from the returned array.  This helper is used by the copy
   * schedule panel to provide common target dates for copying a schedule.
   * @param {string} dateStr A date string in YYYY-MM-DD format.
   * @returns {string[]} An array of nearby dates in ascending order.
   */
  function getNearbyDates(dateStr) {
    try {
      const base = new Date(dateStr);
      if (isNaN(base)) return [];
      const dates = [];
      for (let i = -3; i <= 10; i++) {
        if (i === 0) continue;
        const d = new Date(base);
        d.setDate(base.getDate() + i);
        const iso = d.toISOString().slice(0, 10);
        dates.push(iso);
      }
      return dates;
    } catch (e) {
      return [];
    }
  }

  /**
   * Show a floating panel to select multiple target dates for copying the current
   * schedule.  The panel is positioned near the triggering button.  When the
   * user clicks "Apply", the schedule from the selected date input is copied
   * to the checked dates.  A "Cancel" button closes the panel without
   * performing any action.
   *
   * @param {HTMLElement} btn The button element that triggers the panel.
   * @param {string} dateInputId The ID of the date input element whose value
   * will be used as the source date.  If the value is empty, an alert is
   * shown and the panel is not displayed.
   */
  window.openCopyPanel = function (btn, dateInputId) {
    // Remove any existing panel
    const existing = document.getElementById('copySchedulePanel');
    if (existing) {
      existing.remove();
      return;
    }
    const dateInput = document.getElementById(dateInputId);
    if (!dateInput || !dateInput.value) {
      alert('Please select a date first.');
      return;
    }
    // The date input displays values in MM/DD/YYYY format. Convert to ISO
    // before generating nearby dates and copying schedules. If the conversion
    // fails, fall back to the raw value so that getNearbyDates at least
    // attempts to interpret it. We keep the original mm/dd string for
    // display in the alert below.
    const mmddCurrent = dateInput.value;
    const isoCurrent = mmddToIso(mmddCurrent) || mmddCurrent;
    const targets = getNearbyDates(isoCurrent);
    if (targets.length === 0) {
      alert('Unable to generate target dates.');
      return;
    }
    // Create panel
    const panel = document.createElement('div');
    panel.id = 'copySchedulePanel';
    panel.className = 'absolute z-50 bg-white border border-gray-300 rounded-lg shadow p-3 text-sm';
    // Position panel below the button
    const rect = btn.getBoundingClientRect();
    // Use page offsets to handle scrolling
    panel.style.top = `${rect.bottom + window.scrollY + 4}px`;
    panel.style.left = `${rect.left + window.scrollX}px`;
    // Build list of checkboxes
    targets.forEach((iso) => {
      const row = document.createElement('label');
      row.className = 'flex items-center space-x-2 mb-1';
      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.value = iso;
      // Highlight dates that already contain schedule data by making
      // the label bold and coloured. Use closure-scoped state for lookup.
      let hasData = false;
      try {
        if (state && state.scheduleByDate && state.scheduleByDate[iso]) {
          const sched = state.scheduleByDate[iso];
          if (
            (sched.primeRows && sched.primeRows.length) ||
            (sched.extraRows && sched.extraRows.length) ||
            (sched.manualShows && sched.manualShows.length)
          ) {
            hasData = true;
          }
        }
      } catch (e) {
        // ignore lookup errors
      }
      row.appendChild(cb);
      const span = document.createElement('span');
      span.textContent = isoToMMDD(iso);
      if (hasData) {
        span.classList.add('font-bold', 'text-blue-700');
      }
      row.appendChild(span);
      panel.appendChild(row);
    });
    // Action buttons
    const btnRow = document.createElement('div');
    btnRow.className = 'mt-2 flex justify-end space-x-2';
    const applyBtn = document.createElement('button');
    applyBtn.textContent = 'Apply';
    applyBtn.className = 'px-3 py-1 bg-blue-700 text-white rounded hover:bg-blue-800';
    applyBtn.onclick = function () {
      const selected = Array.from(panel.querySelectorAll('input[type=checkbox]:checked')).map((c) => c.value);
      if (selected.length === 0) {
        alert('No target dates selected.');
        return;
      }
      // Copy from isoCurrent (the canonical ISO string) but show the mm/dd
      // version in the confirmation alert. The selected array already
      // contains ISO strings.
      ShowtimeState.copySchedule(isoCurrent, selected);
      alert(`Schedule for ${mmddCurrent} copied to: ${selected.map(isoToMMDD).join(', ')}.`);
      panel.remove();
    };
    const cancelBtn = document.createElement('button');
    cancelBtn.textContent = 'Cancel';
    cancelBtn.className = 'px-3 py-1 bg-gray-500 text-white rounded hover:bg-gray-600';
    cancelBtn.onclick = function () {
      panel.remove();
    };
    btnRow.appendChild(applyBtn);
    btnRow.appendChild(cancelBtn);
    panel.appendChild(btnRow);
    document.body.appendChild(panel);
  };

  // Inject global navigation styles to give the nav links a pill shape. In the
  // original app the navigation buttons were rounded and padded. We apply
  // similar styling here by targeting anchor tags with the nav-link class
  // inside a nav element. This runs once on initial load.
  (function injectNavPillStyles(){
    if (typeof document === 'undefined') return;
    if (document.getElementById('nav-pill-style')) return;
    try {
      const style = document.createElement('style');
      style.id = 'nav-pill-style';
      style.textContent = `
        nav a.nav-link {
          border-radius: 9999px;
          padding: 0.375rem 0.75rem;
          margin-right: 0.25rem;
          transition: background-color 0.15s;
        }
        nav a.nav-link:hover {
          background-color: rgba(255, 255, 255, 0.2);
        }
      `;
      document.head.appendChild(style);
    } catch (err) {}
  })();
})();

// aud.js
// Auditoriums page logic
// Access global ShowtimeState via window. Do not import as module because
// app.js attaches ShowtimeState to the window object.
(() => {
const ShowtimeState = window.ShowtimeState;

// Global flag used to suppress full re-renders while the user is tabbing
// through inputs. When true, blur/change handlers should update state
// without calling render() so that focus is not lost mid-tab.
let isTabbing = false;

function initAudPage() {
  const addBtn = document.getElementById('addAudBtn');
  // Reference the clear button if present
  const clearBtn = document.getElementById('clearAudBtn');
  const body = document.getElementById('audBody');

  function render() {
    const state = ShowtimeState.state;
    body.innerHTML = '';
    state.auds.forEach((aud) => {
      const tr = document.createElement('tr');
      tr.className = 'hover:bg-gray-50';
      // ID cell
      const tdId = document.createElement('td');
      // Constrain all columns to 10 characters wide and prevent them from growing
      // Expand ID column width to 20 characters. Doubling the width improves
      // legibility while still preventing responsive growth.
      tdId.style.width = '20ch';
      tdId.style.maxWidth = '20ch';
      tdId.className = 'px-3 py-2 truncate';
      tdId.textContent = aud.id;
      tr.appendChild(tdId);
      // Name cell
      const tdName = document.createElement('td');
      // Double the name column width to 20 characters to allow longer names.
      tdName.style.width = '20ch';
      tdName.style.maxWidth = '20ch';
      tdName.className = 'px-3 py-2 truncate navcell';
      const inputName = document.createElement('input');
      inputName.type = 'text';
      inputName.value = aud.name;
      // Let the input expand within the fixed-width cell
      inputName.className = 'border border-gray-300 rounded px-2 py-1 w-full';
      inputName.addEventListener('change', () => {
        aud.name = inputName.value;
        ShowtimeState.save();
        // Only re-render when not tabbing so that focus is preserved across fields
        if (!isTabbing) {
          render();
        }
      });
      tdName.appendChild(inputName);
      tr.appendChild(tdName);
      // Format cell
      const tdFmt = document.createElement('td');
      // Double the format column width to 20 characters.
      tdFmt.style.width = '20ch';
      tdFmt.style.maxWidth = '20ch';
      tdFmt.className = 'px-3 py-2 truncate navcell';
      const inputFmt = document.createElement('input');
      inputFmt.type = 'text';
      inputFmt.value = aud.format;
      // Make the input fill its cell
      inputFmt.className = 'border border-gray-300 rounded px-2 py-1 w-full';
      inputFmt.addEventListener('change', () => {
        aud.format = inputFmt.value;
        ShowtimeState.save();
        if (!isTabbing) {
          render();
        }
      });
      tdFmt.appendChild(inputFmt);
      tr.appendChild(tdFmt);
      // Seats cell
      const tdSeats = document.createElement('td');
      // Double the seats column width to 20 characters.
      tdSeats.style.width = '20ch';
      tdSeats.style.maxWidth = '20ch';
      tdSeats.className = 'px-3 py-2 truncate navcell';
      const inputSeats = document.createElement('input');
      inputSeats.type = 'number';
      inputSeats.min = '0';
      inputSeats.value = aud.seats;
      // Make the input fill its cell
      inputSeats.className = 'border border-gray-300 rounded px-2 py-1 w-full';
      inputSeats.addEventListener('change', () => {
        const val = parseInt(inputSeats.value, 10);
        aud.seats = isNaN(val) ? 0 : val;
        ShowtimeState.save();
        if (!isTabbing) {
          render();
        }
      });
      tdSeats.appendChild(inputSeats);
      tr.appendChild(tdSeats);
      // Create a Delete cell with a button to remove this auditorium.
      const tdDel = document.createElement('td');
      // Narrow width for delete column
      tdDel.style.width = '10ch';
      tdDel.style.maxWidth = '10ch';
      tdDel.className = 'px-3 py-2 truncate';
      const delBtn = document.createElement('button');
      delBtn.textContent = 'Delete';
      // Use a red colour to indicate a destructive action
      delBtn.className = 'text-red-700 hover:text-red-900';
      delBtn.addEventListener('click', () => {
        const state = ShowtimeState.state;
        const idx = state.auds.findIndex(a => a.id === aud.id);
        if (idx >= 0) {
          state.auds.splice(idx, 1);
          // Remove auditorium references from primeRows
          if (Array.isArray(state.primeRows)) {
            state.primeRows.forEach(row => {
              if (row.audId === aud.id) {
                row.audId = null;
              }
            });
          }
          // Remove overrides referencing this auditorium
          if (state.overrides && typeof state.overrides === 'object') {
            Object.keys(state.overrides).forEach(key => {
              const override = state.overrides[key];
              if (override && override.audId === aud.id) {
                delete override.audId;
                if (Object.keys(override).length === 0) {
                  delete state.overrides[key];
                }
              }
            });
          }
          ShowtimeState.save();
          // Dispatch storage event for other pages to update
          try {
            window.dispatchEvent(new Event('storage'));
          } catch {}
          render();
        }
      });
      tdDel.appendChild(delBtn);
      tr.appendChild(tdDel);
      body.appendChild(tr);
    });

    // After rendering rows, assign tab handlers to allow smooth tabbing
    assignTabHandlers();
  }

  addBtn.addEventListener('click', () => {
    const state = ShowtimeState.state;
    const maxId = state.auds.reduce((m, a) => Math.max(m, a.id), 0);
    state.auds.push({ id: maxId + 1, name: `Aud ${maxId + 1}`, format: 'Standard', seats: 100 });
    ShowtimeState.save();
    render();
  });

  // Handle clearing all auditoriums
  if (clearBtn) {
    clearBtn.addEventListener('click', () => {
      const state = ShowtimeState.state;
      // Remove all auditoriums
      state.auds = [];
      // Reset auditorium assignments in primeRows
      if (Array.isArray(state.primeRows)) {
        state.primeRows.forEach(row => {
          row.audId = null;
        });
      }
      // Remove audId from overrides
      if (state.overrides && typeof state.overrides === 'object') {
        Object.keys(state.overrides).forEach(key => {
          const override = state.overrides[key];
          if (override && override.audId) {
            delete override.audId;
            if (Object.keys(override).length === 0) {
              delete state.overrides[key];
            }
          }
        });
      }
      ShowtimeState.save();
      // Notify other pages of the update
      try {
        window.dispatchEvent(new Event('storage'));
      } catch {}
      render();
    });
  }

  window.addEventListener('storage', () => render());
  window.addEventListener('showtimeViewActivated', (evt) => {
    const detail = evt && evt.detail;
    const view = detail && detail.view ? detail.view : evt && evt.view;
    if (view === 'auditoriums') {
      render();
    }
  });
  render();

  // Assign custom tab behaviour to inputs in the auditoriums table. This function
  // gathers all input elements in the current table order and intercepts
  // Tab/Shift+Tab key presses to manually advance focus horizontally then
  // down a row. The state is updated via dispatching change events, and
  // full re-renders are suppressed during tabbing to preserve focus.
  function assignTabHandlers() {
    const rows = body.querySelectorAll('tr');
    // Record how many editable fields exist per row
    const rowFieldCounts = Array.from(rows).map(rowEl =>
      rowEl.querySelectorAll('input, select').length
    );
    // Assign dataset row/col to each field
    rows.forEach((rowEl, rIndex) => {
      const fields = rowEl.querySelectorAll('input, select');
      fields.forEach((fieldEl, cIndex) => {
        fieldEl.dataset.row = rIndex;
        fieldEl.dataset.col = cIndex;
      });
    });
    const allFields = body.querySelectorAll('input, select');
    allFields.forEach((el, idx) => {
      el.addEventListener('keydown', (e) => {
        const key = e.key;
        const r = parseInt(el.dataset.row || '0', 10);
        const c = parseInt(el.dataset.col || '0', 10);
        const rowCount = rows.length;
        const getField = (rowIndex, colIndex) => {
          return body.querySelector(`[data-row='${rowIndex}'][data-col='${colIndex}']`);
        };
        function moveFocus(targetRow, targetCol) {
          let newRow = targetRow;
          let newCol = targetCol;
          // Wrap vertical indices
          if (newRow < 0) newRow = rowCount - 1;
          if (newRow >= rowCount) newRow = 0;
          // Clamp horizontally and wrap across rows
          const maxCols = rowFieldCounts[newRow] || 0;
          if (newCol < 0) {
            newRow = (newRow - 1 + rowCount) % rowCount;
            newCol = (rowFieldCounts[newRow] || 0) - 1;
          } else if (newCol >= maxCols) {
            newRow = (newRow + 1) % rowCount;
            newCol = 0;
          }
          const dest = getField(newRow, newCol);
          if (dest) {
            // Indicate we are navigating to suppress re-renders
            isTabbing = true;
            // Commit current field's value
            el.dispatchEvent(new Event('change'));
            el.dispatchEvent(new Event('blur'));
            dest.focus();
            if (dest.select) {
              try { dest.select(); } catch {}
            }
            setTimeout(() => { isTabbing = false; }, 0);
          }
        }
        if (key === 'ArrowLeft') {
          e.preventDefault();
          moveFocus(r, c - 1);
          return;
        }
        if (key === 'ArrowRight') {
          e.preventDefault();
          moveFocus(r, c + 1);
          return;
        }
        if (key === 'ArrowUp') {
          e.preventDefault();
          moveFocus(r - 1, c);
          return;
        }
        if (key === 'ArrowDown' || key === 'Enter') {
          e.preventDefault();
          moveFocus(r + 1, c);
          return;
        }
        if (key === 'Tab') {
          isTabbing = true;
          e.preventDefault();
          el.dispatchEvent(new Event('change'));
          el.dispatchEvent(new Event('blur'));
          // Determine next field index with wrap
          let nextIndex = e.shiftKey ? idx - 1 : idx + 1;
          if (nextIndex < 0) nextIndex = allFields.length - 1;
          if (nextIndex >= allFields.length) nextIndex = 0;
          const nextEl = allFields[nextIndex];
          if (nextEl && nextEl.focus) {
            nextEl.focus();
            if (nextEl.select) {
              try { nextEl.select(); } catch {}
            }
          }
          setTimeout(() => { isTabbing = false; }, 0);
        }
      });
    });
  }
}

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initAudPage);
} else {
  initAudPage();
}

})();


// bookings.js
// Bookings page logic
// Access global ShowtimeState via window
(() => {
const ShowtimeState = window.ShowtimeState;

// Global flag used to suppress full re-renders during tab navigation. When
// isTabbing is true, blur/change handlers update state without calling
// render() so that focus is preserved when the user presses Tab.
let isTabbing = false;

// Timer handle used to detect the end of a tabbing sequence. When the
// user repeatedly presses Tab to move through inputs, we keep
// isTabbing true and only allow a re-render once no Tab key has
// been pressed for a short delay.  This prevents intermediate blur
// events from triggering a re-render and stealing focus.
let tabResetTimer = null;

function initBookingsPage() {
  const addBtn = document.getElementById('addBookingBtn');
  // Button to clear all bookings and reset to a single blank row
  const clearBtn = document.getElementById('clearBookingsBtn');
  const body = document.getElementById('bookingBody');

  // Hide the Add Booking button: we always keep a blank row at the bottom
  if (addBtn) {
    addBtn.style.display = 'none';
  }

  // Attach clear bookings handler
  if (clearBtn) {
    clearBtn.addEventListener('click', () => {
      // Remove all bookings and associated prime/extra rows.  We also
      // remove any overrides and manual shows tied to prime rows.  The
      // caller wants a fresh start with a single blank booking row.
      const state = ShowtimeState.state;
      state.bookings = [];
      // Clear primeRows and extraRows so no leftover films remain on the
      // prime schedule when starting over.  Without clearing extraRows
      // you could see old entries (e.g. Moon Harbor) linger after
      // clearing bookings.
      state.primeRows = [];
      state.extraRows = [];
      // It’s also safe to clear overrides that reference prime show ids
      // since those ids will be regenerated from bookings.  Manual
      // shows remain untouched to preserve any independent edits.
      if (state.overrides && typeof state.overrides === 'object') {
        Object.keys(state.overrides).forEach(key => {
          // If the override key references a prime row id (starts with
          // "PRB-" or "EX-") remove it.  Overrides for manual shows
          // (ids with colon) are preserved.
          if (/^(PRB-|EX-)/.test(key.split(':')[0])) {
            delete state.overrides[key];
          }
        });
      }
      ShowtimeState.save();
      ensurePrimeRows();
      // Re-render will detect no bookings and append a blank row
      render();
      // Refresh the film highlight dropdown after clearing bookings so that
      // old film names are removed immediately.  Without this call the
      // highlight dropdown may still include films whose bookings were just cleared.
      try {
        if (typeof window.refreshFilmHighlightOptions === 'function') {
          window.refreshFilmHighlightOptions();
        }
        if (typeof window.applyFilmHighlight === 'function') {
          window.applyFilmHighlight();
        }
      } catch (e) {
        /* ignore */
      }
    });
  }

  // Ensure prime rows mirror bookings with films assigned. Keep existing
  // auditorium and prime time assignments where possible.
  function ensurePrimeRows() {
    const state = ShowtimeState.state;
    const currentMap = new Map((state.primeRows || []).map(r => [r.bookingId, r]));
    const newPrimeRows = [];
    state.bookings.forEach(b => {
      // Only include bookings whose film exists and has a non-empty title.  This
      // prevents blank rows from appearing on the prime schedule until a
      // film title is provided.
      if (!b.filmId) return;
      const film = ShowtimeState.filmById(b.filmId);
      if (!film || !film.title) return;
      const existing = currentMap.get(b.id);
      newPrimeRows.push({
        rowId: existing?.rowId || `PRB-${b.id}`,
        bookingId: b.id,
        slot: b.slot,
        filmId: b.filmId,
        audId: existing?.audId ?? null,
        primeHM: existing?.primeHM ?? ''
      });
    });
    state.primeRows = newPrimeRows;
    ShowtimeState.save();
    // Dispatch a storage event so other pages (prime/schedule) update immediately.  The
    // storage event normally only fires across windows, so we trigger it manually
    // here after saving state.  This keeps the prime schedule in sync when a
    // booking's film or slot changes.
    try {
      const evt = new Event('storage');
      window.dispatchEvent(evt);
    } catch {}
  }

  function render() {
    const state = ShowtimeState.state;
    // Always sort bookings by numeric slot ascending before rendering
    state.bookings.sort((a, b) => {
      const sa = parseInt(a.slot, 10);
      const sb = parseInt(b.slot, 10);
      // Fallback to string comparison if parse fails
      if (!isNaN(sa) && !isNaN(sb)) return sa - sb;
      return String(a.slot).localeCompare(String(b.slot));
    });

    // Maintain exactly one blank row: check for bookings whose film title is empty.
    // Blank rows are those whose associated film has an empty title (or film record missing).
    let blankIndices = [];
    state.bookings.forEach((b, idx) => {
      const film = ShowtimeState.filmById(b.filmId);
      if (!film || !film.title) {
        blankIndices.push(idx);
      }
    });
    // Remove extra blank rows, keeping only the first found blank row
    if (blankIndices.length > 1) {
      // Remove from the end to avoid index shift
      for (let i = blankIndices.length - 1; i >= 1; i--) {
        const removeIndex = blankIndices[i];
        state.bookings.splice(removeIndex, 1);
      }
      ShowtimeState.save();
      ensurePrimeRows();
      // Recalculate blankIndices after removal
      blankIndices = [blankIndices[0]];
    }
    // If no blank rows exist, append one
    if (blankIndices.length === 0) {
      const filmId = `F${Date.now()}-${Math.floor(Math.random() * 1000)}`;
      // Do not prefill priority; leave blank
      state.films.push({ id: filmId, title: '', runtime: 0, trailer: 20, priority: '', rating: '', clean: 20, format: '' });
      // Determine the next slot number as one greater than the maximum existing slot number
      let maxSlot = 0;
      state.bookings.forEach(b => {
        const n = parseInt(b.slot, 10);
        if (!isNaN(n) && n > maxSlot) maxSlot = n;
      });
      const nextSlot = String(maxSlot + 1 || 1);
      const bookingId = `B${Date.now()}-${Math.floor(Math.random() * 1000)}`;
      // Do not prefill week or weeksOut; leave blank values
      state.bookings.push({ id: bookingId, week: '', slot: nextSlot, filmId: filmId, notes: '', weeksOut: '' });
      ShowtimeState.save();
      ensurePrimeRows();
    }
    body.innerHTML = '';
    // Maintain a running tabindex across all rows.  Assigning explicit tab
    // indices ensures that pressing Tab will move left‑to‑right through
    // inputs on a row and then down to the next row.  Without explicit
    // indices, the DOM insertion order can lead to unexpected jumps.
    let tabCounter = 1;
    state.bookings.forEach(b => {
      const tr = document.createElement('tr');
      tr.className = 'hover:bg-gray-50';
      // Look up film record; if missing, create a placeholder
      let film = ShowtimeState.filmById(b.filmId);
      if (!film && b.filmId) {
        // if film id is unknown, create placeholder record in memory (will not persist until changed)
        // Leave priority blank so the Priority column is not auto‑populated for unknown films
        film = { id: b.filmId, title: '', runtime: 0, trailer: 20, priority: '', rating: '', clean: 20, format: '' };
      }
      // Slot input (move to the beginning of the row so the Slot column appears first)
      const tdSlot = document.createElement('td');
      // Add navcell class for keyboard navigation highlight
      tdSlot.className = 'px-3 py-2 navcell';
      const inputSlot = document.createElement('input');
      inputSlot.type = 'text';
      inputSlot.value = b.slot;
      inputSlot.className = 'border border-gray-300 rounded px-2 py-1 w-12';
      inputSlot.tabIndex = tabCounter++;
      inputSlot.addEventListener('change', () => {
        b.slot = inputSlot.value;
        ShowtimeState.save();
        ensurePrimeRows();
        if (!isTabbing) {
          render();
        }
      });
      tdSlot.appendChild(inputSlot);
      tr.appendChild(tdSlot);

      // Title input
      const tdTitle = document.createElement('td');
      tdTitle.className = 'px-3 py-2 navcell';
      const inputTitle = document.createElement('input');
      inputTitle.type = 'text';
      inputTitle.value = film ? film.title : '';
      inputTitle.className = 'border border-gray-300 rounded px-2 py-1 w-40';
      // assign a tabindex so that this field appears in sequence
      inputTitle.tabIndex = tabCounter++;
      // Rely on native Tab behaviour for the title field.  Explicitly assigning
      // sequential tabIndex values across all inputs ensures that the focus
      // order moves left‑to‑right across a row and down to the next row when
      // the Tab key is pressed.  We avoid intercepting Tab on the title
      // field to allow the browser to manage focus naturally.
      inputTitle.addEventListener('blur', () => {
        // When the title field loses focus, update the film record.  If the
        // booking previously had no filmId (legacy blank row), create a new
        // film record and assign it.  This allows the user to fill in a
        // blank title and have it persist rather than disappear on blur.
        const titleVal = inputTitle.value.trim();
        if (!b.filmId) {
          if (titleVal) {
            // Create a new film record with reasonable defaults and assign it
            const newFilmId = `F${Date.now()}-${Math.floor(Math.random() * 1000)}`;
            const newFilm = {
              id: newFilmId,
              title: titleVal,
              runtime: film ? film.runtime || 0 : 0,
              trailer: film ? film.trailer || 20 : 20,
              // Do not prefill priority; carry over from placeholder if defined, otherwise leave blank
              priority: (film && film.priority !== undefined && film.priority !== '' && film.priority !== null) ? film.priority : '',
              rating: film ? film.rating || '' : '',
              clean: film ? film.clean || 20 : 20,
              // carry over format from placeholder film if present
              format: film && film.format ? film.format : ''
            };
            ShowtimeState.state.films.push(newFilm);
            b.filmId = newFilmId;
            ShowtimeState.save();
            ensurePrimeRows();
            // Only re-render if not tabbing; otherwise focus will be lost
            if (!isTabbing) {
              render();
            }
          }
          return;
        }
        // Otherwise update the existing film record.  If the title is blank,
        // clear it out so that ensurePrimeRows() will remove the corresponding
        // prime row.
        const f = ShowtimeState.state.films.find(x => x.id === b.filmId);
        if (f) {
          f.title = titleVal;
          ShowtimeState.save();
          ensurePrimeRows();
          // Only re-render if not tabbing
          if (!isTabbing) {
            render();
          }
        }
      });
      tdTitle.appendChild(inputTitle);
      tr.appendChild(tdTitle);

      // Format input (e.g., 2D, 3D)
      const tdFormat = document.createElement('td');
      tdFormat.className = 'px-3 py-2 navcell';
      const inputFormat = document.createElement('input');
      inputFormat.type = 'text';
      // Use film.format if present; otherwise empty string
      inputFormat.value = film && film.format ? film.format : '';
      inputFormat.className = 'border border-gray-300 rounded px-2 py-1 w-20';
      inputFormat.tabIndex = tabCounter++;
      inputFormat.addEventListener('blur', () => {
        const val = inputFormat.value.trim();
        // If a film record exists, update its format
        if (b.filmId) {
          const f = ShowtimeState.state.films.find(x => x.id === b.filmId);
          if (f) {
            f.format = val;
            ShowtimeState.save();
            // Only re-render if not tabbing
            if (!isTabbing) {
              render();
            }
          }
        } else {
          // No film record yet (blank row). Update placeholder film object so
          // that when a title is entered later, the new film picks up this format.
          if (film) {
            film.format = val;
          }
        }
      });
      tdFormat.appendChild(inputFormat);
      tr.appendChild(tdFormat);
      // Runtime input (minutes)
      const tdRuntime = document.createElement('td');
      tdRuntime.className = 'px-3 py-2 navcell';
      const inputRt = document.createElement('input');
      inputRt.type = 'number';
      inputRt.value = film ? film.runtime : 0;
      inputRt.className = 'border border-gray-300 rounded px-2 py-1 w-20';
      inputRt.tabIndex = tabCounter++;
      inputRt.addEventListener('blur', () => {
        if (!b.filmId) return;
        const f = ShowtimeState.state.films.find(x => x.id === b.filmId);
        if (f) {
          const num = parseInt(inputRt.value || '0', 10);
          f.runtime = isNaN(num) ? 0 : num;
          ShowtimeState.save();
          if (!isTabbing) {
            render();
          }
        }
      });
      tdRuntime.appendChild(inputRt);
      tr.appendChild(tdRuntime);
      // Trailer input (minutes)
      const tdTrailer = document.createElement('td');
      tdTrailer.className = 'px-3 py-2 navcell';
      const inputTrailer = document.createElement('input');
      inputTrailer.type = 'number';
      inputTrailer.value = film ? (film.trailer || 0) : 0;
      inputTrailer.className = 'border border-gray-300 rounded px-2 py-1 w-20';
      inputTrailer.tabIndex = tabCounter++;
      inputTrailer.addEventListener('blur', () => {
        if (!b.filmId) return;
        const f = ShowtimeState.state.films.find(x => x.id === b.filmId);
        if (f) {
          const num = parseInt(inputTrailer.value || '0', 10);
          f.trailer = isNaN(num) ? 0 : num;
          ShowtimeState.save();
          if (!isTabbing) {
            render();
          }
        }
      });
      tdTrailer.appendChild(inputTrailer);
      tr.appendChild(tdTrailer);
      // Priority input
      const tdPriority = document.createElement('td');
      tdPriority.className = 'px-3 py-2 navcell';
      const inputPriority = document.createElement('input');
      inputPriority.type = 'number';
      // Do not default priority to 1.  Use an empty string when undefined or blank
      if (film && film.priority !== undefined && film.priority !== '' && film.priority !== null) {
        inputPriority.value = film.priority;
      } else {
        inputPriority.value = '';
      }
      inputPriority.className = 'border border-gray-300 rounded px-2 py-1 w-16';
      inputPriority.tabIndex = tabCounter++;
      inputPriority.addEventListener('blur', () => {
        if (!b.filmId) return;
        const f = ShowtimeState.state.films.find(x => x.id === b.filmId);
        if (f) {
          // If the input is blank or not a number, clear the priority so that
          // the Priority column is not auto-filled.  Otherwise set the numeric value.
          const val = (inputPriority.value || '').trim();
          const num = parseInt(val, 10);
          if (val === '' || isNaN(num)) {
            f.priority = '';
          } else {
            f.priority = num;
          }
          ShowtimeState.save();
          if (!isTabbing) {
            render();
          }
        }
      });
      tdPriority.appendChild(inputPriority);
      tr.appendChild(tdPriority);
      // Rating input
      const tdRating = document.createElement('td');
      tdRating.className = 'px-3 py-2 navcell';
      const inputRating = document.createElement('input');
      inputRating.type = 'text';
      inputRating.value = film ? (film.rating || '') : '';
      inputRating.className = 'border border-gray-300 rounded px-2 py-1 w-16';
      inputRating.tabIndex = tabCounter++;
      inputRating.addEventListener('blur', () => {
        if (!b.filmId) return;
        const f = ShowtimeState.state.films.find(x => x.id === b.filmId);
        if (f) {
          f.rating = inputRating.value;
          ShowtimeState.save();
          if (!isTabbing) {
            render();
          }
        }
      });
      tdRating.appendChild(inputRating);
      tr.appendChild(tdRating);
      // Notes input
      const tdNotes = document.createElement('td');
      tdNotes.className = 'px-3 py-2 navcell';
      const inputNotes = document.createElement('input');
      inputNotes.type = 'text';
      inputNotes.value = b.notes || '';
      inputNotes.className = 'border border-gray-300 rounded px-2 py-1 w-40';
      inputNotes.tabIndex = tabCounter++;
      inputNotes.addEventListener('change', () => {
        b.notes = inputNotes.value;
        ShowtimeState.save();
        if (!isTabbing) {
          render();
        }
      });
      tdNotes.appendChild(inputNotes);
      tr.appendChild(tdNotes);
      // Weeks Out input
      const tdWeeks = document.createElement('td');
      tdWeeks.className = 'px-3 py-2 navcell';
      const inputWeeks = document.createElement('input');
      inputWeeks.type = 'number';
      // Do not default weeksOut to 1; leave empty if undefined or blank.
      if (b.weeksOut !== undefined && b.weeksOut !== '' && b.weeksOut !== null) {
        inputWeeks.value = b.weeksOut;
      } else {
        inputWeeks.value = '';
      }
      inputWeeks.className = 'border border-gray-300 rounded px-2 py-1 w-16';
      inputWeeks.tabIndex = tabCounter++;
      inputWeeks.addEventListener('change', () => {
        // When weeksOut is changed, if the input is blank or invalid, clear it.
        const val = (inputWeeks.value || '').trim();
        const num = parseInt(val, 10);
        if (val === '' || isNaN(num)) {
          b.weeksOut = '';
        } else {
          b.weeksOut = num;
        }
        ShowtimeState.save();
        if (!isTabbing) {
          render();
        }
      });
      tdWeeks.appendChild(inputWeeks);
      tr.appendChild(tdWeeks);
      // Clean input
      const tdClean = document.createElement('td');
      tdClean.className = 'px-3 py-2 navcell';
      const inputClean = document.createElement('input');
      inputClean.type = 'number';
      inputClean.value = film ? (film.clean || 0) : 0;
      inputClean.className = 'border border-gray-300 rounded px-2 py-1 w-20';
      inputClean.tabIndex = tabCounter++;
      inputClean.addEventListener('blur', () => {
        if (!b.filmId) return;
        const f = ShowtimeState.state.films.find(x => x.id === b.filmId);
        if (f) {
          const num = parseInt(inputClean.value || '0', 10);
          f.clean = isNaN(num) ? 0 : num;
          ShowtimeState.save();
          if (!isTabbing) {
            render();
          }
        }
      });
      tdClean.appendChild(inputClean);
      tr.appendChild(tdClean);

      // Delete booking button.  Provide a per‑row delete/trash control at
      // the end of the row.  When clicked, remove the booking, its
      // associated prime/extra rows and any orphaned film record.  Then
      // persist and re-render the table.  Using a simple trash icon
      // ensures accessibility without relying on external icon fonts.
      const tdDelete = document.createElement('td');
      tdDelete.className = 'px-2 py-2 navcell text-center';
      const delBtn = document.createElement('button');
      delBtn.type = 'button';
      delBtn.title = 'Delete booking';
      // Use a unicode trash icon for broad compatibility.  Tailwind
      // classes provide sizing and hover feedback.  The button
      // inherits the surrounding text colour so it blends with the
      // table header.  The focus outline is removed for a cleaner
      // look.
      delBtn.className = 'text-red-600 hover:text-red-800 focus:outline-none';
      delBtn.textContent = '🗑️';
      delBtn.addEventListener('click', () => {
        const state = ShowtimeState.state;
        // Locate this booking by id
        const idx = state.bookings.findIndex(x => x.id === b.id);
        if (idx !== -1) {
          const removed = state.bookings[idx];
          const removedFilmId = removed.filmId;
          // Remove the booking
          state.bookings.splice(idx, 1);
          // Remove associated prime and extra rows referencing this booking
          if (Array.isArray(state.primeRows)) {
            state.primeRows = state.primeRows.filter(pr => pr.bookingId !== removed.id);
          }
          if (Array.isArray(state.extraRows)) {
            state.extraRows = state.extraRows.filter(er => er.bookingId !== removed.id);
          }
          // Remove overrides tied to this booking (prime or extra) by id prefix
          if (state.overrides && typeof state.overrides === 'object') {
            Object.keys(state.overrides).forEach(key => {
              // Overrides for prime/extra shows start with the row id (PRB‑ or EX‑)
              const baseId = key.split(':')[0];
              if (/^(PRB-|EX-)/.test(baseId)) {
                const row = state.primeRows.find(r => r.rowId === baseId) || state.extraRows.find(r => r.rowId === baseId);
                if (row && row.bookingId === removed.id) {
                  delete state.overrides[key];
                }
              }
            });
          }
          // Remove film if no other booking uses it.  Check across all
          // remaining bookings before deleting the film record.  This
          // prevents deleting films still referenced by other bookings.
          if (removedFilmId) {
            const stillUsed = state.bookings.some(bb => bb.filmId === removedFilmId);
            if (!stillUsed) {
              const filmIdx = state.films.findIndex(f => f.id === removedFilmId);
              if (filmIdx !== -1) {
                state.films.splice(filmIdx, 1);
              }
            }
          }
          ShowtimeState.save();
          ensurePrimeRows();
          render();
        }
      });
      tdDelete.appendChild(delBtn);
      tr.appendChild(tdDelete);
      // Tag this row with a filmId if the film exists and has a title.  This
      // allows applyFilmHighlight() to highlight rows matching the selected film.
      if (film && film.id && film.title) {
        tr.dataset.filmid = String(film.id);
      }
      body.appendChild(tr);
    });

    // After rendering all rows, attach custom Tab handlers.  Using
    // assignTabHandlers() allows us to intercept Tab presses on each
    // input and update state before shifting focus.  Without this,
    // default browser Tab behaviour can be disrupted by our blur
    // handlers which trigger re‑renders.  assignTabHandlers uses the
    // document order of inputs to move focus horizontally across the
    // row and then down to the next row.
    assignTabHandlers();

    // Update the film highlight dropdown options in case films were added or
    // removed during this render.  This function is defined in app.js
    // and safe to call if undefined.
    if (typeof window.refreshFilmHighlightOptions === 'function') {
      window.refreshFilmHighlightOptions();
    }

    // Apply film highlighting after the rows have been constructed.  This
    // ensures that newly added or modified rows are highlighted (or
    // unhighlighted) according to the current selection.  The function
    // is defined in app.js and safely no-ops if undefined.
    if (typeof window.applyFilmHighlight === 'function') {
      window.applyFilmHighlight();
    }
  }

  addBtn.addEventListener('click', () => {
    const state = ShowtimeState.state;
    // Create a new film with default values
    const filmId = `F${Date.now()}-${Math.floor(Math.random()*1000)}`;
    // Do not prefill priority when adding a new row via the Add button
    state.films.push({ id: filmId, title: '', runtime: 0, trailer: 20, priority: '', rating: '', clean: 20, format: '' });
    const nextSlot = String(state.bookings.length + 1);
    const bookingId = `B${Date.now()}-${Math.floor(Math.random()*1000)}`;
    // Do not prefill week or weeksOut when adding a new booking; leave blank
    state.bookings.push({ id: bookingId, week: '', slot: nextSlot, filmId: filmId, notes: '', weeksOut: '' });
    ShowtimeState.save();
    ensurePrimeRows();
    render();
  });

  // When the underlying state changes (e.g. from another tab), we
  // refresh prime rows and re-render.  However, if a tabbing
  // operation is underway on this page, skip the re-render to
  // preserve focus order.  The assignTabHandlers logic will
  // eventually call render() at a safe time after tabbing completes.
  window.addEventListener('storage', () => {
    ensurePrimeRows();
    if (!isTabbing) {
      render();
    }
  });
  render();

  // The body keydown listener used in earlier versions to toggle the
  // isTabbing flag on Tab presses is removed.  assignTabHandlers
  // manages tabbing sessions explicitly and schedules re-renders once
  // the user has paused tab navigation.

  // Define helper to assign custom Tab behaviour to inputs. This
  // function collects all input and select elements within the
  // bookings table body and intercepts Tab key presses to update
  // state and manually move focus. When isTabbing is true, input
  // change/blur handlers will skip the full re-render, preserving
  // focus across fields.
  function assignTabHandlers() {
    const fields = body.querySelectorAll('input, select');
    // Build an array of row objects to map inputs/selects to their row
    // and column positions.  rowsArr keeps the order of rows as they
    // appear in the DOM and records all editable fields per row.  This
    // structure is used by the ArrowDown handlers to navigate to the
    // same column on the next row.
    const rowsArr = [];
    fields.forEach((el, idx) => {
      const tr = el.closest('tr');
      let row = rowsArr.find(r => r.rowEl === tr);
      if (!row) {
        row = { rowEl: tr, fields: [] };
        rowsArr.push(row);
      }
      row.fields.push(el);
    });
    // Determine the maximum number of fields among rows.  This value is
    // used to detect when Tab moves past the last editable field in
    // a row (to trigger a re-render that inserts a blank row).
    let fieldsPerRow = 0;
    rowsArr.forEach(row => {
      if (row.fields.length > fieldsPerRow) {
        fieldsPerRow = row.fields.length;
      }
    });
    // Convert NodeList to an array for index operations
    const fieldArray = Array.from(fields);
    fields.forEach((el, idx) => {
      el.addEventListener('keydown', (e) => {
        // Handle ArrowDown: move to the field in the same column on the
        // next row if possible.  Use the rowsArr mapping to determine
        // current row/column and locate the corresponding element.
        if (e.key === 'ArrowDown') {
          e.preventDefault();
          // Determine the current row and column of this element
          let curRow = -1;
          let curCol = -1;
          for (let rIdx = 0; rIdx < rowsArr.length; rIdx++) {
            const colIdx = rowsArr[rIdx].fields.indexOf(el);
            if (colIdx !== -1) {
              curRow = rIdx;
              curCol = colIdx;
              break;
            }
          }
          if (curRow !== -1) {
            const nextRow = rowsArr[curRow + 1];
            if (nextRow) {
              // Clamp column to the number of fields in the next row
              const targetCol = Math.min(curCol, nextRow.fields.length - 1);
              const nextEl = nextRow.fields[targetCol];
              if (nextEl && nextEl.focus) {
                nextEl.focus();
                if (nextEl.select) {
                  try { nextEl.select(); } catch {}
                }
              }
            }
          }
          return;
        }
        if (e.key === 'Tab') {
          // Signal that a tabbing operation is underway so blur
          // handlers skip triggering a full re‑render.  Clear any
          // existing reset timer to extend the tabbing session.
          clearTimeout(tabResetTimer);
          isTabbing = true;
          e.preventDefault();
          // Trigger change and blur on the current element so its
          // handlers persist changes to state without re‑rendering.
          el.dispatchEvent(new Event('change'));
          el.dispatchEvent(new Event('blur'));
          // Compute the index of the next field.  If Shift+Tab was
          // pressed, move backwards; otherwise forwards.  Wrap around
          // the list boundaries to cycle through all fields.
          let nextIndex = e.shiftKey ? idx - 1 : idx + 1;
          if (nextIndex < 0) nextIndex = fields.length - 1;
          if (nextIndex >= fields.length) nextIndex = 0;
          const nextEl = fields[nextIndex];
          // Move focus to the next element and select its contents if
          // possible.  Using focus() ensures the element is ready for
          // immediate input.
          if (nextEl && nextEl.focus) {
            nextEl.focus();
            if (nextEl.select) {
              try { nextEl.select(); } catch {}
            }
          }
          // Schedule a reset of the tabbing flag after a delay.  If
          // the user continues pressing Tab, this timer will be
          // cleared and restarted on each key press.  Once the user
          // pauses for the specified delay, we end the tabbing
          // session, reset the flag, and allow subsequent re-renders.
          tabResetTimer = setTimeout(() => {
            isTabbing = false;
          }, 200);

          // If we've just tabbed out of the last field in a row, schedule a
          // re-render to insert a new blank row.  Use the computed
          // fieldsPerRow to detect row boundaries rather than a hard
          // coded constant so this logic remains correct if columns
          // change.
          if (!e.shiftKey && fieldsPerRow > 0 && (idx % fieldsPerRow === fieldsPerRow - 1)) {
            setTimeout(() => {
              render();
            }, 0);
          }
        }
      });
    });

    // Global handler for ArrowDown on the bookings table body.  This
    // delegates to the rowsArr mapping to determine the element
    // immediately below the currently focused field in the same column.
    body.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowDown') {
        const active = document.activeElement;
        const idx = fieldArray.indexOf(active);
        if (idx !== -1) {
          e.preventDefault();
          // Determine current row and column of the active element
          let curRow = -1;
          let curCol = -1;
          for (let rIdx = 0; rIdx < rowsArr.length; rIdx++) {
            const colIdx = rowsArr[rIdx].fields.indexOf(active);
            if (colIdx !== -1) {
              curRow = rIdx;
              curCol = colIdx;
              break;
            }
          }
          if (curRow !== -1) {
            const nextRow = rowsArr[curRow + 1];
            if (nextRow) {
              const targetCol = Math.min(curCol, nextRow.fields.length - 1);
              const nextEl = nextRow.fields[targetCol];
              if (nextEl && nextEl.focus) {
                nextEl.focus();
                if (nextEl.select) {
                  try { nextEl.select(); } catch {}
                }
              }
            }
          }
        }
      }
    });
  }
  /* Override assignTabHandlers with enhanced arrow-key navigation. The new
     implementation mirrors spreadsheet behaviour: ArrowLeft/Right move
     horizontally with wrap, ArrowUp/Down move vertically (Enter acts as
     down), and Tab/Shift+Tab move linearly while committing edits and
     scheduling re-renders when leaving the last cell of a row. */
  function assignTabHandlers() {
    const fields = body.querySelectorAll('input, select');
    const rowsArr = [];
    fields.forEach((el) => {
      const tr = el.closest('tr');
      let row = rowsArr.find(r => r.rowEl === tr);
      if (!row) {
        row = { rowEl: tr, fields: [] };
        rowsArr.push(row);
      }
      row.fields.push(el);
    });
    let fieldsPerRow = 0;
    rowsArr.forEach(row => {
      if (row.fields.length > fieldsPerRow) {
        fieldsPerRow = row.fields.length;
      }
    });
    fields.forEach((el, idx) => {
      el.addEventListener('keydown', (e) => {
        const key = e.key;
        let curRow = -1;
        let curCol = -1;
        for (let rIdx = 0; rIdx < rowsArr.length; rIdx++) {
          const colIdx = rowsArr[rIdx].fields.indexOf(el);
          if (colIdx !== -1) {
            curRow = rIdx;
            curCol = colIdx;
            break;
          }
        }
        function moveCell(rowIndex, colIndex) {
          const rowCount = rowsArr.length;
          let r = rowIndex;
          let c = colIndex;
          if (r < 0) r = rowCount - 1;
          if (r >= rowCount) r = 0;
          if (c < 0) {
            r = (r - 1 + rowCount) % rowCount;
            c = rowsArr[r].fields.length - 1;
          } else if (c >= rowsArr[r].fields.length) {
            r = (r + 1) % rowCount;
            c = 0;
          }
          const dest = rowsArr[r].fields[c];
          if (dest) {
            isTabbing = true;
            el.dispatchEvent(new Event('change'));
            el.dispatchEvent(new Event('blur'));
            dest.focus();
            if (dest.select) {
              try { dest.select(); } catch {}
            }
            setTimeout(() => { isTabbing = false; }, 0);
          }
        }
        if (key === 'ArrowLeft') {
          if (curRow !== -1) {
            e.preventDefault();
            moveCell(curRow, curCol - 1);
          }
          return;
        }
        if (key === 'ArrowRight') {
          if (curRow !== -1) {
            e.preventDefault();
            moveCell(curRow, curCol + 1);
          }
          return;
        }
        if (key === 'ArrowUp') {
          if (curRow !== -1) {
            e.preventDefault();
            moveCell(curRow - 1, curCol);
          }
          return;
        }
        if (key === 'ArrowDown' || key === 'Enter') {
          if (curRow !== -1) {
            e.preventDefault();
            moveCell(curRow + 1, curCol);
          }
          return;
        }
        if (key === 'Tab') {
          clearTimeout(tabResetTimer);
          isTabbing = true;
          e.preventDefault();
          el.dispatchEvent(new Event('change'));
          el.dispatchEvent(new Event('blur'));
          let nextIndex = e.shiftKey ? idx - 1 : idx + 1;
          if (nextIndex < 0) nextIndex = fields.length - 1;
          if (nextIndex >= fields.length) nextIndex = 0;
          const nextEl = fields[nextIndex];
          if (nextEl && nextEl.focus) {
            nextEl.focus();
            if (nextEl.select) {
              try { nextEl.select(); } catch {}
            }
          }
          tabResetTimer = setTimeout(() => {
            isTabbing = false;
          }, 200);
          if (!e.shiftKey && fieldsPerRow > 0 && (idx % fieldsPerRow === fieldsPerRow - 1)) {
            setTimeout(() => {
              render();
            }, 0);
          }
        }
      });
    });
    body.onkeydown = null;
  }

  window.addEventListener('showtimeViewActivated', (evt) => {
    const detail = evt && evt.detail;
    const view = detail && detail.view ? detail.view : evt && evt.view;
    if (view === 'bookings') {
      render();
    }
  });
}

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initBookingsPage);
} else {
  initBookingsPage();
}

})();


// prime.js
// Prime schedule page logic
// Access global ShowtimeState via window
(() => {
const ShowtimeState = window.ShowtimeState;

// Keep track of the currently open custom prime dropdown menu so that only one menu
// is open at a time. When the user clicks anywhere else on the page, this menu
// will be closed. This emulates the behaviour of a native <select>.
let openPrimeDropdownMenu = null;

function initPrimePage() {
  // Initialise multi‑date support. This will migrate existing schedule
  // data into the current date entry and load the schedule for
  // state.currentDate. It must be called before rendering or
  // manipulating schedules.
  ShowtimeState.initDateSupport();
  // Close any open prime dropdown menu when the user clicks outside of it. We
  // attach this listener once at load time so that each render doesn’t add
  // another listener. When the document is clicked, we hide the currently
  // open menu (if any) and reset the tracker.
  document.addEventListener('click', () => {
    if (openPrimeDropdownMenu) {
      openPrimeDropdownMenu.classList.add('hidden');
      openPrimeDropdownMenu = null;
    }
  });
  // References to first/last show selectors (if present)
  const firstSel = document.getElementById('firstShowPrimeSelect');
  const lastSel = document.getElementById('lastShowPrimeSelect');
  // Reference to the date picker
  const dateInput = document.getElementById('scheduleDatePrime');
  // Reference to the clear times button. We'll attach a single handler below.
  const clearBtn = document.getElementById('clearTimesBtn');

  // Attach clear handler once. The handler uses the shared helper in
  // ShowtimeState to reset all showtimes across the application. After
  // clearing, we re-render and dispatch a storage event so other tabs
  // (schedule grid, order panel) refresh their state. We guard the
  // dispatch in try/catch because some browsers (Safari) may throw.
  if (clearBtn) {
    clearBtn.addEventListener('click', () => {
      ShowtimeState.clearAllTimes();
      render();
      try {
        const evt = new Event('storage');
        window.dispatchEvent(evt);
      } catch {}
    });
  }

  // Sync the date picker with the current schedule date. When the
  // user selects a new date, save the current schedule, load the new
  // schedule and re-render the page. Additionally update the picker
  // value when a date change originates elsewhere (e.g. another tab
  // triggering setDate). We listen for our custom showtimeDateChanged
  // event for this purpose.
  if (dateInput) {
    // Set initial value in MM/DD/YYYY format
    const curDate = ShowtimeState.getCurrentDate();
    if (curDate) dateInput.value = ShowtimeState.isoToMMDD(curDate);
    // When user changes date: parse MM/DD/YYYY to ISO and update state
    dateInput.addEventListener('change', () => {
      const inputVal = dateInput.value;
      if (!inputVal) return;
      const iso = ShowtimeState.mmddToIso(inputVal);
      if (!iso) {
        alert('Invalid date format. Please use MM/DD/YYYY.');
        return;
      }
      // Update display to canonical format (in case user omitted leading zeros)
      dateInput.value = ShowtimeState.isoToMMDD(iso);
      ShowtimeState.setDate(iso);
      // Render will be triggered by our listener below, but we call
      // directly to ensure immediate update
      render();
    });
    // Update picker value when date changes from other sources
    window.addEventListener('showtimeDateChanged', () => {
      const current = ShowtimeState.getCurrentDate();
      if (current) {
        dateInput.value = ShowtimeState.isoToMMDD(current);
      }
      // Re-render schedule when date changes
      render();
    });
  }

  // Hook up previous/next date buttons for the prime schedule.  These
  // buttons appear alongside the date input in the header.  Clicking
  // the arrows will move the current date backward or forward by one
  // day, update the input display and trigger a re-render of the
  // schedule.  If the current date is invalid or unset, today's date
  // is used as the baseline.  Note: we call render() directly after
  // updating the date; listeners on showtimeDateChanged will also
  // trigger render, but calling it here ensures immediate feedback.
  const prevPrimeBtn = document.getElementById('prevDatePrimeBtn');
  const nextPrimeBtn = document.getElementById('nextDatePrimeBtn');
  function shiftDatePrime(delta) {
    const curIso = ShowtimeState.getCurrentDate();
    let d = curIso ? new Date(curIso) : new Date();
    if (isNaN(d)) d = new Date();
    d.setDate(d.getDate() + delta);
    const iso = d.toISOString().slice(0, 10);
    ShowtimeState.setDate(iso);
    if (dateInput) dateInput.value = ShowtimeState.isoToMMDD(iso);
    render();
  }
  if (prevPrimeBtn) prevPrimeBtn.addEventListener('click', () => shiftDatePrime(-1));
  if (nextPrimeBtn) nextPrimeBtn.addEventListener('click', () => shiftDatePrime(1));

  // Populate first/last show dropdowns with 30‑minute increments. Mirrors schedule-grid.
  function populateTimeSelectors() {
    if (!firstSel || !lastSel) return;
    // Generate times from 05:00 to 19:00 in 30‑minute steps
    const times = [];
    let t = ShowtimeState.dtFromHM('05:00');
    const end = ShowtimeState.dtFromHM('19:00');
    while (t <= end) {
      times.push(ShowtimeState.hmFromDate(t));
      t = new Date(t.getTime() + 30 * 60000);
    }
    // Generate last show options manually covering 20:00 through 02:00 (next day) in 30‑minute steps
    const lastTimes = ['20:00','20:30','21:00','21:30','22:00','22:30','23:00','23:30','00:00','00:30','01:00','01:30','02:00'];
    // Clear existing
    firstSel.innerHTML = '';
    lastSel.innerHTML = '';
    times.forEach(hm => {
      const opt = document.createElement('option');
      opt.value = hm;
      opt.textContent = ShowtimeState.fmtHM(hm);
      firstSel.appendChild(opt);
    });
    lastTimes.forEach(hm => {
      const opt = document.createElement('option');
      opt.value = hm;
      opt.textContent = ShowtimeState.fmtHM(hm);
      lastSel.appendChild(opt);
    });
    // Set selected values from state
    if (ShowtimeState.state.firstShowHM) firstSel.value = ShowtimeState.state.firstShowHM;
    if (ShowtimeState.state.lastShowHM) lastSel.value = ShowtimeState.state.lastShowHM;
  }

  // Handle changes to first/last show selects
  if (firstSel && lastSel) {
    firstSel.addEventListener('change', () => {
      ShowtimeState.state.firstShowHM = firstSel.value;
      ShowtimeState.save();
      render();
    });
    lastSel.addEventListener('change', () => {
      ShowtimeState.state.lastShowHM = lastSel.value;
      ShowtimeState.save();
      render();
    });
  }
  const body = document.getElementById('primeBody');

  // We no longer attach a second clear handler here. The handler above
  // covers the clearing logic.

  // Generate prime time options: 5‑minute increments from 6:00p to 8:30p.
  function generatePrimeOptions() {
    const opts = [];
    // Start at 18:00 (6:00 PM) on an arbitrary date
    let t = ShowtimeState.dtFromHM('18:00');
    let end = ShowtimeState.dtFromHM('20:30');
    // If end is before start (e.g., crosses midnight), adjust by adding a day
    if (end < t) {
      end = new Date(end.getTime());
      end.setDate(end.getDate() + 1);
    }
    while (true) {
      opts.push(ShowtimeState.hmFromDate(t));
      if (t.getTime() >= end.getTime()) break;
      // Advance by 5 minutes
      t = new Date(t.getTime() + 5 * 60000);
    }
    return opts;
  }

  function render() {
    const state = ShowtimeState.state;

    // Ensure first/last show selectors are populated and synced to state
    populateTimeSelectors();

    // Ensure primeRows mirror current bookings with films assigned. This keeps
    // the prime table populated when visiting the page without first editing
    // bookings. Rows that already exist preserve their auditorium and prime time.
    (function ensurePrimeRows() {
      const currentMap = new Map((state.primeRows || []).map(r => [r.bookingId, r]));
      const newPrimeRows = [];
      state.bookings.forEach(b => {
        // Only include bookings whose film exists and has a non-empty title.
        if (!b.filmId) return;
        const film = ShowtimeState.filmById(b.filmId);
        if (!film || !film.title) return;
        const existing = currentMap.get(b.id);
        // Always use the booking's filmId for the prime row.  The prime
        // schedule mirrors the bookings list and does not allow editing
        // the film or slot.  Preserve auditorium and prime time from
        // existing rows if present.
        newPrimeRows.push({
          rowId: existing?.rowId || `PRB-${b.id}`,
          bookingId: b.id,
          slot: b.slot,
          filmId: b.filmId,
          audId: existing?.audId ?? null,
          primeHM: existing?.primeHM ?? ''
        });
      });
      state.primeRows = newPrimeRows;
      ShowtimeState.save();
    })();
    body.innerHTML = '';
    // Map to count prime time usage for highlighting duplicate prime times
    const primeCounts = {};
    state.primeRows.forEach(r => {
      if (r.primeHM) {
        primeCounts[r.primeHM] = (primeCounts[r.primeHM] || 0) + 1;
      }
    });
    // Map to count auditorium usage for highlighting duplicate auditorium assignments.  We
    // count assigned auditoriums across all primeRows and extraRows.  A
    // duplicate auditorium (selected more than once) will be highlighted in
    // the dropdown menu except for the current row, similar to how duplicate
    // prime times are highlighted.
    const audCounts = {};
    state.primeRows.concat(state.extraRows).forEach(r => {
      if (r.audId) {
        audCounts[r.audId] = (audCounts[r.audId] || 0) + 1;
      }
    });
    // Rows come from primeRows followed by extraRows
    // Combine prime and extra rows and sort by numeric slot ascending.  Sorting
    // ensures rows display in logical slot order even if previous edits
    // created gaps.  We parse as integers and fallback to lexical
    // comparison if parse fails.
    const rows = state.primeRows.concat(state.extraRows).sort((a,b) => {
      const sa = parseInt(a.slot, 10);
      const sb = parseInt(b.slot, 10);
      if (!isNaN(sa) && !isNaN(sb)) return sa - sb;
      return String(a.slot || '').localeCompare(String(b.slot || ''));
    });
    rows.forEach((row, idx) => {
      const tr = document.createElement('tr');
      // Apply zebra striping for improved readability.  Even rows use white, odd rows use a light gray.  Hover
      // effect darkens slightly.
      tr.className = (idx % 2 === 0 ? 'bg-white' : 'bg-gray-50') + ' hover:bg-gray-100';
      // Auditorium select
      const tdAud = document.createElement('td');
      tdAud.className = 'px-3 py-2';
      const selAud = document.createElement('select');
      // Narrow the auditorium selector on the prime schedule
      selAud.className = 'appearance-none border border-gray-300 rounded px-2 py-1 w-24';
      const blankAudOpt = document.createElement('option');
      blankAudOpt.value = '';
      blankAudOpt.textContent = '';
      selAud.appendChild(blankAudOpt);
      ShowtimeState.state.auds.forEach(a => {
        const opt = document.createElement('option');
        opt.value = a.id;
        opt.textContent = a.name;
        // Highlight duplicate auditorium assignments.  If this auditorium is
        // selected in more than one row, colour the option red and bold
        // unless it is only selected on the current row.  We look up
        // audCounts from the outer scope.
        if (audCounts[a.id] && (row.audId !== a.id || audCounts[a.id] > 1)) {
          opt.style.color = '#dc2626'; // Tailwind red-600
          opt.style.fontWeight = 'bold';
        }
        selAud.appendChild(opt);
      });
      selAud.value = row.audId || '';
      selAud.addEventListener('change', () => {
        const val = selAud.value;
        ShowtimeState.setRowField(row.rowId, 'audId', val ? parseInt(val, 10) : null);
        render();
      });
      tdAud.appendChild(selAud);
      tr.appendChild(tdAud);
      // Slot cell (static)
      const tdSlot = document.createElement('td');
      tdSlot.className = 'px-3 py-2';
      tdSlot.textContent = row.slot || '';
      tr.appendChild(tdSlot);
      // Film cell: display the film title from the booking.  Editing films on
      // the prime schedule is disabled; any changes must be made on the
      // bookings tab.  We still show an empty cell if no film assigned.
      const tdFilm = document.createElement('td');
      tdFilm.className = 'px-3 py-2';
      // Set a minimum width on the film title column so that short titles do not cause
      // the pre/post columns to collapse into unused space.  A width of 16ch
      // accommodates most typical film titles without wrapping.
      tdFilm.style.minWidth = '16ch';
      const filmRec = ShowtimeState.filmById(row.filmId);
      // Display the film title together with its format (if present).  This ensures
      // that users can see whether a film is, for example, a 3D version without
      // having to refer back to the bookings tab.
      tdFilm.textContent = filmRec ? (filmRec.title + (filmRec.format ? ' ' + filmRec.format : '')) : '';
      tr.appendChild(tdFilm);
      // Turnkey cell: display the total cycle time (runtime + trailer + clean) as hours and minutes.
      const tdRt = document.createElement('td');
      tdRt.className = 'px-3 py-2';
      const film = ShowtimeState.filmById(row.filmId);
      // Compute the total cycle minutes using ShowtimeState.cycleMinutes and format to HhMM.
      const toHMM = (mins) => {
        const m = parseInt(mins, 10) || 0;
        const h = Math.floor(m / 60);
        const mm = Math.abs(m % 60);
        return `${h}h${String(mm).padStart(2, '0')}`;
      };
      if (film) {
        const cycleMins = ShowtimeState.cycleMinutes(film);
        tdRt.textContent = toHMM(cycleMins);
      } else {
        tdRt.textContent = '0h00';
      }
      tr.appendChild(tdRt);
      // Helper to get all shows for this row, applying overrides and manual shows.
      function getShowsForRow(r) {
        const out = [];
        // Base shows from buildRowShowtimes (prime cycles)
        const base = ShowtimeState.buildRowShowtimes(r);
        base.forEach(s => out.push({ ...s }));
        // Include manual shows for this row. Manual shows apply to both prime
        // rows and extra rows so that the prime schedule reflects any
        // manually added showtimes on the schedule grid.
        (state.manualShows || []).forEach(ms => {
          if (ms.rowId === r.rowId) out.push({ ...ms });
        });
        // Apply overrides and skip hidden shows
        const results = [];
        out.forEach(rec => {
          // skip hidden shows
          if (state.hiddenShows && state.hiddenShows[rec.id]) return;
          const ov = state.overrides ? state.overrides[rec.id] : undefined;
          let s = { ...rec };
          if (ov) {
            // Override start
            if (ov.start) {
              const newStart = new Date(ov.start);
              s.start = newStart;
              // recompute end using film runtime + trailer + clean
              const film = ShowtimeState.filmById(ov.filmId || s.filmId);
              if (film) {
                const totalMins = (film.runtime || 0) + (film.trailer || 0) + (film.clean || 0);
                s.end = new Date(newStart.getTime() + totalMins * 60000);
                s.runtime = film.runtime;
                s.trailer = film.trailer;
                s.clean = film.clean;
                s.filmId = film.id;
                // Always include the film format in the title for display on the
                // prime schedule, matching how other pages concatenate format.
                s.filmTitle = film.title + (film.format ? ' ' + film.format : '');
                s.cycle = ShowtimeState.cycleMinutes(film);
              }
            }
            // Override auditorium
            if (ov.audId) {
              s.audId = ov.audId;
              const a = state.auds.find(a => a.id === ov.audId);
              s.audName = a ? a.name : s.audName;
            }
            // Override film
            if (ov.filmId && ov.filmId !== s.filmId) {
              const film = ShowtimeState.filmById(ov.filmId);
              if (film) {
                s.filmId = film.id;
                s.filmTitle = film.title + (film.format ? ' ' + film.format : '');
                s.runtime = film.runtime;
                s.trailer = film.trailer;
                s.clean = film.clean;
                s.cycle = ShowtimeState.cycleMinutes(film);
                // adjust end if start override also exists
                const start = s.start || rec.start;
                const totalMins = (film.runtime || 0) + (film.trailer || 0) + (film.clean || 0);
                s.end = new Date(start.getTime() + totalMins * 60000);
              }
            }
          }
          results.push(s);
        });
        results.sort((a, b) => a.start - b.start);
        return results;
      }
      // Compute pre times directly from the prime time and cycle. Always
      // allocate eight cells so the prime column aligns correctly even
      // when no prime time is selected. Pre times are right‑aligned: the
      // most recent times occupy the rightmost cells; remaining cells are
      // left blank (null).
      const preTimes = new Array(8).fill(null);
      if (row.filmId && row.audId && row.primeHM) {
        const film = ShowtimeState.filmById(row.filmId);
        const cycle = ShowtimeState.cycleMinutes(film);
        if (cycle > 0) {
          const primeStart = ShowtimeState.dtFromHM(row.primeHM);
          const firstWindow = ShowtimeState.dtFromHM(ShowtimeState.state.firstShowHM);
          const lastWindow = ShowtimeState.dtFromHM(ShowtimeState.state.lastShowHM);
          // extend lastWindow into next day for times after midnight
          if (lastWindow.getHours() < 5) lastWindow.setDate(lastWindow.getDate() + 1);
          // Collect pre times by stepping backwards
          const times = [];
          let t = new Date(primeStart.getTime() - cycle * 60000);
          let steps = 0;
          while (t >= firstWindow && steps < 50) {
            times.push(new Date(t));
            t = new Date(t.getTime() - cycle * 60000);
            steps++;
          }
          // Sort ascending and deduplicate string labels
          const uniq = [];
          times.sort((a,b) => a - b).forEach(date => {
            const label = ShowtimeState.to12(date);
            if (!uniq.includes(label)) uniq.push(label);
          });
          const selected = uniq.slice(-8);
          // Place selected times into the rightmost cells; preceding cells remain null
          const startIdx = 8 - selected.length;
          selected.forEach((timeLabel, idx) => {
            preTimes[startIdx + idx] = timeLabel;
          });
        }
      }
      // Prime select cell. Use a native <select>. Duplicate times are highlighted
      // by colouring the option text red and bold. Native <option> elements can
      // accept inline styles to change text colour on modern browsers.
      const tdPrime = document.createElement('td');
      tdPrime.className = 'px-3 py-2';
      const selPrime = document.createElement('select');
      // Narrow the prime time selector
      selPrime.className = 'appearance-none border border-gray-300 rounded px-2 py-1 w-20';
      // Blank option to allow clearing the prime time
      const blankPrime = document.createElement('option');
      blankPrime.value = '';
      blankPrime.textContent = '';
      selPrime.appendChild(blankPrime);
      const primeOpts = generatePrimeOptions();
      primeOpts.forEach(hm => {
        const opt = document.createElement('option');
        opt.value = hm;
        opt.textContent = ShowtimeState.fmtHM(hm);
        // If this time is already selected by another row (duplicate), colour it red
        // and make it bold to warn the user. We exclude the current row's own
        // selection unless more than one row uses it.
        if (primeCounts[hm] && (row.primeHM !== hm || primeCounts[hm] > 1)) {
          opt.style.color = '#dc2626'; // Tailwind red-600
          opt.style.fontWeight = 'bold';
        }
        selPrime.appendChild(opt);
      });
      selPrime.value = row.primeHM || '';
      selPrime.addEventListener('change', () => {
        ShowtimeState.setRowField(row.rowId, 'primeHM', selPrime.value || '');
        render();
      });
      // Compute post times similarly to pre times, but moving forward from the prime time
      const postTimes = new Array(8).fill(null);
      if (row.filmId && row.audId && row.primeHM) {
        const film = ShowtimeState.filmById(row.filmId);
        const cycle = ShowtimeState.cycleMinutes(film);
        if (cycle > 0) {
          const primeStart = ShowtimeState.dtFromHM(row.primeHM);
          const firstWindow = ShowtimeState.dtFromHM(ShowtimeState.state.firstShowHM);
          const lastWindow = ShowtimeState.dtFromHM(ShowtimeState.state.lastShowHM);
          if (lastWindow.getHours() < 5) lastWindow.setDate(lastWindow.getDate() + 1);
          const times = [];
          let t = new Date(primeStart.getTime() + cycle * 60000);
          let steps = 0;
          while (t <= lastWindow && steps < 50) {
            times.push(new Date(t));
            t = new Date(t.getTime() + cycle * 60000);
            steps++;
          }
          const uniq = [];
          times.sort((a,b) => a - b).forEach(date => {
            const label = ShowtimeState.to12(date);
            if (!uniq.includes(label)) uniq.push(label);
          });
          const selectedPost = uniq.slice(0, 8);
          // Place selected times into the leftmost cells; trailing cells remain null
          selectedPost.forEach((timeLabel, idx) => {
            postTimes[idx] = timeLabel;
          });
        }
      }
      // Append pre cells before the prime cell
      preTimes.forEach(label => {
        const td = document.createElement('td');
        // Use monospaced, tabular numbers and right alignment for pre times.  White-space
        // nowrap prevents line wrapping. We omit a fixed width so that the column can
        // expand naturally according to its content.
        td.className = 'px-2 py-2 font-mono tabular-nums text-right whitespace-nowrap';
        if (label) td.textContent = label;
        tr.appendChild(td);
      });
      // Append the prime cell now that pre cells are in place.  The select element
      // inherits the width from its container cell (8ch) and will scroll if the
      // options overflow.  We deliberately avoid setting a fixed width on the
      // <select> itself so that the native control can shrink on small screens.
      tdPrime.appendChild(selPrime);
      // Append the prime cell.  Without an explicit width the cell will
      // expand based on its content.  We still use monospaced font and
      // nowrap for consistency.
      tdPrime.className = 'px-2 py-2 font-mono tabular-nums text-center whitespace-nowrap';
      tr.appendChild(tdPrime);
      // Append post cells after the prime cell
      postTimes.forEach(label => {
        const td = document.createElement('td');
        // Left align post times so they read naturally from left to right.  Without
        // an explicit width the column can expand naturally.  White‑space nowrap
        // prevents wrapping.
        td.className = 'px-2 py-2 font-mono tabular-nums text-left whitespace-nowrap';
        if (label) td.textContent = label;
        tr.appendChild(td);
      });
      // Tag this row with the filmId for highlighting.  This allows
      // applyFilmHighlight() to highlight all rows matching the selected film.
      if (row && row.filmId) {
        tr.dataset.filmid = String(row.filmId);
      }
      body.appendChild(tr);
    });

    // After constructing the table, update the film highlight options in case
    // films have changed and apply the highlight.  These functions are
    // provided by app.js and will safely no-op if not defined.
    if (typeof window.refreshFilmHighlightOptions === 'function') {
      window.refreshFilmHighlightOptions();
    }
    if (typeof window.applyFilmHighlight === 'function') {
      window.applyFilmHighlight();
    }
  }

  window.addEventListener('storage', () => render());
  window.addEventListener('showtimeViewActivated', (evt) => {
    const detail = evt && evt.detail;
    const view = detail && detail.view ? detail.view : evt && evt.view;
    if (view === 'prime') {
      render();
    }
  });
  render();
}

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initPrimePage);
} else {
  initPrimePage();
}

})();


// schedule-grid.js
// Schedule grid page logic
// Access global ShowtimeState via window
(() => {
const ShowtimeState = window.ShowtimeState;

// Maintain the next grid cell to focus after a navigation-induced re-render.  When
// assignGridNavHandlers() detects a grid navigation key event (Arrow
// keys, Tab, Enter), it will set gridNavNextFocus to the row/column of
// the destination cell.  After renderAll() completes, we restore focus
// to the cell specified by this object.
let gridNavNextFocus = null;

function initScheduleGridPage() {
  // Initialise multi‑date support so that schedule data is stored per date.
  ShowtimeState.initDateSupport();

  // === Condensed row style when end times are hidden ===
  (function injectScheduleCondenseStyles(){
    // Inject a style element once that defines how the schedule grid should
    // shrink when end times are hidden. The old selectors targeted a
    // combination of Tailwind classes (e.g. w-full table-fixed) that no
    // longer exist on the schedule table, so the rules never applied. We
    // instead scope the rules to the schedule grid via the #gridHead and
    // #gridBody IDs. When the body has the sg-condensed class, the
    // top/bottom padding of header and body cells is reduced, and
    // invisible placeholders used to align end‑time labels are removed so
    // that rows compress vertically.
    if (document.getElementById('schedule-condense-style')) return;
    const style = document.createElement('style');
    style.id = 'schedule-condense-style';
    style.textContent = `
      /* Reduce padding on schedule grid cells when condensed */
      body.sg-condensed #gridHead th,
      body.sg-condensed #gridBody td {
        padding-top: 2px !important;
        padding-bottom: 2px !important;
      }
      /* Remove invisible placeholders used for end‑time alignment when condensed */
      body.sg-condensed #gridBody div.invisible {
        display: none !important;
      }
    `;
    document.head.appendChild(style);
  })();
  function setScheduleCondensed(on){
    document.body.classList.toggle('sg-condensed', !!on);
  }

  const firstSelect = document.getElementById('firstShowSelect');
  const lastSelect = document.getElementById('lastShowSelect');
  const addRowBtn = document.getElementById('addRowBtn');
  const toggleEndBtn = document.getElementById('toggleEndBtn');
  const undoBtn = document.getElementById('undoBtn');
  // Sort rows button (may not exist on all pages)
  const sortRowsBtn = document.getElementById('sortRowsBtn');
  const clearBtn = document.getElementById('clearTimesGridBtn');
  const head = document.getElementById('gridHead');
  const body = document.getElementById('gridBody');

  // Date input for switching schedules
  const dateInput = document.getElementById('scheduleDateGrid');

  // Track which show is currently active in the schedule grid. When a user
  // focuses on a show’s dropdown, we store its id here and highlight the
  // cell. Instead of forcing a full re‑render on every focus, we
  // imperatively add/remove highlight classes on the affected cells. This
  // prevents the dropdown list from closing immediately when the user
  // clicks to open it. We also keep a mapping from show ids to their DOM
  // element so cross‑component highlights can apply without a full re‑render.
  let activeShowId = null;
  // Reference to the currently highlighted cell div in the grid. When a
  // different show becomes active we remove highlight classes from the
  // previous element and apply them to the new one.
  let activeCellDiv = null;
  // Mapping from show id to its corresponding cell div. This is rebuilt
  // whenever the grid re-renders. It enables quickly finding a cell by
  // id when the start‑time order panel notifies us of a new active show.
  let showIdToCellDiv = {};

  // Flag indicating that keyboard navigation is currently in progress. When
  // true, commit handlers should update state but defer re-rendering. This
  // allows arrow navigation to move to the next cell and then trigger a
  // single re-render after focus moves, avoiding multiple re-renders that
  // would break the navigation sequence.
  let gridNavInProgress = false;

  // Ensure first and last show times have sensible defaults. If the
  // persisted state does not include firstShowHM or lastShowHM (e.g. after
  // clearing times), set them to 07:00 and 23:00 respectively. This
  // prevents the schedule grid from rendering blank until the user
  // interacts with the selectors. We update state and save so that
  // subsequent loads use these defaults.
  (() => {
    const st = ShowtimeState.state;
    if (!st.firstShowHM) {
      st.firstShowHM = '07:00';
    }
    if (!st.lastShowHM) {
      st.lastShowHM = '23:00';
    }
    ShowtimeState.save();
  })();

  // Populate first/last show selects. This function can be called
  // independently to refresh the available times and select the saved
  // values. It ensures that state values appear in the dropdowns even
  // if they are not in the default increments.
  function populateTimeSelectors() {
    // Generate first show options: 5:00a to 7:00p (19:00) in 30‑min increments
    function genTimes(startHm, endHm) {
      const times = [];
      let t = ShowtimeState.dtFromHM(startHm);
      const end = ShowtimeState.dtFromHM(endHm);
      while (t <= end) {
        times.push(ShowtimeState.hmFromDate(t));
        t = new Date(t.getTime() + 30 * 60000);
      }
      return times;
    }
    const firstTimes = genTimes('05:00', '19:00');
    const lastTimes = ['20:00','20:30','21:00','21:30','22:00','22:30','23:00','23:30','00:00','00:30','01:00','01:30','02:00'];
    // Clear existing
    firstSelect.innerHTML = '';
    lastSelect.innerHTML = '';
    // Populate options and ensure the current state values appear in the list.
    // If the stored first/last value isn't in the predefined list (e.g., user chose
    // a time that falls between increments), add it to the list so the select
    // correctly reflects the saved value.  Avoid duplicates.
    const currentFirst = ShowtimeState.state.firstShowHM;
    const currentLast = ShowtimeState.state.lastShowHM;
    if (currentFirst && !firstTimes.includes(currentFirst)) {
      firstTimes.push(currentFirst);
      firstTimes.sort();
    }
    if (currentLast && !lastTimes.includes(currentLast)) {
      lastTimes.push(currentLast);
      // Sort last times chronologically across midnight. We map to minutes since 0:00.
      lastTimes.sort((a, b) => {
        const toMins = hm => {
          const [hh, mm] = hm.split(':').map(x => parseInt(x, 10));
          // treat times <5:00 as +24h to keep them at end of list
          const minutes = hh * 60 + mm;
          return minutes < 300 ? minutes + 24 * 60 : minutes;
        };
        return toMins(a) - toMins(b);
      });
    }
    firstTimes.forEach(hm => {
      const opt = document.createElement('option');
      opt.value = hm;
      opt.textContent = ShowtimeState.fmtHM(hm);
      firstSelect.appendChild(opt);
    });
    lastTimes.forEach(hm => {
      const opt = document.createElement('option');
      opt.value = hm;
      opt.textContent = ShowtimeState.fmtHM(hm);
      lastSelect.appendChild(opt);
    });
    // Set selected values from state, defaulting to the earliest options if none or invalid.
    // If the current value is blank or not found in the options, choose the first option.
    if (currentFirst && firstTimes.includes(currentFirst)) {
      firstSelect.value = currentFirst;
    } else {
      firstSelect.value = firstTimes[0];
      // Update state so that other components use the default if none previously saved.
      ShowtimeState.state.firstShowHM = firstTimes[0];
      ShowtimeState.save();
    }
    if (currentLast && lastTimes.includes(currentLast)) {
      lastSelect.value = currentLast;
    } else {
      lastSelect.value = lastTimes[0];
      ShowtimeState.state.lastShowHM = lastTimes[0];
      ShowtimeState.save();
    }
  }

  // Parse user-entered time strings in various shorthand formats. Accept
  // inputs such as "7", "705", "7a", "705a", "9:28", "9:28am", "7p", etc.
  // Returns a 24-hour HH:MM string or null if invalid. If a suffix
  // (a/p/am/pm) is provided, the hours are converted to 24-hour
  // format accordingly. Without a suffix, hours are interpreted in
  // 24-hour form; minutes default to 00 if missing. Invalid inputs
  // return null.
  function parseTimeString(str) {
    if (!str) return null;
    let s = String(str).trim().toLowerCase();
    if (!s) return null;
    let am = null;
    // Detect and strip am/pm suffixes
    if (s.endsWith('am')) {
      am = true;
      s = s.slice(0, -2);
    } else if (s.endsWith('pm')) {
      am = false;
      s = s.slice(0, -2);
    } else if (s.endsWith('a')) {
      am = true;
      s = s.slice(0, -1);
    } else if (s.endsWith('p')) {
      am = false;
      s = s.slice(0, -1);
    }
    // Remove all non-digits from the remaining string
    s = s.replace(/[^0-9]/g, '');
    if (!s) return null;
    let hours, minutes;
    if (s.length <= 2) {
      hours = parseInt(s, 10);
      minutes = 0;
    } else if (s.length === 3) {
      hours = parseInt(s.slice(0, 1), 10);
      minutes = parseInt(s.slice(1), 10);
    } else {
      minutes = parseInt(s.slice(-2), 10);
      hours = parseInt(s.slice(0, -2), 10);
    }
    if (Number.isNaN(hours) || Number.isNaN(minutes) || minutes < 0 || minutes > 59) {
      return null;
    }
    // Apply am/pm logic if suffix present. Interpret 12am as 00 and 12pm as 12.
    if (am !== null) {
      let hr = hours % 12;
      if (!am) hr += 12;
      hours = hr;
    }
    // Without suffix, interpret as 24‑hour value. Reject out-of-range hours.
    if (hours < 0 || hours > 23) return null;
    const hh = String(hours).padStart(2, '0');
    const mm = String(minutes).padStart(2, '0');
    return `${hh}:${mm}`;
  }

  // === Schedule downtime highlighting ===
  // Helper functions and constants used to identify and display
  // idle gaps (≥45m) and opportunities to schedule another film
  // before the first show of the day.  After the grid renders,
  // highlightScheduleDowntime() is invoked to overlay colored
  // bars onto the schedule and append badges to the row labels.

  // Minutes threshold for flagging a downtime gap between shows.
  const GAP_THRESHOLD_MIN = 45;
  // A larger threshold used to distinguish huge gaps (rendered in red).
  const GAP_HUGE_MIN = 90;
  // Minutes representing a typical film slot for late-first show detection.
  const FIT_SLOT_MIN = 105;

  // Normalize a date so that times before 5AM are considered to belong
  // to the next day. This mirrors logic used elsewhere in the app for
  // schedule ordering.
  function normalizeDateForGap(dt) {
    const n = new Date(dt);
    if (n.getHours() < 5) {
      n.setDate(n.getDate() + 1);
    }
    return n;
  }

  function highlightScheduleDowntime() {
    // Clear any existing overlays or badges from a prior render.
    document.querySelectorAll('.dt-overlay').forEach(el => el.remove());
    document.querySelectorAll('.late-first-badge').forEach(el => el.remove());
    // Ensure that timetable cells are set to relative positioning so that
    // absolutely positioned overlays align relative to each cell.
    const allTds = document.querySelectorAll('#gridBody td');
    allTds.forEach(td => {
      const pos = window.getComputedStyle(td).position;
      if (pos === 'static' || pos === '') {
        td.style.position = 'relative';
      }
    });
    // Build an array of column boundaries identical to those used in
    // renderHeader(). Each interval spans 2.5 hours (150 minutes). We
    // normalize the start/end times to support gaps crossing midnight.
    const firstHM = ShowtimeState.state.firstShowHM;
    const lastHM = ShowtimeState.state.lastShowHM;
    const intervalMinutes = 150;
    const first = ShowtimeState.dtFromHM(firstHM);
    const last = ShowtimeState.dtFromHM(lastHM);
    if (last.getHours() < 5) {
      last.setDate(last.getDate() + 1);
    }
    const colBounds = [];
    for (let t = new Date(first); t <= last; ) {
      const startNorm = normalizeDateForGap(t);
      const endNorm = new Date(startNorm.getTime() + intervalMinutes * 60000);
      colBounds.push({ start: startNorm, end: endNorm });
      t = new Date(t.getTime() + intervalMinutes * 60000);
    }
    // Group shows by their rowId.  Each show record holds its start and end
    // times. If a show lacks an end time (e.g. a manual show without a film
    // assigned), attempt to compute one from its film; otherwise fallback to
    // zero duration so that gaps around it are measured conservatively.
    const allShows = ShowtimeState.getAllShows();
    const showsByRow = {};
    allShows.forEach(rec => {
      const rid = rec.rowId;
      if (!rid) return;
      if (!showsByRow[rid]) {
        showsByRow[rid] = [];
      }
      let endDate = rec.end;
      if (!endDate) {
        const film = ShowtimeState.filmById(rec.filmId);
        if (film) {
          const totalMins = film.runtime + (film.trailer || 0) + (film.clean || 0);
          endDate = new Date(rec.start.getTime() + totalMins * 60000);
        } else {
          endDate = new Date(rec.start);
        }
      }
      showsByRow[rid].push({ start: rec.start, end: endDate });
    });
    // Process each row to compute and draw gaps and late-first slots.
    Object.keys(showsByRow).forEach(rid => {
      const list = showsByRow[rid].slice();
      // Sort shows by normalized start time
      list.sort((a, b) => normalizeDateForGap(a.start) - normalizeDateForGap(b.start));
      if (list.length === 0) return;
      // Identify the table row element for this rowId
      const rowTr = document.querySelector(`#gridBody tr[data-rowid='${rid}']`);
      if (!rowTr) return;
      const rowTds = rowTr.querySelectorAll('td');
      // Collect the timeline cells (skip Aud/Film/RT columns)
      const timeCells = [];
      rowTds.forEach((td, idx) => {
        if (idx >= 3) {
          timeCells.push(td);
        }
      });
      // Determine if the first show starts late enough to fit another film
      const windowStart = normalizeDateForGap(ShowtimeState.dtFromHM(firstHM));
      const firstShowStart = normalizeDateForGap(list[0].start);
      const diffFirstMin = (firstShowStart - windowStart) / 60000;
      if (diffFirstMin >= FIT_SLOT_MIN) {
        // Overlay a blue bar from the operating window start to the first show start
        addGapOverlay(timeCells, colBounds, list[0].start, ShowtimeState.dtFromHM(firstHM), diffFirstMin, 'late');
        // Append a small badge to the auditorium cell to indicate a fit slot
        const audTd = rowTds[0];
        if (audTd) {
          const badge = document.createElement('span');
          badge.className = 'late-first-badge ml-1 px-1 rounded text-[10px] text-white';
          badge.style.backgroundColor = '#2563eb';
          badge.textContent = 'slot';
          audTd.appendChild(badge);
        }
      }
      // Check gaps between consecutive shows
      for (let i = 0; i < list.length - 1; i++) {
        const currEnd = normalizeDateForGap(list[i].end);
        const nextStart = normalizeDateForGap(list[i + 1].start);
        const gapMin = (nextStart - currEnd) / 60000;
        if (gapMin >= GAP_THRESHOLD_MIN) {
          addGapOverlay(timeCells, colBounds, list[i + 1].start, list[i].end, gapMin, 'gap');
        }
      }
    });
    // Helper to overlay a gap across the schedule. Accepts raw start and end dates
    // (in original day context), determines their normalized overlap with each
    // column interval, and draws absolutely positioned bars across the cells.
    function addGapOverlay(timeCells, colBounds, gapEnd, gapStart, gapMin, type) {
      const startNorm = normalizeDateForGap(gapStart);
      const endNorm = normalizeDateForGap(gapEnd);
      let colour;
      if (type === 'late') {
        colour = 'rgba(59,130,246,0.4)'; // blue for late slots
      } else if (gapMin >= GAP_HUGE_MIN) {
        colour = 'rgba(220,38,38,0.4)'; // red for huge gaps
      } else {
        colour = 'rgba(234,179,8,0.4)'; // amber for standard gaps
      }
      for (let ci = 0; ci < colBounds.length; ci++) {
        const cb = colBounds[ci];
        const interStartMs = Math.max(cb.start.getTime(), startNorm.getTime());
        const interEndMs = Math.min(cb.end.getTime(), endNorm.getTime());
        if (interEndMs > interStartMs) {
          const totalMs = cb.end.getTime() - cb.start.getTime();
          const ratioStart = (interStartMs - cb.start.getTime()) / totalMs;
          const ratioWidth = (interEndMs - interStartMs) / totalMs;
          const td = timeCells[ci];
          if (!td) continue;
          const overlay = document.createElement('div');
          overlay.className = 'dt-overlay';
          overlay.style.position = 'absolute';
          overlay.style.top = '0';
          overlay.style.bottom = '0';
          overlay.style.left = (ratioStart * 100) + '%';
          overlay.style.width = (ratioWidth * 100) + '%';
          overlay.style.backgroundColor = colour;
          overlay.style.zIndex = '0';
          overlay.style.pointerEvents = 'none';
          td.appendChild(overlay);
        }
      }
    }
  }

  /**
   * Check the current URL for a `jump` parameter and, if present,
   * scroll to and highlight the matching auditorium row.  This helper
   * is invoked after the schedule grid has rendered.  The `jump`
   * value should correspond exactly to the auditorium name shown in
   * the first column of the grid.  Matching is case-sensitive and
   * whitespace trimmed.  Rows are briefly highlighted by applying
   * the `jump-highlight` class and then removing it after a timeout.
   */
  function checkJumpParam() {
    try {
      const url = new URL(window.location.href);
      let jump = url.searchParams.get('jump');
      // Also support hash-based syntax: #jump=<value>
      if (!jump && url.hash && url.hash.startsWith('#jump=')) {
        jump = url.hash.substring(6);
      }
      if (!jump) return;
      jump = decodeURIComponent(jump);
      const rows = document.querySelectorAll('#gridBody tr');
      for (const row of rows) {
        const audCell = row.querySelector('td');
        if (!audCell) continue;
        const cellText = audCell.textContent || '';
        if (cellText.trim() === jump) {
          row.classList.add('jump-highlight');
          // Use smooth scrolling to bring the row into view
          row.scrollIntoView({ behavior: 'smooth', block: 'center' });
          // Remove the highlight after a brief period
          setTimeout(() => {
            row.classList.remove('jump-highlight');
          }, 1200);
          break;
        }
      }
    } catch (err) {
      // Silently ignore errors (e.g. invalid URL parsing)
    }
  }

  // Render the grid header based on current first/last show and 2.5‑hour intervals
  function renderHeader() {
    head.innerHTML = '';
    const tr = document.createElement('tr');
    // Static headers with consistent sizing
    // Define header widths.  Use narrower widths for the auditorium and runtime
    // columns to make the grid more compact.  The film column retains a
    // slightly wider width to accommodate longer titles.  Runtime is short
    // (e.g. 2:20) so we can safely use w-12 (3rem).  These widths tie
    // into theme.css where the max-width for each class is clamped.
    const headers = [
      { label: 'Aud', width: null },
      // Reduce film column from 8rem to 7rem to shrink overall table width
      { label: 'Film', width: 'w-28' },
      { label: 'RT', width: null }
    ];
    headers.forEach(({ label, width }, idx) => {
      const th = document.createElement('th');
      // Apply custom widths: for the Aud (idx 0) and RT (idx 2) columns, set a
      // fixed width of 5ch so they never grow beyond five characters.  If
      // width is specified (Film column), use the class from the config.
      if (idx === 0 || idx === 2) {
        // Double the schedule Aud/RT columns from 5ch to 10ch for improved
        // readability. This prevents the text from being cut off while
        // maintaining a compact grid.
        th.style.width = '10ch';
        th.style.maxWidth = '10ch';
      }
      th.className = `${width || ''} px-2 py-1 text-left`.trim();
      th.textContent = label;
      tr.appendChild(th);
    });
    // Compute interval starts. Each column spans 2.5 hours (150 minutes).
    // In addition to the user-configured first/last show window, include any
    // shows that start outside of that window so that they remain visible
    // in the schedule grid.  Determine the earliest and latest show start
    // times across all shows and expand the grid boundaries accordingly.
    // Start with the stored first/last values.
    const storedFirst = ShowtimeState.dtFromHM(ShowtimeState.state.firstShowHM);
    const storedLast = ShowtimeState.dtFromHM(ShowtimeState.state.lastShowHM);
    // Adjust last across midnight: treat times before 5:00a as belonging to the next day.
    if (storedLast.getHours() < 5) {
      storedLast.setDate(storedLast.getDate() + 1);
    }
    let gridStart = new Date(storedFirst);
    let gridEnd = new Date(storedLast);
    try {
      const allShows = ShowtimeState.getAllShows();
      if (Array.isArray(allShows) && allShows.length > 0) {
        // Normalise a date so that times before 5:00a roll into the next day.
        const normalize = (dt) => {
          const n = new Date(dt);
          if (n.getHours() < 5) {
            n.setDate(n.getDate() + 1);
          }
          return n;
        };
        let normalizedStart = normalize(gridStart);
        let normalizedEnd = normalize(gridEnd);
        allShows.forEach(rec => {
          const sNorm = normalize(rec.start);
          // Expand gridStart backward if a show starts earlier than the stored window.
          if (sNorm < normalizedStart) {
            gridStart = new Date(rec.start);
            normalizedStart = new Date(sNorm);
          }
          // Expand gridEnd forward if a show starts later than the stored window.
          if (sNorm > normalizedEnd) {
            gridEnd = new Date(rec.start);
            normalizedEnd = new Date(sNorm);
          }
        });
      }
    } catch (_) {
      // Ignore errors when computing dynamic grid boundaries
    }
    const intervalMinutes = 150;
    const cols = [];
    for (let t = new Date(gridStart); t <= gridEnd; ) {
      cols.push(new Date(t));
      t = new Date(t.getTime() + intervalMinutes * 60000);
    }
    // Time columns do not need labels; render blank headers. Use a
    // narrower width to prevent the grid from stretching excessively. A
    // Tailwind w-16 class sets width to 4rem (~64px) which accommodates an
    // HH:MMa/p label and our hidden caret. Adjust padding to keep spacing
    // consistent.
    cols.forEach(() => {
      const th = document.createElement('th');
      th.className = 'w-14 px-2 py-1 text-center whitespace-nowrap';
      th.textContent = '';
      tr.appendChild(th);
    });
    head.appendChild(tr);
    return cols;
  }

  // Helper: compute shows for a row. Uses base showtimes from
  // buildRowShowtimes plus manual shows and applies overrides. Hidden
  // shows are excluded. Result is sorted by start time.
  function getShowsForRow(row) {
    const state = ShowtimeState.state;
    // If this is a dynamic row (created by an auditorium override) then
    // collect the corresponding show(s) directly from getAllShows. Dynamic
    // rows are identified by rowIds starting with "OV-". They are not
    // present in primeRows or extraRows, so buildRowShowtimes would
    // return nothing. Instead, fetch all shows and filter by rowId.
    if (row && typeof row.rowId === 'string' && row.rowId.startsWith('OV-')) {
      const list = ShowtimeState.getAllShows().filter(r => r.rowId === row.rowId);
      // Filter hidden shows if necessary
      const filtered = list.filter(r => !state.hiddenShows || !state.hiddenShows[r.id]);
      // Already updated by getAllShows with overrides; just sort by start
      return filtered.sort((a, b) => a.start - b.start);
    }
    let shows = [];
    // Base showtimes from prime/extra rows
    try {
      shows = shows.concat(ShowtimeState.buildRowShowtimes(row));
    } catch (e) {
      // in case buildRowShowtimes fails, fallback to empty
    }
    // Manual shows for this row
    (state.manualShows || []).forEach(ms => {
      if (ms.rowId === row.rowId) shows.push({ ...ms });
    });
    // Apply overrides and filter hidden
    const result = [];
    shows.forEach(s => {
      // Skip hidden shows
      if (state.hiddenShows && state.hiddenShows[s.id]) return;
      const ov = state.overrides ? state.overrides[s.id] : undefined;
      // If this is a base (non-dynamic) row and this show has an override that
      // changes its auditorium or film, omit it from the base row. The
      // overridden show will be rendered in its own dynamic row.
      if (!(row && typeof row.rowId === 'string' && row.rowId.startsWith('OV-')) && ov && ((ov.audId && ov.audId !== s.audId) || (ov.filmId && ov.filmId !== s.filmId))) {
        return;
      }
      let rec = { ...s };
      if (ov) {
        // apply start override
        if (ov.start) {
          const newStart = new Date(ov.start);
          rec.start = newStart;
          // recompute end based on film runtime and trailer only (exclude clean)
          const film = ShowtimeState.filmById(ov.filmId || rec.filmId);
          if (film) {
            // compute end using runtime and trailer times only
            const totalMins = (film.runtime || 0) + (film.trailer || 0);
            rec.end = new Date(newStart.getTime() + totalMins * 60000);
            rec.runtime = film.runtime;
            rec.filmId = film.id;
            // Append the film format to the film title when building override records
            rec.filmTitle = film.title + (film.format ? ' ' + film.format : '');
          }
        }
        // apply auditorium override
        if (ov.audId) {
          rec.audId = ov.audId;
          const a = ShowtimeState.state.auds.find(a => a.id === ov.audId);
          rec.audName = a ? a.name : rec.audName;
        }
        // apply film override
        if (ov.filmId && ov.filmId !== rec.filmId) {
          const film = ShowtimeState.filmById(ov.filmId);
          if (film) {
            rec.filmId = film.id;
            rec.filmTitle = film.title + (film.format ? ' ' + film.format : '');
            rec.runtime = film.runtime;
            rec.trailer = film.trailer;
            rec.clean = film.clean;
            // adjust end using runtime and trailer (exclude clean) if start override also exists
            const startTime = rec.start || s.start;
            const totalMins2 = (film.runtime || 0) + (film.trailer || 0);
            rec.end = new Date(startTime.getTime() + totalMins2 * 60000);
          }
        }
      }
      result.push(rec);
    });
    // Deduplicate shows by start time, auditorium and film to prevent
    // conflicts.  In some scenarios (e.g. editing start times outside
    // the first/last window or overlapping shows) multiple records can
    // map to the same start time and film.  Use a composite key to
    // eliminate duplicates while preserving order.
    result.sort((a, b) => a.start - b.start);
    const unique = [];
    const seen = new Set();
    result.forEach(rec => {
      const key = `${rec.start.getTime()}_${rec.audId}_${rec.filmId}`;
      if (!seen.has(key)) {
        seen.add(key);
        unique.push(rec);
      }
    });
    return unique;
  }

  // Render the grid body rows
  function renderRows(cols) {
    body.innerHTML = '';
    const state = ShowtimeState.state;
    // Compose rows: primeRows + extraRows. Copy to avoid modifying state
    // Build list of rows including prime, extra and dynamic rows. Dynamic
    // rows represent individual shows that have been moved to a different
    // auditorium via override. They are identified by rowIds starting
    // with "OV-" on shows returned from getAllShows(). Dynamic rows
    // contain only a single show and do not have editable row-level
    // auditorium or film selectors.
    const baseRows = (state.primeRows || []).concat(state.extraRows || []);
    const dynamicRowsMap = {};
    ShowtimeState.getAllShows().forEach(rec => {
      if (rec.rowId && typeof rec.rowId === 'string' && rec.rowId.startsWith('OV-')) {
        if (!dynamicRowsMap[rec.rowId]) {
          dynamicRowsMap[rec.rowId] = {
            rowId: rec.rowId,
            audId: rec.audId,
            filmId: rec.filmId,
            dynamic: true,
            showIds: []
          };
        }
        dynamicRowsMap[rec.rowId].showIds.push(rec.id);
      }
    });
    // Convert dynamic rows map to an array and sort by auditorium id then film id.
    let dynamicRows = Object.values(dynamicRowsMap);
    dynamicRows.sort((a, b) => {
      const aId = a.audId || Number.MAX_SAFE_INTEGER;
      const bId = b.audId || Number.MAX_SAFE_INTEGER;
      if (aId === bId) {
        // Sort by filmId as secondary key for consistency
        return String(a.filmId).localeCompare(String(b.filmId));
      }
      return aId - bId;
    });
    // Combine base and dynamic rows. Sort entire list by auditorium id so that
    // dynamic rows and base rows intermingle by their destination auditorium.
    let rows = baseRows.concat(dynamicRows);
    rows.sort((a, b) => {
      const aId = a.audId || Number.MAX_SAFE_INTEGER;
      const bId = b.audId || Number.MAX_SAFE_INTEGER;
      if (aId === bId) {
        // Within same auditorium, leave base rows before dynamic rows and
        // maintain their original relative order by comparing rowId strings.
        const aDyn = !!a.dynamic;
        const bDyn = !!b.dynamic;
        if (aDyn !== bDyn) return aDyn ? 1 : -1;
        return String(a.rowId).localeCompare(String(b.rowId));
      }
      return aId - bId;
    });
    // Rebuild mapping and clear active cell reference before generating rows.
    showIdToCellDiv = {};
    activeCellDiv = null;
    // Compute list of films currently used in bookings to populate film selectors.
    // We only include films that are referenced in bookings and have a title to avoid
    // showing old or blank film entries. Deduplicate by film id and sort by title.
    const usedFilmIds = new Set();
    (state.bookings || []).forEach(b => {
      if (b.filmId) {
        usedFilmIds.add(b.filmId);
      }
    });
    const usedFilms = ShowtimeState.state.films
      .filter(f => usedFilmIds.has(f.id) && f.title)
      .sort((a, b) => {
        const ta = (a.title || '').toLowerCase();
        const tb = (b.title || '').toLowerCase();
        return ta.localeCompare(tb);
      });
    // Attach a row index to each rendered row so we can assign
    // data-row attributes for keyboard navigation. Provide rowIndex
    // parameter to the callback.
    // To visually group rows by auditorium, we assign alternating
    // background colours at the auditorium boundary rather than every
    // row.  When the auditorium id changes between consecutive rows,
    // toggle the shade so that all rows for the same auditorium share
    // the same background colour.  See user request to group multiple
    // movies in one auditorium with consistent shading.
    let lastAudForShade = null;
    let shadeToggle = false;
    rows.forEach((row, rowIndex) => {
      const tr = document.createElement('tr');
      // Attach the rowId as a data attribute so highlight functions can map row IDs to DOM rows
      if (row && row.rowId) {
        tr.dataset.rowid = String(row.rowId);
      }
      // Determine whether to toggle shading when auditorium changes.  Use
      // row.audId; for blank or undefined audId, treat as unique to avoid
      // grouping unrelated rows together.
      // Determine the auditorium identifier for row colouring.  When an
      // auditorium id is present, use it; otherwise carry forward the
      // previous group’s id so that blank or unspecified rows (e.g.,
      // placeholder blank row) inherit the same shading.  This prevents
      // toggling the shading on rows that do not correspond to a new
      // auditorium.  See user request for grouping auditoriums by colour.
      const currentAud = (row && row.audId ? String(row.audId) : lastAudForShade);
      if (currentAud !== lastAudForShade) {
        shadeToggle = !shadeToggle;
        lastAudForShade = currentAud;
      }
      const shadeClass = shadeToggle ? 'bg-gray-50' : 'bg-white';
      // Apply hover colour to all rows; preserve shading for active row highlight.
      tr.className = shadeClass + ' hover:bg-gray-50';
      // Tag this row with the filmId for highlighting if present.  Rows
      // representing dynamic or base schedule entries will be highlighted
      // when the selected film matches this id.
      if (row && row.filmId) {
        tr.dataset.filmid = String(row.filmId);
      }
      // If this is a dynamic row (created via auditorium override), render
      // editable selects just like a base row. Dynamic rows behave like
      // regular rows to allow editing auditorium, film and adding manual
      // shows. We parse the underlying showId from the rowId (OV-<id>)
      // so we can call updateShowAud and updateShowFilm on that show.
      if (row.dynamic) {
        // Underlying show ids for this dynamic row group. A dynamic row may
        // represent multiple shows that share the same destination auditorium
        // and film. Use row.showIds provided by dynamicRowsMap to update
        // all shows when editing row-level selects.
        const showIds = Array.isArray(row.showIds) ? row.showIds : [];
        // Auditorium select
        const tdAud = document.createElement('td');
        // Constrain auditorium column to 10 characters to prevent truncation
        tdAud.style.width = '10ch';
        tdAud.style.maxWidth = '10ch';
        // Mark this cell for keyboard navigation and identify its coordinates
        tdAud.dataset.row = rowIndex;
        tdAud.dataset.col = 0;
        // Remove the Tailwind vertical padding (py-1) from the auditorium cell so rows are tighter.
        tdAud.className = 'px-2 truncate navcell';
        const selAud = document.createElement('select');
        // Auditorium selector: rely on card-table styling for appearance.  The
        // enclosing cell has a fixed width so the select will fill the
        // available space without causing the column to grow.
        selAud.className = 'appearance-none text-xs w-full';
        const blankAud = document.createElement('option');
        blankAud.value = '';
        blankAud.textContent = '';
        selAud.appendChild(blankAud);
        ShowtimeState.state.auds.forEach(a => {
          const opt = document.createElement('option');
          opt.value = a.id;
          opt.textContent = a.name;
          selAud.appendChild(opt);
        });
        selAud.value = row.audId || '';
        selAud.addEventListener('change', () => {
          const val = selAud.value;
          showIds.forEach(id => {
            ShowtimeState.updateShowAud(id, val ? parseInt(val, 10) : null);
          });
          renderAll();
        });
        tdAud.appendChild(selAud);
        tr.appendChild(tdAud);
        // Film select
        const tdFilm = document.createElement('td');
        // Identify film cell for keyboard navigation
        tdFilm.dataset.row = rowIndex;
        tdFilm.dataset.col = 1;
        // Remove vertical padding from the film cell for a denser appearance.
        tdFilm.className = 'px-2 navcell';
        const selFilm = document.createElement('select');
        // Use a simple class; card-table styling will remove borders.  Use a
        // fixed width of 7rem via inline style for compactness.
        selFilm.className = 'appearance-none text-xs';
        selFilm.style.width = '7rem';
        const blankFilm = document.createElement('option');
        blankFilm.value = '';
        blankFilm.textContent = '';
        selFilm.appendChild(blankFilm);
        usedFilms.forEach(f => {
          const opt = document.createElement('option');
          opt.value = f.id;
          // Display the film format alongside the title if present
          opt.textContent = f.title + (f.format ? ' ' + f.format : '');
          selFilm.appendChild(opt);
        });
        selFilm.value = row.filmId || '';
        selFilm.addEventListener('change', () => {
          const val = selFilm.value;
          showIds.forEach(id => {
            ShowtimeState.updateShowFilm(id, val || null);
          });
          renderAll();
        });
        tdFilm.appendChild(selFilm);
        tr.appendChild(tdFilm);
        // Runtime cell
        const tdRt = document.createElement('td');
        // Constrain runtime column to 10 characters wide; this column is not interactive
        tdRt.style.width = '10ch';
        tdRt.style.maxWidth = '10ch';
        tdRt.className = 'px-2 py-1 truncate';
        const filmObj = ShowtimeState.filmById(row.filmId);
        tdRt.textContent = filmObj ? ShowtimeState.fmtDur(filmObj.runtime) : '0:00';
        tr.appendChild(tdRt);
      } else {
        // Auditorium select
        const tdAud = document.createElement('td');
        // Widen the auditorium column to 10 characters
        tdAud.style.width = '10ch';
        tdAud.style.maxWidth = '10ch';
        // Mark this cell for keyboard navigation and identify its coordinates
        tdAud.dataset.row = rowIndex;
        tdAud.dataset.col = 0;
        // Dynamic rows also need compact cells: omit vertical padding on the auditorium cell.
        tdAud.className = 'px-2 truncate navcell';
        const selAud = document.createElement('select');
        // Auditorium selector: rely on card-table styling for appearance
        selAud.className = 'appearance-none text-xs w-full';
        const blankAud = document.createElement('option');
        blankAud.value = '';
        blankAud.textContent = '';
        selAud.appendChild(blankAud);
        ShowtimeState.state.auds.forEach(a => {
          const opt = document.createElement('option');
          opt.value = a.id;
          opt.textContent = a.name;
          selAud.appendChild(opt);
        });
        selAud.value = row.audId || '';
        selAud.addEventListener('change', () => {
          const val = selAud.value;
          ShowtimeState.setRowField(row.rowId, 'audId', val ? parseInt(val, 10) : null);
          renderAll();
        });
        tdAud.appendChild(selAud);
        tr.appendChild(tdAud);
        // Film select
        const tdFilm = document.createElement('td');
        // Identify film cell for keyboard navigation
        tdFilm.dataset.row = rowIndex;
        tdFilm.dataset.col = 1;
        // Dynamic row film cell without vertical padding.
        tdFilm.className = 'px-2 navcell';
        const selFilm = document.createElement('select');
        // Film selector: rely on card-table styling; set a fixed width via inline style
        selFilm.className = 'appearance-none text-xs';
        selFilm.style.width = '7rem';
        const blankFilm = document.createElement('option');
        blankFilm.value = '';
        blankFilm.textContent = '';
        selFilm.appendChild(blankFilm);
        usedFilms.forEach(f => {
          const opt = document.createElement('option');
          opt.value = f.id;
          opt.textContent = f.title + (f.format ? ' ' + f.format : '');
          selFilm.appendChild(opt);
        });
        selFilm.value = row.filmId || '';
        selFilm.addEventListener('change', () => {
          ShowtimeState.setRowField(row.rowId, 'filmId', selFilm.value || null);
          renderAll();
        });
        tdFilm.appendChild(selFilm);
        tr.appendChild(tdFilm);
        // Runtime
        const tdRt = document.createElement('td');
        // Widen the runtime column to 10 characters
        tdRt.style.width = '10ch';
        tdRt.style.maxWidth = '10ch';
        tdRt.className = 'px-2 py-1 truncate';
        const film = ShowtimeState.filmById(row.filmId);
        tdRt.textContent = film ? ShowtimeState.fmtDur(film.runtime) : '0:00';
        tr.appendChild(tdRt);
      }
      // Gather shows for this row: base + manual + overrides
      const showsForRow = getShowsForRow(row);
      // Determine overlaps (showtimes that overlap with the previous cycle, including clean time).
      // We compute the cycle minutes for each show on the fly. If a show has no film or
      // a zero-duration cycle (runtime+trailer+clean <= 0), we skip overlap checks for it.
      const overlapIds = new Set();
      for (let i = 1; i < showsForRow.length; i++) {
        const prev = showsForRow[i - 1];
        const curr = showsForRow[i];
        // Determine cycle minutes for the previous show. Use the stored cycle
        // on the show if available; otherwise compute from its film. A zero or
        // undefined cycle indicates no meaningful runtime, so we ignore overlap.
        let cycleMins = prev.cycle;
        if (cycleMins === undefined || cycleMins === null) {
          const f = ShowtimeState.filmById(prev.filmId);
          cycleMins = f ? ShowtimeState.cycleMinutes(f) : 0;
        }
        if (cycleMins > 0) {
          const prevEndDate = new Date(prev.start.getTime() + cycleMins * 60000);
          if (curr.start < prevEndDate) {
            overlapIds.add(prev.id);
            overlapIds.add(curr.id);
          }
        }
      }
      // Build cells for each interval
      // Use the same interval length as renderHeader (2.5 hours = 150 minutes)
      const intervalMinutes = 150;
      cols.forEach((boundary, idx) => {
        const end = new Date(boundary.getTime() + intervalMinutes * 60000);
        // choose the earliest show in this interval
        const cellShow = showsForRow.find(s => s.start >= boundary && s.start < end);
        const td = document.createElement('td');
        // Assign navigation metadata: row index and column index (time columns start at 2)
        td.dataset.row = rowIndex;
        td.dataset.col = String(2 + idx);
        td.className = 'navcell';
        // We'll style individual cells via the inner div rather than tailwind classes
        if (cellShow) {
        // Show cell: render an input for editing the show start time.
          const div = document.createElement('div');
          // Remove the default border/background so it blends with the table grid.
          // The highlight styling will be applied conditionally when this show is active.
          let cellClass = '';
          // Apply highlight if this show is currently active
          if (cellShow.id === activeShowId) {
            cellClass = 'ring-2 ring-purple-400 border-2 border-purple-500 bg-purple-50';
            activeCellDiv = div;
          }
          div.className = cellClass;
          // Stack the start time and end time vertically.  Using a column
          // layout provides each element its own line, preventing the end
          // time from overlapping the start time.  The fixed width
          // maintains alignment with other columns.
          div.style.width = '3.5rem';
          div.style.display = 'flex';
          div.style.flexDirection = 'column';
          div.style.alignItems = 'flex-start';
          div.style.justifyContent = 'flex-start';
          // Remove padding so the height is governed by the children.
          div.style.padding = '0';
          // Reduce the gap between lines to zero; the CSS line-height will
          // control spacing between the input and end-time label.
          div.style.gap = '0';
          const inp = document.createElement('input');
          inp.type = 'text';
          // Use a medium font size so that times are more legible, matching
          // the Prime schedule.  Remove the tiny text-xs class and instead
          // apply text-sm (0.875rem) so the dense-schedule CSS can govern
          // overall row height.  Avoid setting inline height or padding here
          // so that table rows can shrink consistently.
          inp.className = 'text-sm w-full';
          // Override the inline font size to 0.875rem (14px) to ensure the
          // input text remains legible.  Previous versions used 0.65rem,
          // which was too small.  This matches the font size used in
          // Prime schedule tables.
          inp.style.fontSize = '0.875rem';
          // Center-align the start time text so that it matches the end time alignment.
          // Without this, inputs default to center alignment on some platforms,
          // which can cause the end time label (left-aligned) to look misaligned.
          inp.style.textAlign = 'center';
          // Do not set line-height, height or padding here; allow CSS to determine
          // the appropriate values for compact rows.
          // Pre-fill with the current start time in 12-hour format
          inp.value = ShowtimeState.to12(cellShow.start);
          // When focused, mark this show as active
          function activate() {
            if (!cellShow || !cellShow.id) return;
            const id = cellShow.id;
            // Remove highlight from previously active cell
            if (activeCellDiv && activeCellDiv !== div) {
              activeCellDiv.classList.remove('ring-2','ring-purple-400','border-2','border-purple-500','bg-purple-50');
            }
            // Apply highlight to current cell if not already
            if (div && div !== activeCellDiv) {
              div.classList.add('ring-2','ring-purple-400','border-2','border-purple-500','bg-purple-50');
            }
            activeCellDiv = div;
            activeShowId = id;
            // Notify other components of the active show change
            try {
              const evt = new CustomEvent('activeShowChange', { detail: { showId: id } });
              window.dispatchEvent(evt);
            } catch {}
          }
          inp.addEventListener('focus', activate);
          // Commit edits only on change. When editing an existing show time, parse
          // the value and update the show. If the field is cleared, delete the
          // show by hiding it. Avoid attaching a blur handler to prevent
          // duplicate commits (change already fires on blur when the value
          // has changed).
          function commit() {
            // Trim whitespace to detect empty input for deletion
            const val = inp.value ? inp.value.trim() : '';
            // If the input is cleared, hide the show (delete) via updateShowStart
            if (val === '') {
              ShowtimeState.updateShowStart(cellShow.id, '');
              if (!gridNavInProgress) {
                renderAll();
              }
              return;
            }
            const hm = parseTimeString(val);
            if (!hm) {
              // If invalid, revert to the existing start time
              inp.value = ShowtimeState.to12(cellShow.start);
              return;
            }
            // Only update if changed
            if (hm !== ShowtimeState.hmFromDate(cellShow.start)) {
              ShowtimeState.updateShowStart(cellShow.id, hm);
              if (!gridNavInProgress) {
                renderAll();
              }
            }
          }
          // Attach only the change event; blur triggers change automatically
          inp.addEventListener('change', commit);
          div.appendChild(inp);
          // Record mapping from show id to cell div for cross‑highlight
          showIdToCellDiv[cellShow.id] = div;
          // End time label or invisible placeholder.
          if (ShowtimeState.state.showEndTimes) {
            const lab = document.createElement('div');
            // Use a small font on a single line.  When overlaps occur, add a yellow
            // background to highlight conflict.
            let labClass = 'text-[10px] text-gray-500';
            if (overlapIds.has(cellShow.id)) {
              labClass += ' bg-yellow-100 rounded px-0.5';
            }
            lab.className = labClass;
            lab.textContent = ShowtimeState.to12(cellShow.end);
            // Center-align the end time label to match the start time input.
            lab.style.textAlign = 'center';
            // Expand the label to fill the full width of the cell so centering works
            lab.style.width = '100%';
            div.appendChild(lab);
          } else {
            const lab = document.createElement('div');
            // Invisible placeholder: keep as small as possible; no margin.
            lab.className = 'text-[10px] invisible';
            lab.textContent = 'x';
            // Ensure placeholder spans the width for proper alignment when end times are shown later
            lab.style.width = '100%';
            div.appendChild(lab);
          }
          td.appendChild(div);
        } else {
          // Empty cell: render a text input for manual show creation
          const div = document.createElement('div');
          // Stack the start time input and placeholder vertically.  A column
          // layout reserves a separate line for the end-time placeholder,
          // mirroring the layout of populated cells.
          div.className = '';
          div.style.width = '3.5rem';
          div.style.display = 'flex';
          div.style.flexDirection = 'column';
          div.style.alignItems = 'flex-start';
          div.style.justifyContent = 'flex-start';
          div.style.gap = '0';
          div.style.padding = '0';
          const inp = document.createElement('input');
          inp.type = 'text';
          inp.className = 'text-sm w-full';
          // Use a medium font size (0.875rem) instead of 0.65rem for better
          // readability.  This matches the Prime schedule table font size.
          inp.style.fontSize = '0.875rem';
          // Center-align the text in manual input for consistent alignment
          inp.style.textAlign = 'center';
          // Do not set inline line-height, height or padding for compact rows.
          inp.value = '';
          // Commit on change or blur. Parse the input; if valid, add a manual show.
          function commit() {
            const hm = parseTimeString(inp.value);
            if (hm) {
              ShowtimeState.addManualShow(row.rowId, hm);
              // Defer re-render if a keyboard navigation is in progress; nav handler will re-render.
              if (!gridNavInProgress) {
                renderAll();
              }
            } else {
              inp.value = '';
            }
          }
          // Attach only the change event. The change event fires when the input
          // loses focus and its value has been modified. Avoid adding a blur
          // handler here because blur would fire in addition to change and
          // cause the commit to run twice, which results in duplicate manual
          // shows being added. See issue reported by users where each manual
          // showtime was duplicated on the Gantt and Start Order views.
          inp.addEventListener('change', commit);
          div.appendChild(inp);
          // placeholder for end time (invisible). Keep it inline and small
          const lab = document.createElement('div');
          lab.className = 'text-[10px] invisible';
          lab.textContent = 'x';
          // Ensure placeholder spans the width for proper alignment when end times are shown later
          lab.style.width = '100%';
          div.appendChild(lab);
          td.appendChild(div);
        }
        tr.appendChild(td);
      });
      body.appendChild(tr);
    });
  }

  // Render both header and rows
  function renderAll() {
    // Ensure prime rows exist if none have been created yet.  If the
    // application has bookings but primeRows is empty (e.g. user never
    // visited the Prime page), derive primeRows from bookings with
    // assigned films. Use booking slot and assign empty audId/primeHM.
    (function ensurePrimeRows() {
      const state = ShowtimeState.state;
      if (!state.primeRows || state.primeRows.length === 0) {
        const rows = [];
        (state.bookings || []).forEach(b => {
          if (!b.filmId) return;
          rows.push({
            rowId: `PRB-${b.id}`,
            bookingId: b.id,
            slot: b.slot,
            filmId: b.filmId,
            audId: null,
            primeHM: ''
          });
        });
        if (rows.length > 0) {
          state.primeRows = rows;
          ShowtimeState.save();
        }
      }
    })();
    populateTimeSelectors();
    const cols = renderHeader();
    renderRows(cols);
    // Condense rows when end times are hidden
    setScheduleCondensed(!ShowtimeState.state.showEndTimes);
    // Update toggle button text
    toggleEndBtn.textContent = ShowtimeState.state.showEndTimes ? 'Hide End Times' : 'Show End Times';

    // Refresh the film highlight options (if new films were added) and
    // apply the highlight to rows after re-rendering.  The functions
    // live on window and will gracefully no-op if undefined.
    if (typeof window.refreshFilmHighlightOptions === 'function') {
      window.refreshFilmHighlightOptions();
    }
    if (typeof window.applyFilmHighlight === 'function') {
      window.applyFilmHighlight();
    }

    // Reattach keyboard navigation handlers after each render.  This will
    // collect all navigable cells (auditorium, film and time inputs) and
    // wire up Arrow/Tab/Enter key events to move focus across the grid.
    assignGridNavHandlers();

    // If a navigation handler recorded a cell to focus after re-render,
    // restore focus to that cell in the next microtask.  Without this
    // mechanism, the re-render would blow away the focused element and
    // keyboard navigation would stall.
    if (gridNavNextFocus) {
      const { row: fRow, col: fCol } = gridNavNextFocus;
      // Reset the pointer immediately so subsequent renders don't reuse it.
      gridNavNextFocus = null;
      setTimeout(() => {
        try {
          const cell = document.querySelector(`#gridBody td[data-row='${fRow}'][data-col='${fCol}']`);
          if (cell) {
            const ctrl = cell.querySelector('input, select');
            if (ctrl) {
              ctrl.focus();
              if (typeof ctrl.select === 'function') {
                ctrl.select();
              }
            }
          }
        } catch (err) {
          // Ignore focus errors
        }
      }, 0);
    }

    // After re-rendering and restoring focus, optionally decorate the schedule grid.
    // We intentionally skip downtime highlight overlays here to keep the
    // schedule view uncluttered.  Instead, flagged issues are shown on the
    // dashboard page.  If a "jump" parameter is present in the URL, scroll
    // to and briefly highlight the corresponding auditorium row.
    if (typeof checkJumpParam === 'function') {
      checkJumpParam();
    }

    // Note: we do not dispatch any synthetic storage events here. Instead,
    // app.js dispatches a custom "showtimeStateUpdated" event after
    // every state save, and order-panel.js listens for that event to
    // re-render when the schedule changes within the same tab. This
    // avoids unnecessary overhead while keeping the start-time order
    // panel in sync with edits made on the schedule grid.
  }

  // Event handlers
  firstSelect.addEventListener('change', () => {
    ShowtimeState.state.firstShowHM = firstSelect.value;
    ShowtimeState.save();
    renderAll();
  });
  lastSelect.addEventListener('change', () => {
    ShowtimeState.state.lastShowHM = lastSelect.value;
    ShowtimeState.save();
    renderAll();
  });
  addRowBtn.addEventListener('click', () => {
    ShowtimeState.addExtraRow();
    renderAll();
  });
  toggleEndBtn.addEventListener('click', () => {
    ShowtimeState.toggleEndTimes();
    renderAll();
  });
  undoBtn.addEventListener('click', () => {
    ShowtimeState.undo();
    renderAll();
  });

  // Sort prime and extra rows by auditorium id. Rows without an auditorium
  // assignment (null or empty) are placed at the end. Persist the new
  // order, save state and re-render. This allows quickly organizing
  // rows into numerical auditorium order, similar to the original app.
  if (sortRowsBtn) {
    sortRowsBtn.addEventListener('click', () => {
      const state = ShowtimeState.state;
      const sorter = (a, b) => {
        // undefined or null audIds go to the end
        const aId = a.audId || Number.MAX_SAFE_INTEGER;
        const bId = b.audId || Number.MAX_SAFE_INTEGER;
        // If equal audId, preserve original order by comparing rowId strings
        if (aId === bId) {
          return String(a.rowId).localeCompare(String(b.rowId));
        }
        return aId - bId;
      };
      if (Array.isArray(state.primeRows)) {
        state.primeRows.sort(sorter);
      }
      if (Array.isArray(state.extraRows)) {
        state.extraRows.sort(sorter);
      }
      ShowtimeState.save();
      renderAll();
    });
  }

  // Clear times button: resets all prime times, manual shows and overrides. Use the same behaviour
  // as the Clear Times button on the Prime page. Extra rows remain but prime times and show
  // overrides are cleared. After clearing, the grid re-renders and other pages are notified via
  // the storage event.
  if (clearBtn) {
    clearBtn.addEventListener('click', () => {
      // Reset all showtimes (prime, overrides, manual) via centralized helper
      ShowtimeState.clearAllTimes();
      // Re-render the grid to reflect the cleared schedule
      renderAll();
      // Dispatch storage event so prime and order views update
      try {
        const evt = new Event('storage');
        window.dispatchEvent(evt);
      } catch {}
    });
  }

  // Listen for external changes (e.g. other tabs)
  window.addEventListener('storage', () => renderAll());

  // Listen for cross‑component show highlight changes. When another
  // component (like the start‑time order panel) sets a show as active,
  // update our highlight without forcing a full re‑render. If we do
  // not know about the cell yet (for instance the grid hasn't been
  // rendered since the show was created), fall back to re‑rendering to
  // apply the highlight.
  window.addEventListener('activeShowChange', (e) => {
    const id = e && e.detail && e.detail.showId;
    if (!id) return;
    if (activeShowId === id) return;
    // Remove highlight from current cell
    if (activeCellDiv) {
      activeCellDiv.classList.remove('ring-2','ring-purple-400','border-2','border-purple-500','bg-purple-50');
      activeCellDiv = null;
    }
    activeShowId = id;
    // Highlight the new cell if we know it
    const div = showIdToCellDiv[id];
    if (div) {
      div.classList.add('ring-2','ring-purple-400','border-2','border-purple-500','bg-purple-50');
      activeCellDiv = div;
    } else {
      // otherwise trigger a full re‑render to rebuild the mapping
      renderAll();
    }
  });

  /**
   * Attach keyboard navigation to the schedule grid. This function
   * assigns a keydown handler to every select element within a cell
   * marked with the `navcell` class and data-row/data-col attributes.
   * ArrowLeft/ArrowRight and Tab/Shift+Tab move horizontally with
   * wrap-around across rows; ArrowUp/ArrowDown and Enter move vertically
   * with wrap-around. Before moving, the current select dispatches
   * change and blur events to commit any edits. Navigation skips
   * non-existent cells (e.g. runtime columns) and wraps when reaching
   * the edges of the grid.
   */
  function assignGridNavHandlers() {
    const navCells = document.querySelectorAll('#gridBody td.navcell');
    if (!navCells || navCells.length === 0) return;
    const rowsMap = {};
    let maxRow = -1;
    let maxCol = -1;
    // Build a map of row/col to the focusable control (input or select)
    navCells.forEach(td => {
      const r = parseInt(td.dataset.row, 10);
      const c = parseInt(td.dataset.col, 10);
      if (Number.isNaN(r) || Number.isNaN(c)) return;
      const ctrl = td.querySelector('input, select');
      if (!ctrl) return;
      if (!rowsMap[r]) rowsMap[r] = {};
      rowsMap[r][c] = ctrl;
      if (r > maxRow) maxRow = r;
      if (c > maxCol) maxCol = c;
    });
    if (maxRow < 0 || maxCol < 0) return;
    navCells.forEach(td => {
      const ctrl = td.querySelector('input, select');
      if (!ctrl) return;
      ctrl.onkeydown = function (e) {
        const key = e.key;
        const cell = this.closest('td');
        const row = cell ? parseInt(cell.dataset.row, 10) : NaN;
        const col = cell ? parseInt(cell.dataset.col, 10) : NaN;
        if (Number.isNaN(row) || Number.isNaN(col)) return;
        let newRow = row;
        let newCol = col;
        let handled = false;
        if (key === 'ArrowLeft' || (key === 'Tab' && e.shiftKey)) {
          newCol = col - 1;
          if (newCol < 0) {
            newCol = maxCol;
            newRow = row - 1;
            if (newRow < 0) newRow = maxRow;
          }
          handled = true;
        } else if (key === 'ArrowRight' || (key === 'Tab' && !e.shiftKey)) {
          newCol = col + 1;
          if (newCol > maxCol) {
            newCol = 0;
            newRow = row + 1;
            if (newRow > maxRow) newRow = 0;
          }
          handled = true;
        } else if (key === 'ArrowUp') {
          newRow = row - 1;
          if (newRow < 0) newRow = maxRow;
          handled = true;
        } else if (key === 'ArrowDown' || key === 'Enter') {
          newRow = row + 1;
          if (newRow > maxRow) newRow = 0;
          handled = true;
        }
        if (handled) {
          // Mark that grid navigation is in progress. Commit handlers should
          // update state without triggering render until we finish moving.
          gridNavInProgress = true;
          // Prevent the key event from inserting arrow characters into the input
          e.preventDefault();
          // Stop propagation to other listeners (including default caret movement)
          e.stopPropagation();
          // Also stop immediate propagation so no other handlers on this element run
          if (typeof e.stopImmediatePropagation === 'function') e.stopImmediatePropagation();
          try {
            // Dispatch change and blur events to commit edits on the current control
            this.dispatchEvent(new Event('change', { bubbles: true }));
            this.dispatchEvent(new Event('blur', { bubbles: true }));
          } catch {}
          let attempts = 0;
          const maxAttempts = (maxRow + 1) * (maxCol + 1);
          let target = null;
          let r = newRow;
          let c = newCol;
          while (attempts < maxAttempts) {
            if (rowsMap[r] && rowsMap[r][c]) {
              target = rowsMap[r][c];
              break;
            }
            c++;
            if (c > maxCol) {
              c = 0;
              r++;
              if (r > maxRow) r = 0;
            }
            attempts++;
          }
          if (target) {
            // Record the row/col of the destination cell so we can restore
            // focus after the grid is redrawn.  Use the r/c values from
            // our search loop, which correspond to the dataset of the target.
            gridNavNextFocus = { row: r, col: c };
            target.focus();
            if (typeof target.select === 'function') {
              try { target.select(); } catch {}
            }
          }
          // End navigation.  Re-render the grid to reflect committed edits.
          gridNavInProgress = false;
          renderAll();
        }
      };
    });
  }

  // Initial render
  // Populate selectors immediately so the grid can draw on first load.
  populateTimeSelectors();
  // Render once now and then again in a microtask. This two‑step render
  // ensures that if the state’s first/last show values were empty or
  // missing, the defaults inserted by populateTimeSelectors() are used
  // for the subsequent render. Without this, the grid may not draw
  // until the user interacts with the selectors.
  renderAll();
  // Use setTimeout with zero delay to queue a second render after the
  // select values and state updates have propagated. This helps avoid
  // a blank grid on initial load when firstShowHM/lastShowHM were unset.
  setTimeout(() => {
    renderAll();
  }, 0);

  // If a date input exists, set its initial value (MM/DD/YYYY) and wire up listeners.
  if (dateInput) {
    const cur = ShowtimeState.getCurrentDate();
    if (cur) dateInput.value = ShowtimeState.isoToMMDD(cur);
    dateInput.addEventListener('change', () => {
      const val = dateInput.value;
      if (!val) return;
      const iso = ShowtimeState.mmddToIso(val);
      if (!iso) {
        alert('Invalid date format. Please use MM/DD/YYYY.');
        return;
      }
      // Normalize display
      dateInput.value = ShowtimeState.isoToMMDD(iso);
      ShowtimeState.setDate(iso);
      // After switching date, re-render the grid
      renderAll();
    });
    // Respond to date changes triggered elsewhere
    window.addEventListener('showtimeDateChanged', () => {
      const current = ShowtimeState.getCurrentDate();
      if (current) {
        dateInput.value = ShowtimeState.isoToMMDD(current);
      }
      renderAll();
    });
  }

  // Wire up previous/next day buttons for the schedule grid.  These
  // buttons flank the date input in the header and allow the user to
  // navigate one day backward or forward at a time.  When clicked,
  // they update the current date via ShowtimeState, update the input
  // display and trigger a re‑render of the grid.
  const prevGridBtn = document.getElementById('prevDateGridBtn');
  const nextGridBtn = document.getElementById('nextDateGridBtn');
  function shiftDateGrid(delta) {
    const curIso = ShowtimeState.getCurrentDate();
    // If current date is not set, fall back to today
    let d = curIso ? new Date(curIso) : new Date();
    if (isNaN(d)) d = new Date();
    d.setDate(d.getDate() + delta);
    const iso = d.toISOString().slice(0, 10);
    ShowtimeState.setDate(iso);
    if (dateInput) dateInput.value = ShowtimeState.isoToMMDD(iso);
    renderAll();
  }
  if (prevGridBtn) prevGridBtn.addEventListener('click', () => shiftDateGrid(-1));
  if (nextGridBtn) nextGridBtn.addEventListener('click', () => shiftDateGrid(1));
  window.addEventListener('showtimeViewActivated', (evt) => {
    const detail = evt && evt.detail;
    const view = detail && detail.view ? detail.view : evt && evt.view;
    if (view === 'schedule') {
      renderAll();
    }
  });
}

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initScheduleGridPage);
} else {
  initScheduleGridPage();
}

})();


// order.js
// Start‑time order view with nudge controls
// Access the global ShowtimeState via window
(() => {
const ShowtimeState = window.ShowtimeState;

function initOrderView() {
  const tbody = document.getElementById('orderBody');

  function normalizeDate(dt) {
    const n = new Date(dt);
    // If time is between 00:00 and 04:59 on the same calendar date as first show,
    // treat it as the next day to order after evening shows.
    // For simplicity here, we roll any time before 5:00a to the next day.
    if (n.getHours() < 5) {
      n.setDate(n.getDate() + 1);
    }
    return n;
  }

  // Compute the time gap (in minutes) between this show and the next show in the same auditorium
  function cleanGap(current, shows) {
    // Find next show with same auditorium ID and start after current.start
    let next = null;
    const currNormStart = normalizeDate(current.start);
    shows.forEach(rec => {
      if (rec.audId === current.audId) {
        const recNormStart = normalizeDate(rec.start);
        if (recNormStart > currNormStart) {
          if (!next || recNormStart < normalizeDate(next.start)) {
            next = rec;
          }
        }
      }
    });
    if (!next) return '';
    // Compute minutes between next.start and current.end
    const mins = Math.floor((normalizeDate(next.start) - normalizeDate(current.end)) / 60000);
    return mins;
  }

  function formatCleanLabel(mins) {
    if (mins === '') return '';
    if (mins >= 60) {
      const h = Math.floor(mins / 60);
      const m = mins % 60;
      return `${h}h${String(m).padStart(2,'0')}m`;
    }
    return `${mins}m`;
  }

  function nudgeShow(rec, dir) {
    // rec: show record; dir: -1 for up (earlier), 1 for down (later)
    // Compute new start time by adding dir*5 minutes
    const newDate = new Date(rec.start.getTime() + dir * 5 * 60000);
    const newHm = ShowtimeState.hmFromDate(newDate);
    ShowtimeState.updateShowStart(rec.id, newHm);
    render();
  }

  function render() {
    // Ensure primeRows exist if the user hasn’t visited the Prime page yet.  If
    // there are bookings with films but no prime rows, derive them so that
    // getAllShows() returns something.
    (function ensurePrimeRows() {
      const state = ShowtimeState.state;
      if (!state.primeRows || state.primeRows.length === 0) {
        const rows = [];
        (state.bookings || []).forEach(b => {
          if (!b.filmId) return;
          rows.push({
            rowId: `PRB-${b.id}`,
            bookingId: b.id,
            slot: b.slot,
            filmId: b.filmId,
            audId: null,
            primeHM: ''
          });
        });
        if (rows.length > 0) {
          state.primeRows = rows;
          ShowtimeState.save();
        }
      }
    })();
    const allShows = ShowtimeState.getAllShows();
    // Sort shows by start time (with normalization for early AM)
    const shows = allShows.slice().sort((a, b) => {
      const an = normalizeDate(a.start);
      const bn = normalizeDate(b.start);
      return an - bn;
    });
    tbody.innerHTML = '';
    shows.forEach((rec, idx) => {
      const tr = document.createElement('tr');
      // Use zebra striping and hover highlights similar to the older design
      tr.className = 'border-b border-slate-100 last:border-0 transition-colors odd:bg-white even:bg-slate-50 hover:bg-sky-50';
      // Tag the row with filmId for highlighting.  When a film is selected
      // from the highlight dropdown, rows with matching filmId will
      // receive a pink highlight.  rec.filmId may be undefined for
      // manual shows; in that case the dataset is not set.
      if (rec.filmId) {
        tr.dataset.filmid = String(rec.filmId);
      }
      // Add a thin medium‑grey bottom border when the next show starts in a
      // different hour. Using a subtle grey colour (#9ca3af) instead of
      // solid black makes the hour groupings easier on the eye while
      // still delineating separate hours.  See issue # for details.
      if (idx < shows.length - 1) {
        const currHour = normalizeDate(rec.start).getHours();
        const nextHour = normalizeDate(shows[idx + 1].start).getHours();
        if (currHour !== nextHour) {
          tr.style.borderBottom = '1px solid #9ca3af';
        }
      }
      // Start time cell
      const tdStart = document.createElement('td');
      tdStart.className = 'px-2 py-1 font-mono tabular-nums';
      tdStart.textContent = ShowtimeState.to12(rec.start);
      tr.appendChild(tdStart);
      // Clean cell
      const gap = cleanGap(rec, shows);
      const tdClean = document.createElement('td');
      tdClean.className = 'px-2 py-1 font-mono tabular-nums';
      const label = formatCleanLabel(gap);
      if (label && gap < 20) {
        // Highlight short cleaning windows (<20m) with a yellow background to
        // draw attention. Use a light yellow to avoid overpowering other
        // colours.
        const span = document.createElement('span');
        span.className = 'bg-yellow-100 rounded px-1';
        span.textContent = label;
        tdClean.appendChild(span);
      } else {
        tdClean.textContent = label;
      }
      tr.appendChild(tdClean);
      // Auditorium cell
      const tdAud = document.createElement('td');
      tdAud.className = 'px-2 py-1';
      tdAud.textContent = rec.audName || '';
      tr.appendChild(tdAud);
      // Film cell
      const tdFilm = document.createElement('td');
      tdFilm.className = 'px-2 py-1';
      tdFilm.textContent = rec.filmTitle || '';
      tr.appendChild(tdFilm);
      // Nudge cell
      const tdNudge = document.createElement('td');
      tdNudge.className = 'px-2 py-1';
      // Up button
      const btnUp = document.createElement('button');
      // Use a smaller rounded radius to more closely match the older design
      btnUp.className = 'inline-flex items-center border rounded-md px-2 py-0.5 mr-1 bg-white hover:bg-gray-50 shadow-sm';
      btnUp.textContent = '▲';
      btnUp.addEventListener('click', (e) => {
        e.stopPropagation();
        nudgeShow(rec, -1);
      });
      // Down button
      const btnDown = document.createElement('button');
      btnDown.className = 'inline-flex items-center border rounded-md px-2 py-0.5 bg-white hover:bg-gray-50 shadow-sm';
      btnDown.textContent = '▼';
      btnDown.addEventListener('click', (e) => {
        e.stopPropagation();
        nudgeShow(rec, 1);
      });
      tdNudge.appendChild(btnUp);
      tdNudge.appendChild(btnDown);
      tr.appendChild(tdNudge);
      tbody.appendChild(tr);
    });

    // After populating the order table, apply film highlighting.  This
    // highlights rows whose filmId matches the selected film in the
    // header dropdown.  The helper is defined in app.js and
    // gracefully no-ops if not present.
    if (typeof window.applyFilmHighlight === 'function') {
      window.applyFilmHighlight();
    }
  }

  window.addEventListener('storage', () => render());
  window.addEventListener('showtimeViewActivated', (evt) => {
    const detail = evt && evt.detail;
    const view = detail && detail.view ? detail.view : evt && evt.view;
    if (view === 'order') {
      render();
    }
  });
  render();
}

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initOrderView);
} else {
  initOrderView();
}

})();


// gantt.js
// Gantt timeline view for the Showtime Builder application.
// This script renders a horizontal timeline of shows grouped by
// auditorium and supports dragging to adjust start times or move
// shows between auditoriums. It listens for global state changes
// and active show highlights to keep in sync with the schedule grid
// and order panel. The timeline spans from the configured first show
// time to the last show time and uses the same normalization rules
// (times before 5:00a belong to the next day).

(function(){
  const ShowtimeState = window.ShowtimeState;
  if (!ShowtimeState) return;
  // Normalize a date such that times before 5:00a are treated as
  // belonging to the next day. This matches the behaviour in the
  // order panel and schedule grid for comparing show times across
  // midnight. Returns a new Date instance.
  function normalizeDate(dt) {
    const d = new Date(dt);
    if (d.getHours() < 5) {
      d.setDate(d.getDate() + 1);
    }
    return d;
  }
  // State tracking for active show and dragging.  activeShowId
  // represents the show currently selected across components.  dragState
  // stores information about the show being dragged.
  let activeShowId = null;
  let dragState = null;
  // Mappings to quickly look up DOM elements and data by show id
  let showIdToBar = {};
  let showIdToRec = {};
  let rowEls = [];
  let rowIndexOfShow = {};

  // Current film being dragged from the tray. When a film chip is dragged, this
  // variable stores the filmId so that drop handlers can create a manual show.
  let currentDragFilmId = null;

  // Film selected for click‑to‑insert mode.  When the user clicks a film
  // chip rather than dragging it, this variable stores the filmId.  While
  // clickInsertFilmId is set, moving over the timeline will show a ghost
  // preview and clicking on a timeline row will insert a show at that
  // position.  Selecting a film again will cancel insert mode.  This mode
  // exists alongside HTML5 drag‑and‑drop to make adding shows easier on
  // touch devices or when dragging feels janky.
  let clickInsertFilmId = null;

  // Render the film selection tray. Films are pulled from the bookings list
  // and deduplicated by filmId. Blank rows or bookings without a valid film
  // title are ignored. Each film is presented as a draggable chip showing the
  // title and total cycle length (runtime + trailer + clean) in minutes. The
  // tray is rebuilt on every render so it reflects the latest booking data.
  function renderFilmTray() {
    const tray = document.getElementById('filmTray');
    if (!tray) return;
    // Clear existing chips
    tray.innerHTML = '';
    const state = ShowtimeState.state;
    const filmIds = new Set();
    // Gather unique filmIds from bookings that have a valid film attached
    (state.bookings || []).forEach(b => {
      if (b && b.filmId) filmIds.add(b.filmId);
    });
    // Build chips for each film. Sort alphabetically by title for consistency.
    const films = Array.from(filmIds).map(fid => ShowtimeState.filmById(fid)).filter(f => f && f.title);
    films.sort((a,b) => a.title.localeCompare(b.title));
    // Compute timeline duration for sizing film chips relative to the Gantt bars.
    // The timeline spans from 9:00 a.m. to midnight by default, but can extend
    // earlier or later based on the configured first and last show times. Use
    // the same computation as the main render() function to derive the
    // timeline length. This ensures that film chips are sized in proportion
    // to the visible timeline used by the Gantt bars.
    const cfgFirst = normalizeDate(ShowtimeState.dtFromHM(state.firstShowHM));
    const cfgLast = normalizeDate(ShowtimeState.dtFromHM(state.lastShowHM));
    const baselineStart = normalizeDate(ShowtimeState.dtFromHM('09:00'));
    const baselineEnd = normalizeDate(ShowtimeState.dtFromHM('00:00'));
    const lastDate = cfgLast > baselineEnd ? cfgLast : baselineEnd;
    const timelineStart = new Date(baselineStart);
    timelineStart.setSeconds(0);
    timelineStart.setMilliseconds(0);
    const timelineMins = Math.max(1, (lastDate - timelineStart) / 60000);

    films.forEach(f => {
      const chip = document.createElement('button');
      // Compute film length in minutes using runtime + trailer (excluding clean).
      const filmMinutes = (f.runtime || 0) + (f.trailer || 0);
      const widthPercent = (filmMinutes / timelineMins) * 100;
      // Apply pill styling: grey background, rounded full corners, consistent padding,
      // truncated title and fixed height.  Use flex properties so the chip
      // occupies a proportional width relative to the timeline.
      chip.className = 'flex-none border border-gray-300 bg-gray-100 text-gray-700 rounded-full px-2 py-1 text-xs cursor-grab hover:bg-gray-200 overflow-hidden whitespace-nowrap';
      // Set the flex basis based on the film duration. Ensure chips are not
      // extremely small or excessively wide by constraining the percentage.
      const minPct = 3; // minimum percent width
      const maxPct = 30; // maximum percent width
      const pct = Math.max(minPct, Math.min(maxPct, widthPercent));
      chip.style.flexBasis = pct.toFixed(2) + '%';
      chip.style.flexShrink = '0';
      chip.style.flexGrow = '0';
      // Truncate the film title to a maximum of 13 characters and append an ellipsis
      const title = f.title || '';
      const maxChars = 13;
      let shortTitle = title;
      if (title.length > maxChars) {
        shortTitle = title.slice(0, maxChars - 1) + '…';
      }
      chip.textContent = shortTitle;
      // Tooltip shows full film name, optional format and runtime+trailer duration
      const filmDurationMin = (f.runtime || 0) + (f.trailer || 0);
      chip.title = `${f.format ? f.format + ': ' : ''}${f.title} • ${ShowtimeState.fmtDur(filmDurationMin)}`;
      chip.draggable = true;
      // Highlight the chip if it is currently selected for click insertion
      if (clickInsertFilmId === f.id) {
        chip.classList.add('ring-2','ring-offset-1','ring-blue-400');
      }
      // Drag start: begin inserting new show; cancel click insert mode
      chip.addEventListener('dragstart', (e) => {
        currentDragFilmId = f.id;
        clickInsertFilmId = null;
        e.dataTransfer.effectAllowed = 'copy';
        e.dataTransfer.setData('text/plain', f.id);
      });
      // Drag end: clear current drag and re-render to update highlights
      chip.addEventListener('dragend', () => {
        currentDragFilmId = null;
        renderFilmTray();
      });
      // Click handler: toggle click‑to‑insert mode
      chip.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (clickInsertFilmId === f.id) {
          clickInsertFilmId = null;
        } else {
          clickInsertFilmId = f.id;
        }
        renderFilmTray();
      });
      tray.appendChild(chip);
    });
  }

  // Store last computed timeline start and duration so that drag
  // calculations are consistent with the render window.  When
  // dragging, we need to compute offsets relative to the same
  // baseline start used in render(), not necessarily the configured
  // first show time.  Without this, a mismatch between the
  // configured first show (e.g. 9:30a) and the baseline start (9:00a)
  // causes bars to drift relative to the hour markers.  These
  // variables are updated in render() and read in the drag handlers.
  let lastFirstDate = null;
  let lastTimelineMins = null;

  // Build and render the entire timeline.  Recreates rows and bars
  // from scratch based on the current state.  Called whenever state
  // changes or the active show changes.
  function render() {
    // Ensure state is loaded
    ShowtimeState.load();
    // Rebuild the film selection tray on every render so it reflects
    // current bookings. This must run before any early return from
    // render() to ensure the tray is cleared when there are no
    // bookings.
    try {
      renderFilmTray();
    } catch {}
    const state = ShowtimeState.state;
    // Compute start and end of the timeline window
    // Determine the baseline visible window.  We always want to show at
    // least 9:00am through 1:00am (the next day).  If the configured
    // first show time is earlier than 9:00am, we extend the start to
    // that earlier time.  If the configured last show time is later
    // than 1:00am, we extend the end to that later time.
    const cfgFirst = normalizeDate(ShowtimeState.dtFromHM(state.firstShowHM));
    const cfgLast = normalizeDate(ShowtimeState.dtFromHM(state.lastShowHM));
    // Baseline start at 9:00am today. When computing the visible window we
    // always include 9:00a through midnight at minimum.  If the first
    // configured show begins earlier than 9:00, the window will extend
    // earlier; likewise if the last configured show ends after midnight
    // the window extends later.  Midnight (00:00) is normalized to the
    // next day by normalizeDate() below so it always sorts after
    // evening shows.
    const baselineStart = normalizeDate(ShowtimeState.dtFromHM('09:00'));
    // Baseline end at 12:00am (midnight). This is normalized to the next
    // day so that the timeline spans at least until the end of the
    // current day.
    const baselineEnd = normalizeDate(ShowtimeState.dtFromHM('00:00'));
    // Choose the raw first date: the earlier of the configured first show and baseline start.
    const rawFirstDate = cfgFirst < baselineStart ? cfgFirst : baselineStart;
    // Choose the last date: the later of the configured last show and baseline end.
    const lastDate = cfgLast > baselineEnd ? cfgLast : baselineEnd;
    // Always align the timeline start to the baseline (9:00a) so that hour
    // markers land on the clock (e.g. 10:00, 10:30, 11:00). Shows before
    // the baseline will still render, but may extend off the left side of
    // the visible window.
    const timelineStart = new Date(baselineStart);
    timelineStart.setSeconds(0);
    timelineStart.setMilliseconds(0);
    // Duration in minutes of the full timeline (not floored) so that
    // fractional minutes are preserved. Ensure at least one minute to avoid divide-by-zero.
    const timelineMins = Math.max(1, (lastDate - timelineStart) / 60000);
    // The firstDate remains the earlier of the configured first show and baseline start.
    const firstDate = rawFirstDate;
    // Persist the computed baseline start and duration so drag handlers can
    // refer to them.  Without capturing these values, the drag
    // computations might use the configured first show time instead of
    // the baseline start, resulting in bars misaligned with the hour
    // markers during dragging or after release.
    lastFirstDate = timelineStart;
    lastTimelineMins = timelineMins;
    // Clear previous mappings
    showIdToBar = {};
    showIdToRec = {};
    rowEls = [];
    rowIndexOfShow = {};
    // Group shows by auditorium
    const shows = ShowtimeState.getAllShows();
    const auds = (state.auds || []).slice().sort((a,b) => a.id - b.id);
    const showsByAud = {};
    auds.forEach(a => { showsByAud[a.id] = []; });
    shows.forEach(rec => {
      // fallback for missing audId: group into first row
      const aid = rec.audId || (auds[0] && auds[0].id);
      if (!showsByAud[aid]) showsByAud[aid] = [];
      showsByAud[aid].push(rec);
    });
    // Sort shows within each auditorium by start time
    Object.values(showsByAud).forEach(list => {
      list.sort((a,b) => normalizeDate(a.start) - normalizeDate(b.start));
    });
    // Build the DOM
    const container = document.getElementById('ganttContainer');
    if (!container) return;
    container.innerHTML = '';
    // Header with 30‑minute and hour ticks.  We generate tick marks at
    // every half hour boundary aligned to the clock (e.g. 10:00, 10:30,
    // 11:00).  Hour ticks include labels; half‑hour ticks are drawn
    // without labels.  Lines before the visible window are skipped.
    //
    // The timeline rows include a fixed label column at the left (5rem wide).
    // Previously, the header’s tick marks were positioned relative to
    // the full container width, causing the vertical lines and labels to
    // misalign with the show bars (which live in the timeline cell after
    // the label).  To fix this, build the header as a flex container
    // with a spacer for the label column and a separate tick container
    // that fills the remaining width.  All tick positioning is relative
    // to this tick container so hour markers align perfectly with the
    // bars below.
    const header = document.createElement('div');
    // Apply grad-header class so the tick header uses the same gradient
    // colours as other table headers.  The grad-header class also
    // applies white text colour, so we omit any explicit text colour here.
    header.className = 'relative flex h-6 text-[0.625rem] select-none grad-header';
    header.style.minWidth = '100%';
    // Spacer cell to align with the 5rem label column on each row. We
    // replicate the sticky styling from row labels so that the header
    // remains aligned when horizontally scrolled. The spacer itself is
    // empty; its only purpose is to occupy the same width as the
    // auditorium name column below.
    const spacer = document.createElement('div');
    spacer.className = 'sticky left-0 z-10 bg-white border-r border-gray-200';
    spacer.style.width = '5rem';
    spacer.style.flexShrink = '0';
    header.appendChild(spacer);
    // Container for the timeline ticks. This flexes to fill the
    // remaining horizontal space. All tick lines and labels are
    // absolutely positioned relative to this element so that their
    // percentages map to the same width as the show bars.
    const tickContainer = document.createElement('div');
    tickContainer.className = 'relative flex-1';
    // Determine the first tick at or before the firstDate on a 30‑minute boundary
    const firstTick = new Date(timelineStart);
    firstTick.setSeconds(0); firstTick.setMilliseconds(0);
    const mins = firstTick.getMinutes();
    // Round down to nearest 30‑minute boundary
    firstTick.setMinutes(Math.floor(mins / 30) * 30);
    // Generate ticks every 30 minutes until the end of the timeline.  Skip
    // ticks that fall before the firstDate.  For each tick, draw a
    // vertical line.  For hour ticks (minute === 0), also draw a
    // label.
    for (let t = new Date(firstTick); t <= lastDate; t = new Date(t.getTime() + 30 * 60000)) {
      if (t < firstDate) continue;
      const minutesFromFirst = (t.getTime() - timelineStart.getTime()) / 60000;
      const leftPercent = (minutesFromFirst / timelineMins) * 100;
      // Vertical line for this tick
      const line = document.createElement('div');
      // Hour lines use a darker colour, half‑hour lines lighter
      const isHour = t.getMinutes() === 0;
      line.className = 'absolute top-0 bottom-0 border-l';
      line.classList.add(isHour ? 'border-gray-300' : 'border-gray-200');
      line.style.left = `${leftPercent}%`;
      line.style.width = '0';
      tickContainer.appendChild(line);
      // Label for hour ticks
      if (isHour) {
        const label = document.createElement('span');
        // Use white text for hour labels so they remain legible on the
        // gradient header background.  The grad-header class on the
        // parent header sets the text colour to white; specifying
        // text-white here ensures consistency even if CSS changes.
        label.className = 'absolute text-white';
        label.textContent = ShowtimeState.to12(t);
        label.style.left = `${leftPercent}%`;
        label.style.transform = 'translateX(-50%)';
        label.style.top = '0.125rem';
        tickContainer.appendChild(label);
      }
    }
    header.appendChild(tickContainer);
    container.appendChild(header);
    // Build each row for each auditorium
    auds.forEach((aud, rowIndex) => {
      // Row container
      const row = document.createElement('div');
      row.className = 'relative flex items-stretch border-b border-gray-200 text-xs';
      row.style.minHeight = '2rem';
      // Sticky label cell
      const label = document.createElement('div');
      label.className = 'sticky left-0 z-10 bg-white border-r border-gray-200 flex items-center px-2 whitespace-nowrap';
      label.style.width = '5rem';
      label.textContent = aud.name;
      row.appendChild(label);
      // Timeline cell (bars live here)
      const timeline = document.createElement('div');
      timeline.className = 'relative flex-1';
      timeline.style.minHeight = '2rem';
      // Store the auditorium id on the timeline element so drop handlers
      // can determine which auditorium the user is dropping onto.
      timeline.dataset.audId = String(aud.id);

      // Drag‑over handler: when a film chip is dragged over this row, we
      // compute the preview position and show a dashed ghost bar to
      // indicate where the new show will land. We allow dropping only
      // when a film is being dragged.
      let ghostDiv = null;
      function showGhost(pxLeft, pxWidth) {
        if (!ghostDiv) {
          ghostDiv = document.createElement('div');
          ghostDiv.className = 'absolute top-1/4 h-1/2 opacity-60 border-2 border-dashed border-gray-400 bg-gray-200';
          timeline.appendChild(ghostDiv);
        }
        ghostDiv.style.left = pxLeft + 'px';
        ghostDiv.style.width = Math.max(2, pxWidth) + 'px';
      }
      function clearGhost() {
        if (ghostDiv) {
          ghostDiv.remove();
          ghostDiv = null;
        }
      }
      timeline.addEventListener('dragover', (e) => {
        const filmId = currentDragFilmId || e.dataTransfer.getData('text/plain');
        if (!filmId) return;
        e.preventDefault();
        const rect = timeline.getBoundingClientRect();
        // Position relative to the timeline width
        let px = e.clientX - rect.left;
        if (px < 0) px = 0;
        if (px > rect.width) px = rect.width;
        const leftPct = px / rect.width;
        // Compute minutes relative to the rendered timeline. Use the same
        // timeline duration captured during render().  Snap to 5 minutes.
        const minutes = Math.round((leftPct * lastTimelineMins) / 5) * 5;
        const film = ShowtimeState.filmById(filmId);
        const cycleMins = ShowtimeState.cycleMinutes(film || { runtime: 0, trailer: 0, clean: 0 }) || 0;
        // Pixel width for preview based on cycle duration
        const pxWidth = rect.width * (cycleMins / lastTimelineMins);
        showGhost(px, pxWidth);
      });
      timeline.addEventListener('dragleave', (e) => {
        clearGhost();
      });
      timeline.addEventListener('drop', (e) => {
        // Prevent the event from bubbling so the global drop handler does not
        // also handle this drop. Without stopping propagation, the drop
        // event would bubble to document and insert a duplicate show.
        e.stopPropagation();
        const filmId = currentDragFilmId || e.dataTransfer.getData('text/plain');
        clearGhost();
        if (!filmId) return;
        e.preventDefault();
        const rect = timeline.getBoundingClientRect();
        let px = e.clientX - rect.left;
        if (px < 0) px = 0;
        if (px > rect.width) px = rect.width;
        const leftPct = px / rect.width;
        // Compute minutes from start of timeline. Snap to nearest 5 minutes.
        const minutes = Math.round((leftPct * lastTimelineMins) / 5) * 5;
        // Determine absolute start time from timeline baseline
        const dropDate = new Date(lastFirstDate.getTime() + minutes * 60000);
        const hm = ShowtimeState.hmFromDate(dropDate);
        const audId = parseInt(timeline.dataset.audId, 10);
        // Find an existing row matching this film and auditorium.  Convert
        // audId values to numbers and filmId values to strings for
        // comparison so that type differences (e.g. '1' vs 1) do not
        // prevent a match.  Search both prime and extra rows.
        const st = ShowtimeState.state;
        let row = null;
        const allRows = [].concat(st.primeRows || [], st.extraRows || []);
        for (const r of allRows) {
          const rAud = typeof r.audId === 'undefined' ? undefined : parseInt(r.audId, 10);
          const rFilm = r.filmId != null ? String(r.filmId) : null;
          if (rAud === audId && rFilm === String(filmId)) {
            row = r;
            break;
          }
        }
        // If no matching row exists, create a new extra row and assign
        // both the auditorium and film.  The row IDs are strings so
        // convert the auditorium id back to a string when setting the
        // field to match other rows.
        if (!row) {
          row = ShowtimeState.addExtraRow();
          ShowtimeState.setRowField(row.rowId, 'audId', audId);
          ShowtimeState.setRowField(row.rowId, 'filmId', String(filmId));
        }
        // Add a manual show at the computed time.
        ShowtimeState.addManualShow(row.rowId, hm);
        // Re-render timeline to include the new show
        render();
      });

      // Hover preview for click‑to‑insert mode.  When a film is selected via the
      // film tray (clickInsertFilmId not null) and the user moves the cursor
      // over a timeline row, show a dashed ghost bar indicating where the
      // show would be inserted.  Do not show a preview if a drag is in
      // progress (currentDragFilmId) to avoid conflicting visuals.
      timeline.addEventListener('mousemove', (e) => {
        if (!clickInsertFilmId || currentDragFilmId) return;
        const rect = timeline.getBoundingClientRect();
        let px = e.clientX - rect.left;
        if (px < 0) px = 0;
        if (px > rect.width) px = rect.width;
        // Use baseline timeline duration and start captured earlier
        const leftPct = px / rect.width;
        const minutes = Math.round((leftPct * lastTimelineMins) / 5) * 5;
        const film = ShowtimeState.filmById(clickInsertFilmId);
        const cycleMins = ShowtimeState.cycleMinutes(film || { runtime: 0, trailer: 0, clean: 0 }) || 0;
        const pxWidth = rect.width * (cycleMins / lastTimelineMins);
        showGhost(px, pxWidth);
      });
      // Clear the ghost when the cursor leaves the row during click insertion
      timeline.addEventListener('mouseleave', (e) => {
        clearGhost();
      });
      // Click to insert a show.  If a film is currently selected via the
      // tray (clickInsertFilmId), compute the time and add a manual show
      // at that time in the clicked auditorium row.  Afterwards, clear
      // clickInsertFilmId and ghost preview.  Ignore clicks while
      // dragging.
      timeline.addEventListener('click', (e) => {
        if (!clickInsertFilmId || currentDragFilmId) return;
        const rect = timeline.getBoundingClientRect();
        let px = e.clientX - rect.left;
        if (px < 0) px = 0;
        if (px > rect.width) px = rect.width;
        const leftPct = px / rect.width;
        const minutes = Math.round((leftPct * lastTimelineMins) / 5) * 5;
        const dropDate = new Date(lastFirstDate.getTime() + minutes * 60000);
        const hm = ShowtimeState.hmFromDate(dropDate);
        const audId = parseInt(timeline.dataset.audId, 10);
        // Find an existing row matching this film and auditorium
        const st = ShowtimeState.state;
        let rowMatch = null;
        const allRows = [].concat(st.primeRows || [], st.extraRows || []);
        for (const r of allRows) {
          const rAud = typeof r.audId === 'undefined' ? undefined : parseInt(r.audId, 10);
          const rFilm = r.filmId != null ? String(r.filmId) : null;
          if (rAud === audId && rFilm === String(clickInsertFilmId)) {
            rowMatch = r;
            break;
          }
        }
        if (!rowMatch) {
          rowMatch = ShowtimeState.addExtraRow();
          ShowtimeState.setRowField(rowMatch.rowId, 'audId', audId);
          ShowtimeState.setRowField(rowMatch.rowId, 'filmId', String(clickInsertFilmId));
        }
        ShowtimeState.addManualShow(rowMatch.rowId, hm);
        // Exit insert mode and clear preview
        clickInsertFilmId = null;
        clearGhost();
        // Refresh the film tray highlight and timeline
        render();
      });
      // Grid lines for this row: half‑hour and hour marks.  Use a
      // lighter colour for half‑hours and darker for hours.  Lines
      // before firstDate are skipped.
      const rowFirstTick = new Date(firstTick);
      // Iterate ticks across the timeline
      for (let tt = new Date(rowFirstTick); tt <= lastDate; tt = new Date(tt.getTime() + 30 * 60000)) {
        if (tt < firstDate) continue;
        const minutesFromFirst = (tt.getTime() - timelineStart.getTime()) / 60000;
        const leftPercent = (minutesFromFirst / timelineMins) * 100;
        const line = document.createElement('div');
        const isHour = tt.getMinutes() === 0;
        line.className = 'absolute top-0 bottom-0 border-l';
        line.classList.add(isHour ? 'border-gray-200' : 'border-gray-100');
        line.style.left = `${leftPercent}%`;
        line.style.width = '0';
        timeline.appendChild(line);
      }
      // Render each show in this auditorium
      (showsByAud[aud.id] || []).forEach(rec => {
        // Compute relative positions
        // Rather than using normalizeDate() directly for both start and end,
        // normalize the dates carefully to avoid adding an extra day to
        // end times that already fall on the next day.  The previous
        // implementation always added a day to times before 5:00 a.m.
        // regardless of their existing date, which caused movies that
        // ended after midnight to appear excessively long on the
        // timeline.  Here, we only bump times before 5 a.m. when they
        // occur on the same date as the start.  Otherwise, we preserve
        // the provided date.
        const rawStart = new Date(rec.start);
        const rawEnd = new Date(rec.end);
        // Normalize the start: if the show starts before 5 a.m., treat it
        // as belonging to the next day.  This matches the behavior in
        // normalizeDate() for early‑morning starts.
        let start = new Date(rawStart);
        if (start.getHours() < 5) {
          start.setDate(start.getDate() + 1);
        }
        // Normalize the end: only bump the date forward if it ends
        // before 5 a.m. *and* still shares the same date as the start.
        // Without this check, a show that already ends on the next
        // calendar day (e.g. 1:30 a.m. next day) would incorrectly be
        // moved two days forward.  See GH issue # and user report.
        let end = new Date(rawEnd);
        if (end.getHours() < 5 && end.getDate() === rawStart.getDate()) {
          end.setDate(end.getDate() + 1);
        }
        // Compute minutes from the timeline start rather than raw first
        // date to ensure bar alignment with tick marks.  Avoid flooring
        // these values so fractional minutes are preserved, which
        // prevents bars from snapping to 30‑minute boundaries and keeps
        // them aligned with the hour markers.  DurMin uses the exact
        // duration as a float.
        // Compute the bar position relative to the timeline.  Use
        // timelineStart and lastDate (the end of the visible window) so
        // shows that finish after the window are truncated rather than
        // spilling past the right edge.  Without clamping the end
        // time, shows that end after midnight (or after the configured
        // last show) would render too wide because their full duration
        // is divided by the window length.
        const startMin = (start - timelineStart) / 60000;
        // Clamp the end time to the last visible date so width is
        // truncated when shows extend past the end of the window.
        const clampedEnd = end > lastDate ? lastDate : end;
        const endMin = (clampedEnd - timelineStart) / 60000;
        // Ensure at least 1 minute width to make the bar visible
        const durMin = Math.max(1, endMin - startMin);
        let leftPercent = (startMin / timelineMins) * 100;
        let widthPercent = (durMin / timelineMins) * 100;
        // Create bar
        const bar = document.createElement('div');
        bar.className = 'absolute rounded-md text-white text-[0.65rem] flex items-center pl-1 pr-1 whitespace-nowrap overflow-hidden shadow';
        bar.style.left = `${leftPercent}%`;
        bar.style.width = `${widthPercent}%`;
        bar.style.top = '0.25rem';
        bar.style.bottom = '0.25rem';
        // Default gradient
        // Apply the gradient bar class defined in theme.css instead of hardcoding
        // Tailwind colours. The grad-bar class uses CSS variables set via the
        // theme picker so bars automatically change colours when the swatch
        // selection changes. See theme.css for details.
        bar.classList.add('grad-bar');
        // Tag bar with filmId for highlighting.  When a film is selected
        // from the highlight dropdown, bars whose data-filmid matches
        // the selection will receive a pink highlight via CSS.
        if (rec.filmId) {
          bar.dataset.filmid = String(rec.filmId);
        }
        bar.dataset.id = rec.id;
        bar.dataset.audid = rec.audId;
        bar.style.cursor = 'pointer';
        // Content: start time and film title
        const startSpan = document.createElement('span');
        startSpan.className = 'font-mono tabular-nums';
        startSpan.textContent = ShowtimeState.to12(rec.start);
        const filmSpan = document.createElement('span');
        filmSpan.className = 'ml-1 truncate';
        filmSpan.textContent = rec.filmTitle || '';
        bar.appendChild(startSpan);
        bar.appendChild(filmSpan);
        // Highlight active show: remove the gradient bar and apply a subtle purple
        // highlight so the selected show stands out.  The grad-bar class is
        // removed here and restored when the bar is deselected.
        if (rec.id === activeShowId) {
          bar.classList.remove('grad-bar');
          bar.classList.add('ring-2','ring-purple-400','bg-purple-50','text-black');
        }

        // If a film is selected in the highlight dropdown, ensure the
        // corresponding bars remain highlighted even after selecting a show or
        // applying other classes.  Check the global state for the
        // highlightFilmId and add the film-highlight class when the current
        // record matches.  Also set the text colour to black for
        // readability.
        try {
          const highlightId = ShowtimeState.state && ShowtimeState.state.highlightFilmId;
          if (highlightId && rec.filmId && String(rec.filmId) === String(highlightId)) {
            bar.classList.add('film-highlight');
            bar.classList.add('text-black');
          }
        } catch (_) {
          /* ignore */
        }
        // Event handlers
        bar.addEventListener('pointerdown', onPointerDown);
        bar.addEventListener('click', onBarClick);
        timeline.appendChild(bar);
        // Map show id to bar and rec for lookup
        showIdToBar[rec.id] = bar;
        showIdToRec[rec.id] = rec;
        rowIndexOfShow[rec.id] = rowIndex;
      });
      row.appendChild(timeline);
      rowEls[rowIndex] = row;
      container.appendChild(row);
    });
  }

  // Apply film highlight after rendering the timeline.  This will add
  // a pink highlight to any bars whose data‑filmid matches the
  // current selection in the highlight dropdown.  The
  // applyFilmHighlight() function is defined globally in app.js.  Wrap
  // in a try/catch to avoid errors if the function is not defined yet.
  try {
    if (typeof window.applyFilmHighlight === 'function') {
      window.applyFilmHighlight();
    }
  } catch (e) {}
  // Handle bar click to set active show
  function onBarClick(e) {
    // Prevent click during dragging: if dragState exists, ignore click
    if (dragState) return;
    const id = e.currentTarget.dataset.id;
    if (!id) return;
    activeShowId = id;
    // Dispatch global event so other components highlight this show
    try {
      const evt = new CustomEvent('activeShowChange', { detail: { showId: id } });
      window.dispatchEvent(evt);
    } catch {}
    // Re-render to apply highlight locally
    render();
  }
  // Initiate a drag on pointerdown
  function onPointerDown(e) {
    if (!e.isPrimary) return;
    // Only respond to left mouse button or primary touch
    e.preventDefault();
    const bar = e.currentTarget;
    const id = bar.dataset.id;
    const rec = showIdToRec[id];
    const rowIndex = rowIndexOfShow[id];
    const startX = e.clientX;
    const startY = e.clientY;
    const timelineWidth = bar.parentElement.getBoundingClientRect().width;
    const state = ShowtimeState.state;
    // Use the baseline first date and timeline mins computed in render().  This
    // ensures horizontal drag distance maps consistently to minutes regardless
    // of the configured first show time.  Fallback to configured times if
    // render() hasn’t run yet.
    const firstDate = lastFirstDate || normalizeDate(ShowtimeState.dtFromHM(state.firstShowHM));
    const timelineMins = lastTimelineMins || Math.max(1, Math.floor((normalizeDate(ShowtimeState.dtFromHM(state.lastShowHM)) - firstDate) / 60000));
    // Compute the original start offset relative to the baseline first date
    const originalStartMin = Math.floor((normalizeDate(rec.start) - firstDate) / 60000);
    const originalAudId = rec.audId;
    dragState = {
      id,
      rec,
      rowIndex,
      startX,
      startY,
      timelineWidth,
      firstDate,
      timelineMins,
      originalStartMin,
      originalAudId,
      bar,
      rowEls
    };

    // If a film was previously selected for click-to-insert mode, cancel that
    // selection when dragging an existing show. Without this, a stray click
    // event after the drag would trigger the click-to-insert handler and
    // insert an extra manual show. Clearing clickInsertFilmId here prevents
    // that unintended insertion. Re-render the film tray so that any
    // highlighted chip loses its selection ring.
    if (typeof clickInsertFilmId !== 'undefined' && clickInsertFilmId !== null) {
      clickInsertFilmId = null;
      try {
        renderFilmTray();
      } catch (err) {
        /* ignore */
      }
    }
    // Capture pointer events on this bar
    bar.setPointerCapture(e.pointerId);
    window.addEventListener('pointermove', onPointerMove);
    window.addEventListener('pointerup', onPointerUp);
  }
  // Drag preview handler: update bar position and colour during drag
  function onPointerMove(e) {
    if (!dragState) return;
    const dx = e.clientX - dragState.startX;
    const dy = e.clientY - dragState.startY;
    // Convert horizontal movement into minutes
    const deltaMin = (dx / dragState.timelineWidth) * dragState.timelineMins;
    let newStartMin = dragState.originalStartMin + deltaMin;
    // Snap to nearest 5 minute increment
    newStartMin = Math.round(newStartMin / 5) * 5;
    // Determine target row based on vertical movement
    const rowHeight = dragState.rowEls[0] ? dragState.rowEls[0].getBoundingClientRect().height : 32;
    let rowShift = Math.round(dy / rowHeight);
    let newRowIndex = dragState.rowIndex + rowShift;
    if (newRowIndex < 0) newRowIndex = 0;
    if (newRowIndex >= dragState.rowEls.length) newRowIndex = dragState.rowEls.length - 1;
    // Compute new auditorium id
    const state = ShowtimeState.state;
    const auds = (state.auds || []).slice().sort((a,b) => a.id - b.id);
    const newAudId = (auds[newRowIndex] && auds[newRowIndex].id) || dragState.originalAudId;
    // Compute preview position
    const leftPercent = (newStartMin / dragState.timelineMins) * 100;
    dragState.bar.style.left = `${leftPercent}%`;
    // Translate vertically to preview row change
    const translateY = (newRowIndex - dragState.rowIndex) * (rowHeight);
    dragState.bar.style.transform = `translate(0, ${translateY}px)`;
    // Detect overlap in preview
    const previewStartDate = new Date(dragState.firstDate.getTime() + newStartMin * 60000);
    const filmDuration = Math.max(1, Math.floor((normalizeDate(dragState.rec.end) - normalizeDate(dragState.rec.start)) / 60000));
    const previewEndDate = new Date(previewStartDate.getTime() + filmDuration * 60000);
    let conflict = false;
    // Check overlap with existing shows in target auditorium
    const allShows = ShowtimeState.getAllShows();
    allShows.forEach(other => {
      if (other.id === dragState.id) return;
      if (other.audId !== newAudId) return;
      const oStart = normalizeDate(other.start);
      const oEnd = normalizeDate(other.end);
      if (previewStartDate < oEnd && previewEndDate > oStart) {
        conflict = true;
      }
    });
    // Set preview colour
    if (conflict) {
      dragState.bar.classList.add('bg-red-500');
      dragState.bar.classList.remove('grad-bar','bg-purple-50','ring-2','ring-purple-400','text-black');
    } else {
      // Reset classes to default gradient when not active or conflicting
      dragState.bar.classList.remove('bg-red-500');
      // Only add gradient if this bar is not the active show; highlight will be applied in onPointerUp or on click
      dragState.bar.classList.add('grad-bar');
      dragState.bar.classList.remove('bg-purple-50','ring-2','ring-purple-400','text-black');
    }
  }
  // Finalize drag: commit changes and clean up
  function onPointerUp(e) {
    if (!dragState) return;
    const dx = e.clientX - dragState.startX;
    const dy = e.clientY - dragState.startY;
    const deltaMin = (dx / dragState.timelineWidth) * dragState.timelineMins;
    let newStartMin = dragState.originalStartMin + deltaMin;
    newStartMin = Math.round(newStartMin / 5) * 5;
    const rowHeight = dragState.rowEls[0] ? dragState.rowEls[0].getBoundingClientRect().height : 32;
    let rowShift = Math.round(dy / rowHeight);
    let newRowIndex = dragState.rowIndex + rowShift;
    if (newRowIndex < 0) newRowIndex = 0;
    if (newRowIndex >= dragState.rowEls.length) newRowIndex = dragState.rowEls.length - 1;
    const state = ShowtimeState.state;
    const auds = (state.auds || []).slice().sort((a,b) => a.id - b.id);
    const newAudId = (auds[newRowIndex] && auds[newRowIndex].id) || dragState.originalAudId;
    // Compute final start HM
    const finalStartDate = new Date(dragState.firstDate.getTime() + newStartMin * 60000);
    const newHM = ShowtimeState.hmFromDate(finalStartDate);
    // Commit auditorium change if changed
    if (newAudId !== dragState.originalAudId) {
      // Always override the show auditorium only. Do not alter the entire row.
      // If moving back to the original auditorium, clear the override by
      // passing null. Otherwise set the override to the new auditorium.
      if (newAudId === dragState.originalAudId) {
        ShowtimeState.updateShowAud(dragState.id, null);
      } else {
        ShowtimeState.updateShowAud(dragState.id, newAudId);
      }
    }
    // Commit start time change if changed
    const origHM = ShowtimeState.hmFromDate(new Date(dragState.firstDate.getTime() + dragState.originalStartMin * 60000));
    if (newHM !== origHM) {
      ShowtimeState.updateShowStart(dragState.id, newHM);
    }
    // Set this show as active and notify other components
    activeShowId = dragState.id;
    try {
      const evt = new CustomEvent('activeShowChange', { detail: { showId: dragState.id } });
      window.dispatchEvent(evt);
    } catch {}
    // Release pointer capture and remove listeners
    dragState.bar.releasePointerCapture(e.pointerId);
    window.removeEventListener('pointermove', onPointerMove);
    window.removeEventListener('pointerup', onPointerUp);
    dragState = null;
    // Re-render to reset transforms and apply highlight
    render();
  }
  // When the global state changes (other pages editing show times), re-render
  window.addEventListener('showtimeStateUpdated', () => {
    render();
  });
  // When another component selects a show, update active highlight
  window.addEventListener('activeShowChange', (e) => {
    const id = e && e.detail && e.detail.showId;
    if (!id) return;
    if (activeShowId !== id) {
      activeShowId = id;
      render();
    }
  });

  // Helper to determine if the currently focused element is an input or editable field.
  function isFormField(el) {
    return el && (/input|select|textarea/i.test(el.tagName) || el.isContentEditable);
  }
  // Global key handler for deletion, undo and cancelling selection. When a bar is
  // selected (activeShowId), pressing Delete or Backspace will remove
  // it by setting its start time to blank. Escape clears the selection.
  // Ctrl/Cmd+Z triggers the global undo.
  document.addEventListener('keydown', (e) => {
    // Ignore if focus is inside a form field (e.g. search bar)
    if (isFormField(document.activeElement)) return;
    // Delete/Backspace to remove a show
    if ((e.key === 'Delete' || e.key === 'Backspace') && activeShowId) {
      e.preventDefault();
      // Soft delete the show by clearing its start time
      ShowtimeState.updateShowStart(activeShowId, '');
      activeShowId = null;
      render();
    }
    // Undo with Ctrl/Cmd+Z
    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') {
      e.preventDefault();
      ShowtimeState.undo();
      render();
    }
    // Escape to clear selection
    if (e.key === 'Escape') {
      if (activeShowId) {
        activeShowId = null;
        render();
      }
    }
  });

  // Improve drag and drop experience for adding shows from the film tray. When
  // a film chip is being dragged, allow dropping anywhere on the page (not
  // just over a timeline row) without showing the red "no drop" cursor. This
  // global dragover handler prevents the default browser behaviour so the
  // cursor shows a copy icon instead of a prohibited sign. It only
  // activates when a film is currently being dragged.
  document.addEventListener('dragover', (e) => {
    if (currentDragFilmId) {
      e.preventDefault();
      // Show copy cursor so the user knows dropping will insert a show
      if (e.dataTransfer) {
        try {
          e.dataTransfer.dropEffect = 'copy';
        } catch {} // Some browsers may throw
      }
    }
  });

  // Global drop handler for film chips. If a user drops a film outside of
  // any specific timeline row, attempt to insert the show at the nearest
  // row based on the drop position. This makes the drop feel less fussy
  // because the user doesn’t have to precisely hit the row element. Drops
  // onto the film tray or navigation bar are ignored. After inserting the
  // show, clear the current drag state and re-render the timeline.
  document.addEventListener('drop', (e) => {
    // Determine the film being dragged from either the global state or
    // the drag data transfer (for fallback support). If no film is
    // present, exit early.
    const filmId = currentDragFilmId || (e.dataTransfer && e.dataTransfer.getData('text/plain'));
    if (!filmId) return;
    // Prevent the browser from navigating or doing other default drop
    // behaviour
    e.preventDefault();
    // Ignore drops onto the film tray or the nav bar – these should
    // simply cancel the drag without inserting a show
    const tray = document.getElementById('filmTray');
    const nav = document.querySelector('nav');
    if ((tray && tray.contains(e.target)) || (nav && nav.contains(e.target))) {
      currentDragFilmId = null;
      clickInsertFilmId = null;
      render();
      return;
    }
    // Compute which row was targeted by the drop. Use the Y coordinate
    // relative to the gantt container to find the nearest row. Subtract
    // the height of the header (the first child of ganttContainer) so
    // that rows align correctly. Fall back to first row if calculation
    // yields a negative index.
    const container = document.getElementById('ganttContainer');
    if (!container) {
      currentDragFilmId = null;
      clickInsertFilmId = null;
      render();
      return;
    }
    const contRect = container.getBoundingClientRect();
    // Determine header height from the first child element (the tick header)
    let headerHeight = 0;
    if (container.firstChild && container.firstChild.getBoundingClientRect) {
      const headerRect = container.firstChild.getBoundingClientRect();
      headerHeight = headerRect.height;
    }
    // Y offset within the rows (excluding header). If the drop is above
    // the first row, rowIndex will become negative and will be clamped to 0.
    const yOffset = e.clientY - contRect.top - headerHeight;
    // Height of a row (use first row’s height if available).
    const rowHeight = rowEls && rowEls.length > 0 && rowEls[0].getBoundingClientRect ? rowEls[0].getBoundingClientRect().height : 32;
    let rowIndex = Math.floor(yOffset / rowHeight);
    if (rowIndex < 0) rowIndex = 0;
    if (rowIndex >= rowEls.length) rowIndex = rowEls.length - 1;
    // Find the timeline cell in the selected row. It’s the last child of
    // the row because the first child is the sticky label.
    const rowEl = rowEls[rowIndex];
    if (!rowEl) {
      currentDragFilmId = null;
      clickInsertFilmId = null;
      render();
      return;
    }
    const timeline = rowEl.querySelector('[data-aud-id]');
    if (!timeline) {
      currentDragFilmId = null;
      clickInsertFilmId = null;
      render();
      return;
    }
    // Compute the drop’s position within the timeline horizontally. If
    // the user drops to the left or right of the timeline, clamp to
    // bounds.
    const rect = timeline.getBoundingClientRect();
    let px = e.clientX - rect.left;
    if (px < 0) px = 0;
    if (px > rect.width) px = rect.width;
    const leftPct = rect.width > 0 ? (px / rect.width) : 0;
    // Calculate minutes relative to the timeline baseline and snap to
    // 5-minute increments
    const minutes = Math.round((leftPct * lastTimelineMins) / 5) * 5;
    const dropDate = new Date(lastFirstDate.getTime() + minutes * 60000);
    const hm = ShowtimeState.hmFromDate(dropDate);
    const audId = parseInt(timeline.dataset.audId, 10);
    // Find or create a row matching this auditorium and film. Use string
    // comparisons for filmIds to handle numeric vs string mismatches.
    const st = ShowtimeState.state;
    let targetRow = null;
    const allRows = [].concat(st.primeRows || [], st.extraRows || []);
    for (const r of allRows) {
      const rAud = typeof r.audId === 'undefined' ? undefined : parseInt(r.audId, 10);
      const rFilm = r.filmId != null ? String(r.filmId) : null;
      if (rAud === audId && rFilm === String(filmId)) {
        targetRow = r;
        break;
      }
    }
    if (!targetRow) {
      targetRow = ShowtimeState.addExtraRow();
      ShowtimeState.setRowField(targetRow.rowId, 'audId', audId);
      ShowtimeState.setRowField(targetRow.rowId, 'filmId', String(filmId));
    }
    ShowtimeState.addManualShow(targetRow.rowId, hm);
    // Clear film selection and click insert modes
    currentDragFilmId = null;
    clickInsertFilmId = null;
    // Re-render to show the new show and update film tray
    render();
  });
  // Initial render once the DOM is ready
  function initGanttPage() {
    // Initialise multi‑date support. This will migrate existing schedules
    // and ensure the current date is set. It must be called before
    // rendering or modifying the schedule.
    ShowtimeState.initDateSupport();
    ShowtimeState.load();
    // References to first/last show selectors and date input/buttons
    const dateInput = document.getElementById('scheduleDateGantt');
    const firstSel = document.getElementById('firstShowGanttSelect');
    const lastSel = document.getElementById('lastShowGanttSelect');
    const prevBtn = document.getElementById('prevDateGanttBtn');
    const nextBtn = document.getElementById('nextDateGanttBtn');

    // Populate the time selectors with 30‑minute increments.  This mirrors
    // the prime and schedule list/grid pages.  Last show options span
    // 20:00 through 02:00 to accommodate late shows crossing midnight.
    function populateTimeSelectors() {
      if (!firstSel || !lastSel) return;
      const times = [];
      let t = ShowtimeState.dtFromHM('05:00');
      const end = ShowtimeState.dtFromHM('19:00');
      while (t <= end) {
        times.push(ShowtimeState.hmFromDate(t));
        t = new Date(t.getTime() + 30 * 60000);
      }
      const lastTimes = ['20:00','20:30','21:00','21:30','22:00','22:30','23:00','23:30','00:00','00:30','01:00','01:30','02:00'];
      firstSel.innerHTML = '';
      lastSel.innerHTML = '';
      times.forEach(hm => {
        const opt = document.createElement('option');
        opt.value = hm;
        opt.textContent = ShowtimeState.fmtHM(hm);
        firstSel.appendChild(opt);
      });
      lastTimes.forEach(hm => {
        const opt = document.createElement('option');
        opt.value = hm;
        opt.textContent = ShowtimeState.fmtHM(hm);
        lastSel.appendChild(opt);
      });
      if (ShowtimeState.state.firstShowHM) firstSel.value = ShowtimeState.state.firstShowHM;
      if (ShowtimeState.state.lastShowHM) lastSel.value = ShowtimeState.state.lastShowHM;
    }

    // Attach change handlers to first/last selectors
    if (firstSel && lastSel) {
      firstSel.addEventListener('change', () => {
        ShowtimeState.state.firstShowHM = firstSel.value;
        ShowtimeState.save();
        render();
      });
      lastSel.addEventListener('change', () => {
        ShowtimeState.state.lastShowHM = lastSel.value;
        ShowtimeState.save();
        render();
      });
    }

    // Shift the current date by delta days (-1 for previous, +1 for next)
    function shiftDate(delta) {
      const curIso = ShowtimeState.getCurrentDate();
      let d = curIso ? new Date(curIso) : new Date();
      if (isNaN(d)) d = new Date();
      d.setDate(d.getDate() + delta);
      const iso = d.toISOString().slice(0, 10);
      ShowtimeState.setDate(iso);
      if (dateInput) dateInput.value = ShowtimeState.isoToMMDD(iso);
      render();
    }
    if (prevBtn) prevBtn.addEventListener('click', () => shiftDate(-1));
    if (nextBtn) nextBtn.addEventListener('click', () => shiftDate(1));

    // Set up the date input if present.  Allow manual entry and
    // conversion between MM/DD/YYYY and ISO.  Re-render on changes.
    if (dateInput) {
      const cur = ShowtimeState.getCurrentDate();
      if (cur) dateInput.value = ShowtimeState.isoToMMDD(cur);
      dateInput.addEventListener('change', () => {
        const val = dateInput.value;
        if (!val) return;
        const iso = ShowtimeState.mmddToIso(val);
        if (!iso) {
          alert('Invalid date format. Please use MM/DD/YYYY.');
          return;
        }
        dateInput.value = ShowtimeState.isoToMMDD(iso);
        ShowtimeState.setDate(iso);
        render();
      });
      // Update date input and re-render when other components change the date
      window.addEventListener('showtimeDateChanged', () => {
        const c = ShowtimeState.getCurrentDate();
        if (c) dateInput.value = ShowtimeState.isoToMMDD(c);
        // Update time selectors in case they changed elsewhere
        populateTimeSelectors();
        render();
      });
    }

    // Populate selectors immediately on first load
    populateTimeSelectors();
    render();
    // After the initial render, apply any film highlight on the timeline.  The
    // applyFilmHighlight() function checks data-filmid attributes on
    // bars and adds the .film-highlight class when the selected film
    // matches.  This ensures the initial view respects the current
    // highlight selection.
    try {
      if (typeof window.applyFilmHighlight === 'function') {
        window.applyFilmHighlight();
      }
    } catch (e) {}
    // Listen for highlight changes so that the timeline updates when
    // the user selects a different film in the nav dropdown.  Without
    // this listener, the highlight would not update until the next
    // render (e.g. after a drag or configuration change).
    window.addEventListener('filmHighlightChange', () => {
      try {
        if (typeof window.applyFilmHighlight === 'function') {
          window.applyFilmHighlight();
        }
      } catch (e) {}
    });
    window.addEventListener('showtimeViewActivated', (evt) => {
      const detail = evt && evt.detail;
      const view = detail && detail.view ? detail.view : evt && evt.view;
      if (view === 'gantt') {
        setTimeout(() => render(), 0);
      }
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initGanttPage);
  } else {
    initGanttPage();
  }
})();


// dashboard-inline.js
(function() {
  const ShowtimeState = window.ShowtimeState;
  if (!ShowtimeState) return;

  function initDashboardPage() {
    if (!ShowtimeState) return;
    try {
      if (typeof ShowtimeState.initDateSupport === 'function') {
        ShowtimeState.initDateSupport();
      }
    } catch (_) {}

    const dateInput = document.getElementById('scheduleDateGlobal');
    if (dateInput) {
      dateInput.addEventListener('change', () => updateSummaries());
    }
    const firstSel = document.getElementById('firstShowGlobalSelect');
    if (firstSel) {
      firstSel.addEventListener('change', () => updateSummaries());
    }
    const lastSel = document.getElementById('lastShowGlobalSelect');
    if (lastSel) {
      lastSel.addEventListener('change', () => updateSummaries());
    }

    updateSummaries();

    window.addEventListener('showtimeViewActivated', evt => {
      const detail = evt && evt.detail;
      const view = detail && detail.view ? detail.view : evt && evt.view;
      if (view === 'dashboard') {
        updateSummaries();
      }
    });
  }

  function clear(node) {
    if (!node) return;
    while (node.firstChild) {
      node.removeChild(node.firstChild);
    }
  }

  function createCell(content, className) {
    const td = document.createElement('td');
    td.className = className || '';
    if (content instanceof Node) {
      td.appendChild(content);
    } else {
      td.textContent = content == null ? '' : String(content);
    }
    return td;
  }

  function createBar(value, max, suffix) {
    const wrapper = document.createElement('div');
    wrapper.className = 'summary-bar-wrapper';
    const valueRow = document.createElement('div');
    valueRow.className = 'summary-bar-value';
    valueRow.textContent = suffix ? `${value}${suffix}` : `${value}`;
    const track = document.createElement('div');
    track.className = 'summary-bar-track';
    const bar = document.createElement('div');
    bar.className = 'summary-bar';
    const pct = max > 0 ? Math.max(0, Math.min(100, (value / max) * 100)) : 0;
    bar.style.width = `${pct}%`;
    track.appendChild(bar);
    wrapper.appendChild(valueRow);
    wrapper.appendChild(track);
    return wrapper;
  }

  function updateSummaries() {
    const filmBody = document.getElementById('filmSummaryBody');
    const audBody = document.getElementById('audSummaryBody');
    const timeBody = document.getElementById('timeSummaryBody');
    const utilBody = document.getElementById('utilSummaryBody');
    const flaggedContainer = document.getElementById('flaggedList');

    clear(filmBody);
    clear(audBody);
    clear(timeBody);
    clear(utilBody);
    clear(flaggedContainer);

    const shows = (ShowtimeState && typeof ShowtimeState.getAllShows === 'function')
      ? ShowtimeState.getAllShows() || []
      : [];

    const filmCounts = new Map();
    const audCounts = new Map();
    const hourCounts = new Map();
    const seatCounts = new Map();
    const endHourCounts = new Map();

    shows.forEach(rec => {
      const filmName = rec.filmTitle || rec.filmId || 'Unknown';
      filmCounts.set(filmName, (filmCounts.get(filmName) || 0) + 1);
      const audName = rec.audName || 'Unassigned';
      audCounts.set(audName, (audCounts.get(audName) || 0) + 1);
      const start = rec.start instanceof Date ? rec.start : new Date(rec.start);
      const hr = start.getHours();
      hourCounts.set(hr, (hourCounts.get(hr) || 0) + 1);
      let seats = 0;
      try {
        if (ShowtimeState.audById && rec.audId != null) {
          const audObj = ShowtimeState.audById(rec.audId);
          if (audObj && audObj.seats != null) {
            seats = parseInt(audObj.seats, 10) || 0;
          }
        }
      } catch (_) {}
      seatCounts.set(hr, (seatCounts.get(hr) || 0) + seats);

      let endTime = rec.end;
      if (!(endTime instanceof Date)) {
        if (rec.end && typeof rec.end === 'string') {
          endTime = new Date(rec.end);
        } else {
          let film = null;
          try {
            if (ShowtimeState.filmById && rec.filmId) {
              film = ShowtimeState.filmById(rec.filmId);
            }
          } catch (_) {}
          if (film) {
            const runtime = (film.runtime || 0) + (film.trailer || 0);
            endTime = new Date(start.getTime() + runtime * 60000);
          } else {
            endTime = new Date(start);
          }
        }
      }
      const endHr = endTime instanceof Date ? endTime.getHours() : start.getHours();
      endHourCounts.set(endHr, (endHourCounts.get(endHr) || 0) + 1);
    });

    const filmItems = Array.from(filmCounts.entries()).sort((a, b) => b[1] - a[1]);
    const filmMax = filmItems.reduce((m, [, v]) => Math.max(m, v), 0);
    filmItems.forEach(([label, value]) => {
      const tr = document.createElement('tr');
      tr.appendChild(createCell(label, 'px-2 py-1 text-left'));
      tr.appendChild(createCell(createBar(value, filmMax), 'px-2 py-1 text-right'));
      if (filmBody) filmBody.appendChild(tr);
    });

    const audItems = Array.from(audCounts.entries()).sort((a, b) => b[1] - a[1]);
    const audMax = audItems.reduce((m, [, v]) => Math.max(m, v), 0);
    audItems.forEach(([label, value]) => {
      const tr = document.createElement('tr');
      tr.appendChild(createCell(label, 'px-2 py-1 text-left'));
      tr.appendChild(createCell(createBar(value, audMax), 'px-2 py-1 text-right'));
      if (audBody) audBody.appendChild(tr);
    });

    const timeItems = Array.from(hourCounts.keys())
      .sort((a, b) => a - b)
      .map(hr => ({
        hour: hr,
        starts: hourCounts.get(hr) || 0,
        seats: seatCounts.get(hr) || 0,
        ends: endHourCounts.get(hr) || 0,
      }));
    timeItems.forEach(item => {
      const tr = document.createElement('tr');
      tr.appendChild(createCell(formatHour(item.hour), 'px-2 py-1 text-left'));
      tr.appendChild(createCell(item.starts, 'px-2 py-1 text-right font-medium'));
      tr.appendChild(createCell(item.seats, 'px-2 py-1 text-right'));
      tr.appendChild(createCell(item.ends, 'px-2 py-1 text-right'));
      if (timeBody) timeBody.appendChild(tr);
    });

    const utilEntries = computeUtilisation(shows, audCounts);
    const utilMax = utilEntries.reduce((m, item) => Math.max(m, item.percent), 0);
    utilEntries.forEach(item => {
      const tr = document.createElement('tr');
      tr.appendChild(createCell(item.audName, 'px-2 py-1 text-left'));
      tr.appendChild(createCell(createBar(item.percent.toFixed(1), utilMax || 100, '%'), 'px-2 py-1 text-right'));
      if (utilBody) utilBody.appendChild(tr);
    });

    if (flaggedContainer) {
      const issues = computeFlaggedIssues();
      issues.forEach(issue => {
        const li = document.createElement('li');
        let colour = 'text-gray-700';
        if (issue.type === 'late') colour = 'text-blue-700';
        else if (issue.type === 'gap') colour = 'text-yellow-600';
        else if (issue.type === 'huge') colour = 'text-red-700';
        li.className = colour;
        li.textContent = issue.message;
        flaggedContainer.appendChild(li);
      });
      if (issues.length === 0) {
        const li = document.createElement('li');
        li.className = 'text-green-700';
        li.textContent = 'No downtime or late-first issues detected.';
        flaggedContainer.appendChild(li);
      }
    }
  }

  function computeUtilisation(shows, audCounts) {
    const results = [];
    if (!ShowtimeState) return results;
    const state = ShowtimeState.state || {};
    let firstHM = state.firstShowHM || '07:00';
    let lastHM = state.lastShowHM || '23:00';
    const dateIso = typeof ShowtimeState.getCurrentDate === 'function' ? ShowtimeState.getCurrentDate() : null;
    try {
      if (dateIso && state.scheduleByDate && state.scheduleByDate[dateIso]) {
        const entry = state.scheduleByDate[dateIso];
        if (entry.firstShowHM) firstHM = entry.firstShowHM;
        if (entry.lastShowHM) lastHM = entry.lastShowHM;
      }
    } catch (_) {}
    let firstDate = typeof ShowtimeState.dtFromHM === 'function' ? ShowtimeState.dtFromHM(firstHM) : new Date();
    let lastDate = typeof ShowtimeState.dtFromHM === 'function' ? ShowtimeState.dtFromHM(lastHM) : new Date();
    let available = (lastDate - firstDate) / 60000;
    if (!isFinite(available) || available <= 0) {
      available += 24 * 60;
    }
    const totals = new Map();
    shows.forEach(rec => {
      const audName = rec.audName || 'Unassigned';
      if (!audCounts.has(audName)) return;
      const start = rec.start instanceof Date ? rec.start : new Date(rec.start);
      const end = rec.end instanceof Date ? rec.end : new Date(rec.end || start);
      let duration = (end - start) / 60000;
      if (!isFinite(duration) || duration < 0) duration = 0;
      totals.set(audName, (totals.get(audName) || 0) + duration);
    });
    audCounts.forEach((_, audName) => {
      const mins = totals.get(audName) || 0;
      const percent = available > 0 ? Math.min(100, (mins / available) * 100) : 0;
      results.push({ audName, percent });
    });
    results.sort((a, b) => b.percent - a.percent);
    return results;
  }

  function normalizeDateForGap(dt) {
    const n = new Date(dt);
    if (n.getHours() < 5) {
      n.setDate(n.getDate() + 1);
    }
    return n;
  }

  function formatDuration(mins) {
    const h = Math.floor(mins / 60);
    const m = Math.round(mins % 60);
    return `${h}h${String(m).padStart(2, '0')}m`;
  }

  function computeFlaggedIssues() {
    const issues = [];
    if (!ShowtimeState || typeof ShowtimeState.getAllShows !== 'function') return issues;
    const shows = ShowtimeState.getAllShows() || [];
    const byAud = {};
    shows.forEach(rec => {
      const audId = rec.audId;
      if (!audId) return;
      if (!byAud[audId]) byAud[audId] = [];
      let endDate = rec.end;
      if (!(endDate instanceof Date)) {
        if (rec.end) {
          endDate = new Date(rec.end);
        } else {
          let film = null;
          try {
            if (rec.filmId && ShowtimeState.filmById) {
              film = ShowtimeState.filmById(rec.filmId);
            }
          } catch (_) {}
          if (film) {
            const total = (film.runtime || 0) + (film.trailer || 0) + (film.clean || 0);
            endDate = new Date((rec.start instanceof Date ? rec.start : new Date(rec.start)).getTime() + total * 60000);
          } else {
            endDate = new Date(rec.start instanceof Date ? rec.start : new Date(rec.start));
          }
        }
      }
      byAud[audId].push({
        start: rec.start instanceof Date ? rec.start : new Date(rec.start),
        end: endDate,
        audName: rec.audName || ''
      });
    });
    const state = ShowtimeState.state || {};
    const firstHM = state.firstShowHM || '07:00';
    const windowStartRaw = typeof ShowtimeState.dtFromHM === 'function' ? ShowtimeState.dtFromHM(firstHM) : new Date();
    Object.keys(byAud).forEach(audId => {
      const list = byAud[audId];
      list.sort((a, b) => normalizeDateForGap(a.start) - normalizeDateForGap(b.start));
      if (!list.length) return;
      const audName = list[0].audName || `Aud ${audId}`;
      const windowStart = normalizeDateForGap(windowStartRaw);
      const firstStart = normalizeDateForGap(list[0].start);
      const diffFirst = (firstStart - windowStart) / 60000;
      if (diffFirst >= 105) {
        const startDisp = ShowtimeState.to12 ? ShowtimeState.to12(windowStartRaw) : '';
        const endDisp = ShowtimeState.to12 ? ShowtimeState.to12(list[0].start) : '';
        const durationStr = formatDuration(diffFirst);
        issues.push({
          audName,
          type: 'late',
          message: `${audName}: slot before first show from ${startDisp} to ${endDisp} (${durationStr})`,
          minutes: diffFirst
        });
      }
      for (let i = 0; i < list.length - 1; i++) {
        const currEnd = normalizeDateForGap(list[i].end);
        const nextStart = normalizeDateForGap(list[i + 1].start);
        const gapMin = (nextStart - currEnd) / 60000;
        if (gapMin >= 45) {
          const startDisp = ShowtimeState.to12 ? ShowtimeState.to12(list[i].end) : '';
          const endDisp = ShowtimeState.to12 ? ShowtimeState.to12(list[i + 1].start) : '';
          const durationStr = formatDuration(gapMin);
          const type = gapMin >= 90 ? 'huge' : 'gap';
          issues.push({
            audName,
            type,
            message: `${audName}: gap from ${startDisp} to ${endDisp} (${durationStr})`,
            minutes: gapMin
          });
        }
      }
    });
    issues.sort((a, b) => b.minutes - a.minutes);
    return issues;
  }

  function formatHour(h) {
    const hour12 = ((h + 11) % 12) + 1;
    return hour12 + (h < 12 ? 'a' : 'p');
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initDashboardPage);
  } else {
    initDashboardPage();
  }
})();


// audit.js
// Audit tab script
// This script renders a static audit table grouping shows by film title. It
// lists every show in chronological order per film and computes the time
// gap between consecutive shows. The gap is shown in hours and minutes.
// If the gap between two shows is less than 30 minutes, the cell is
// highlighted for easy visualisation.

(() => {

function initAuditPage() {
  const ShowtimeState = window.ShowtimeState;
  if (!ShowtimeState) return;
  // Initialise multi‑date support on the audit tab
  ShowtimeState.initDateSupport();
  const bodyFilm = document.getElementById('auditByFilmBody');
  const bodyHouse = document.getElementById('housePlacementBody');
  const bodyAud = document.getElementById('showsPerAudBody');
  const bodyFeature = document.getElementById('showsPerFeatureBody');
  if (!bodyFilm || !bodyHouse || !bodyAud || !bodyFeature) return;
  // Load the latest state from storage; ignore errors
  try {
    ShowtimeState.load();
  } catch (e) {
    /* ignore */
  }
  // Date input for switching days
  const dateInput = document.getElementById('scheduleDateAudit');
  // First/last show selectors and previous/next date buttons
  const firstSel = document.getElementById('firstShowAuditSelect');
  const lastSel = document.getElementById('lastShowAuditSelect');
  const prevBtn = document.getElementById('prevDateAuditBtn');
  const nextBtn = document.getElementById('nextDateAuditBtn');

  // Populate the first/last show selectors.  This generates 30‑minute
  // increments from 05:00 to 19:00 for the first show and from
  // 20:00 through 02:00 for the last show.  Selected values are
  // persisted in ShowtimeState.state and applied to the dropdowns.
  function populateTimeSelectors() {
    if (!firstSel || !lastSel) return;
    const times = [];
    let t = ShowtimeState.dtFromHM('05:00');
    const end = ShowtimeState.dtFromHM('19:00');
    while (t <= end) {
      times.push(ShowtimeState.hmFromDate(t));
      t = new Date(t.getTime() + 30 * 60000);
    }
    const lastTimes = ['20:00','20:30','21:00','21:30','22:00','22:30','23:00','23:30','00:00','00:30','01:00','01:30','02:00'];
    firstSel.innerHTML = '';
    lastSel.innerHTML = '';
    times.forEach(hm => {
      const opt = document.createElement('option');
      opt.value = hm;
      opt.textContent = ShowtimeState.fmtHM(hm);
      firstSel.appendChild(opt);
    });
    lastTimes.forEach(hm => {
      const opt = document.createElement('option');
      opt.value = hm;
      opt.textContent = ShowtimeState.fmtHM(hm);
      lastSel.appendChild(opt);
    });
    if (ShowtimeState.state.firstShowHM) firstSel.value = ShowtimeState.state.firstShowHM;
    if (ShowtimeState.state.lastShowHM) lastSel.value = ShowtimeState.state.lastShowHM;
  }

  // Change handlers for first/last selectors: persist new values and re-render
  if (firstSel && lastSel) {
    firstSel.addEventListener('change', () => {
      ShowtimeState.state.firstShowHM = firstSel.value;
      ShowtimeState.save();
      render();
    });
    lastSel.addEventListener('change', () => {
      ShowtimeState.state.lastShowHM = lastSel.value;
      ShowtimeState.save();
      render();
    });
  }

  // Shift date by delta days when clicking prev/next buttons
  function shiftDate(delta) {
    const curIso = ShowtimeState.getCurrentDate();
    let d = curIso ? new Date(curIso) : new Date();
    if (isNaN(d)) d = new Date();
    d.setDate(d.getDate() + delta);
    const iso = d.toISOString().slice(0,10);
    ShowtimeState.setDate(iso);
    if (dateInput) dateInput.value = ShowtimeState.isoToMMDD(iso);
    render();
  }
  if (prevBtn) prevBtn.addEventListener('click', () => shiftDate(-1));
  if (nextBtn) nextBtn.addEventListener('click', () => shiftDate(1));

  // Helper to get base film title (ignoring format)
  function getBaseTitle(rec) {
    let baseTitle = rec.filmTitle || '';
    try {
      if (ShowtimeState.filmById && rec.filmId) {
        const filmRec = ShowtimeState.filmById(rec.filmId);
        if (filmRec && filmRec.title) baseTitle = filmRec.title;
      }
    } catch (_) {
      // fallback
    }
    return baseTitle;
  }

  function render() {
    // Clear existing bodies
    bodyFilm.innerHTML = '';
    bodyHouse.innerHTML = '';
    bodyAud.innerHTML = '';
    bodyFeature.innerHTML = '';
    const shows = ShowtimeState.getAllShows();
    if (!shows || !Array.isArray(shows)) return;
    // === Schedule by Film ===
    // Group shows by base film title
    const groups = {};
    for (const rec of shows) {
      const title = getBaseTitle(rec);
      if (!groups[title]) groups[title] = [];
      groups[title].push(rec);
    }
    const filmTitles = Object.keys(groups).sort((a, b) => a.localeCompare(b));
    // Iterate through each film title and build the rows for the "Schedule by Film" table.
    // We track the index of the current film group so we can apply a slightly
    // darker top border when the film changes.  This improves visual
    // separation between groups without altering the overall look and feel.
    for (let groupIndex = 0; groupIndex < filmTitles.length; groupIndex++) {
      const ft = filmTitles[groupIndex];
      const list = groups[ft];
      // Sort by start time
      list.sort((a, b) => a.start - b.start);

      // Insert a thin separator row before each film group except the first.  Using
      // a dedicated table row with a 1‑pixel height and a slightly darker
      // background colour provides a clear visual boundary between groups
      // without relying on table borders (which are collapsed by the
      // Tailwind divide utilities).  The separator uses a colspan to span
      // all columns of the table.  See test pages for more details.
      if (groupIndex > 0) {
        const sepTr = document.createElement('tr');
        const sepTd = document.createElement('td');
        sepTd.colSpan = 4;
        // Remove padding so the height reflects only the border thickness
        sepTd.className = 'p-0 bg-gray-300';
        // Explicit height; using 1px ensures the line appears slightly darker
        // than the default divide lines but does not consume significant space.
        sepTd.style.height = '1px';
        sepTr.appendChild(sepTd);
        bodyFilm.appendChild(sepTr);
      }
      for (let i = 0; i < list.length; i++) {
        const rec = list[i];
        const next = list[i + 1];
        let gapStr = '';
        let shortGap = false;
        if (next) {
          const diffMin = (next.start - rec.start) / 60000;
          const hours = Math.floor(diffMin / 60);
          const mins = Math.round(diffMin % 60);
          gapStr = `${hours}:${mins.toString().padStart(2, '0')}`;
          if (diffMin < 30) shortGap = true;
        }
        const tr = document.createElement('tr');
        // Alternate row background colours for odd/even rows
        tr.className = i % 2 === 0 ? 'bg-white' : 'bg-gray-50';
        // Tag each row with its filmId for highlighting.  If rec.filmId is
        // defined, assign it as a data attribute so applyFilmHighlight()
        // can identify and highlight rows corresponding to the selected film.
        if (rec && rec.filmId) {
          tr.dataset.filmid = String(rec.filmId);
        }
        // Create and populate table cells
        const tdFilm = document.createElement('td');
        tdFilm.className = 'px-2 py-1';
        tdFilm.textContent = ft;
        const tdStart = document.createElement('td');
        tdStart.className = 'px-2 py-1';
        tdStart.textContent = ShowtimeState.to12(rec.start);
        const tdAud = document.createElement('td');
        tdAud.className = 'px-2 py-1';
        tdAud.textContent = rec.audName || '';
        const tdGap = document.createElement('td');
        tdGap.className = 'px-2 py-1';
        tdGap.textContent = gapStr;
        if (shortGap && gapStr) tdGap.classList.add('bg-yellow-200');

        // No additional border styling is applied here.  The group separator
        // row inserted above provides the visual boundary between films.
        tr.appendChild(tdFilm);
        tr.appendChild(tdStart);
        tr.appendChild(tdAud);
        tr.appendChild(tdGap);
        bodyFilm.appendChild(tr);
      }
    }

    // === House Placement Audit ===
    // For each film title, list unique auditorium-seat pairs
    for (const ft of filmTitles) {
      const list = groups[ft];
      const pairs = new Map(); // key: audName -> seat count
      for (const rec of list) {
        const audId = rec.audId;
        let audName = rec.audName || '';
        let seats = '';
        try {
          const audRec = ShowtimeState.audById ? ShowtimeState.audById(audId) : null;
          if (audRec) {
            audName = audRec.name || audName;
            seats = audRec.seats != null ? String(audRec.seats) : seats;
          }
        } catch (_) {
          // ignore
        }
        // If rec itself has seats property, we could use it; but show rec may not have seats.
        if (!pairs.has(audName)) {
          pairs.set(audName, seats);
        }
      }
      const row = document.createElement('tr');
      row.className = 'bg-white';
      // Tag the row with the filmId of the first record in the list for
      // highlight matching.  Each row summarises a single film.
      const firstRec = list && list[0];
      if (firstRec && firstRec.filmId) {
        row.dataset.filmid = String(firstRec.filmId);
      }
      // Assign filmId to the entire row for highlighting.  Use the filmId
      // from the first record in the group if available.  This tags the
      // row so selecting the film will highlight the House Placement row.
      const sampleRecHP = list && list[0];
      if (sampleRecHP && sampleRecHP.filmId) {
        row.dataset.filmid = String(sampleRecHP.filmId);
      }
      const tdFilm = document.createElement('td');
      tdFilm.className = 'px-2 py-1 align-top';
      tdFilm.textContent = ft;
      const tdHouses = document.createElement('td');
      tdHouses.className = 'px-2 py-1';
      // Build string of "Aud X (seats)" pairs separated by comma
      const parts = [];
      for (const [audName, seats] of pairs.entries()) {
        let part = audName;
        if (seats) part += ` (${seats})`;
        parts.push(part);
      }
      tdHouses.textContent = parts.join(', ');
      row.appendChild(tdFilm);
      row.appendChild(tdHouses);
      bodyHouse.appendChild(row);
    }

    // === Shows per Auditorium ===
    // Group shows by auditorium
    const audGroups = {};
    for (const rec of shows) {
      const audId = rec.audId;
      if (!audGroups[audId]) audGroups[audId] = [];
      audGroups[audId].push(rec);
    }
    const audIds = Object.keys(audGroups);
    audIds.sort((a, b) => {
      // sort by auditorium name if available, else by numeric id
      const aName = (() => {
        try {
          const idNum = (typeof a === 'string' || typeof a === 'number') ? parseInt(a, 10) : a;
          const r = ShowtimeState.audById ? ShowtimeState.audById(idNum) : null;
          return r && r.name ? r.name : String(a);
        } catch (_) {
          return String(a);
        }
      })();
      const bName = (() => {
        try {
          const idNum = (typeof b === 'string' || typeof b === 'number') ? parseInt(b, 10) : b;
          const r = ShowtimeState.audById ? ShowtimeState.audById(idNum) : null;
          return r && r.name ? r.name : String(b);
        } catch (_) {
          return String(b);
        }
      })();
      return aName.localeCompare(bName);
    });
    for (const audId of audIds) {
      const list = audGroups[audId];
      if (!list || list.length === 0) continue;
      // Determine auditorium name and seats.  Convert audId to a number
      // before looking it up because audIds are stored as strings in
      // the grouping keys.  Without converting, ShowtimeState.audById
      // (which compares using strict equality) will fail to find a
      // match and return undefined, resulting in blank auditorium
      // names and seats.  See user bug report about empty cells.
      let audName = '';
      let seats = '';
      try {
        const idNum = (typeof audId === 'string' || typeof audId === 'number') ? parseInt(audId, 10) : audId;
        const audRec = ShowtimeState.audById ? ShowtimeState.audById(idNum) : null;
        if (audRec) {
          audName = audRec.name || '';
          seats = audRec.seats != null ? String(audRec.seats) : '';
        }
      } catch (_) {}
      // Sort shows by start time to get earliest and latest
      list.sort((a, b) => a.start - b.start);
      const firstShow = ShowtimeState.to12(list[0].start);
      const lastShow = ShowtimeState.to12(list[list.length - 1].start);
      const row = document.createElement('tr');
      row.className = 'bg-white';
      // Do not tag rows in the Shows per Auditorium table with a filmId.
      // Each row in this table represents an auditorium, not a single film.
      // Tagging by filmId could inadvertently apply film highlight styling,
      // causing the text to blend with the highlight colour.  By leaving
      // dataset.filmid undefined for this table, the highlight dropdown
      // will not alter these rows and their contents will remain visible.
      const tdAud = document.createElement('td');
      tdAud.className = 'px-2 py-1';
      tdAud.textContent = audName;
      const tdSeats = document.createElement('td');
      tdSeats.className = 'px-2 py-1';
      tdSeats.textContent = seats;
      const tdCount = document.createElement('td');
      tdCount.className = 'px-2 py-1';
      tdCount.textContent = String(list.length);
      const tdFirst = document.createElement('td');
      tdFirst.className = 'px-2 py-1';
      tdFirst.textContent = firstShow;
      const tdLast = document.createElement('td');
      tdLast.className = 'px-2 py-1';
      tdLast.textContent = lastShow;
      row.appendChild(tdAud);
      row.appendChild(tdSeats);
      row.appendChild(tdCount);
      row.appendChild(tdFirst);
      row.appendChild(tdLast);
      bodyAud.appendChild(row);
    }

    // === Shows per Feature ===
    // For each base film, count unique auditoriums (prints), show count, first show, last show
    for (const ft of filmTitles) {
      const list = groups[ft];
      if (!list || list.length === 0) continue;
      // Unique auditoriums
      const audSet = new Set();
      for (const rec of list) audSet.add(rec.audId);
      const prints = audSet.size;
      // Sort by start time
      list.sort((a, b) => a.start - b.start);
      const firstShow = ShowtimeState.to12(list[0].start);
      const lastShow = ShowtimeState.to12(list[list.length - 1].start);
      const row = document.createElement('tr');
      row.className = 'bg-white';
      // Tag row with filmId for highlighting using first record from the list.
      const sampleRec = list && list[0];
      if (sampleRec && sampleRec.filmId) {
        row.dataset.filmid = String(sampleRec.filmId);
      }
      const tdFilm = document.createElement('td');
      tdFilm.className = 'px-2 py-1';
      tdFilm.textContent = ft;
      const tdPrints = document.createElement('td');
      tdPrints.className = 'px-2 py-1';
      tdPrints.textContent = String(prints);
      const tdCount = document.createElement('td');
      tdCount.className = 'px-2 py-1';
      tdCount.textContent = String(list.length);
      const tdFirst = document.createElement('td');
      tdFirst.className = 'px-2 py-1';
      tdFirst.textContent = firstShow;
      const tdLast = document.createElement('td');
      tdLast.className = 'px-2 py-1';
      tdLast.textContent = lastShow;
      row.appendChild(tdFilm);
      row.appendChild(tdPrints);
      row.appendChild(tdCount);
      row.appendChild(tdFirst);
      row.appendChild(tdLast);
      bodyFeature.appendChild(row);
    }

    // After populating all audit tables, apply film highlights if available.
    // This ensures that rows corresponding to the selected film are
    // highlighted on the audit tab.  The function is defined in
    // app.js and gracefully no-ops if undefined.
    try {
      if (typeof window.applyFilmHighlight === 'function') {
        window.applyFilmHighlight();
      }
    } catch (_) {}
  }
  // Initial render and re-render on state changes
  // Populate selectors on first load
  populateTimeSelectors();

  render();
  // Apply film highlight after the initial render.  This ensures the audit
  // tables respond immediately to any existing highlight selection.
  try {
    if (typeof window.applyFilmHighlight === 'function') {
      window.applyFilmHighlight();
    }
  } catch (_) {}
  window.addEventListener('storage', () => {
    render();
    // Apply highlight after updating from storage changes
    try {
      if (typeof window.applyFilmHighlight === 'function') {
        window.applyFilmHighlight();
      }
    } catch (_) {}
  });
  // Setup date input behaviour. Use MM/DD/YYYY format for display and parse on change.
  if (dateInput) {
    const cur = ShowtimeState.getCurrentDate();
    if (cur) dateInput.value = ShowtimeState.isoToMMDD(cur);
    dateInput.addEventListener('change', () => {
      const val = dateInput.value;
      if (!val) return;
      const iso = ShowtimeState.mmddToIso(val);
      if (!iso) {
        alert('Invalid date format. Please use MM/DD/YYYY.');
        return;
      }
      dateInput.value = ShowtimeState.isoToMMDD(iso);
      ShowtimeState.setDate(iso);
      render();
      // After changing the date, reapply film highlight
      try {
        if (typeof window.applyFilmHighlight === 'function') {
          window.applyFilmHighlight();
        }
      } catch (_) {}
    });
    // When date changes from other components, update input, refresh selectors and re-render
    window.addEventListener('showtimeDateChanged', () => {
      const current = ShowtimeState.getCurrentDate();
      if (current) dateInput.value = ShowtimeState.isoToMMDD(current);
      populateTimeSelectors();
      render();
      // Reapply highlight after rendering with the new date
      try {
        if (typeof window.applyFilmHighlight === 'function') {
          window.applyFilmHighlight();
        }
      } catch (_) {}
    });
  }
  window.addEventListener('showtimeViewActivated', (evt) => {
    const detail = evt && evt.detail;
    const view = detail && detail.view ? detail.view : evt && evt.view;
    if (view === 'audit') {
      render();
      try {
        if (typeof window.applyFilmHighlight === 'function') {
          window.applyFilmHighlight();
        }
      } catch (_) {}
    }
  });
}

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initAuditPage);
} else {
  initAuditPage();
}

})();


// theme.js
/*
 * Theme picker logic for Showtime Builder.
 *
 * This script reads two CSS variables, --brand-from and --brand-to, from
 * localStorage on page load and applies them to the document element. It
 * registers click handlers on any element with data-brand-from and
 * data-brand-to attributes so that selecting a swatch updates the
 * gradient colours across the app. The selected colours persist across
 * page loads via localStorage. If localStorage is unavailable, the
 * picker gracefully degrades and uses the default colours defined in
 * theme.css.
 */
(function(){
  /**
   * Apply the provided colours to the CSS custom properties. Persist
   * the selection to localStorage so it can be restored on subsequent
   * page loads.
   *
   * @param {string} from - The starting colour of the gradient.
   * @param {string} to   - The ending colour of the gradient.
   */
  function apply(from, to) {
    document.documentElement.style.setProperty('--brand-from', from);
    document.documentElement.style.setProperty('--brand-to', to);
    try {
      localStorage.setItem('showtime:brand-from', from);
      localStorage.setItem('showtime:brand-to', to);
    } catch (err) {
      // localStorage may be unavailable in some contexts (e.g. private mode). Ignore errors.
    }
  }
  function initThemePicker() {
    // Attempt to restore previously selected colours.
    try {
      const from = localStorage.getItem('showtime:brand-from');
      const to = localStorage.getItem('showtime:brand-to');
      if (from && to) {
        apply(from, to);
      }
    } catch (err) {
      /* ignore */
    }
    // Wire up click handlers for all swatch buttons. Each button
    // specifies the colours it represents via data-brand-from and
    // data-brand-to attributes.
    document.querySelectorAll('[data-brand-from][data-brand-to]').forEach(btn => {
      btn.addEventListener('click', function() {
        const from = btn.getAttribute('data-brand-from');
        const to = btn.getAttribute('data-brand-to');
        apply(from, to);
      });
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initThemePicker);
  } else {
    initThemePicker();
  }
})();


// dense-toggle.js
// Dense Tables Toggle
//
// This script inserts a "Dense tables" checkbox into the navigation controls
// on every page and toggles a global `dense` class on the <body> when
// checked.  When enabled, table rows and headers reduce their padding
// and font size to display more information in the same vertical space.
// The toggle state is persisted in localStorage under the
// `showtime:denseTables` key so that the user’s preference carries
// across pages and sessions.

(function() {
  function initDenseToggle() {
    // Locate the navigation controls container; default to the nav itself.
    const nav = document.querySelector('nav');
    if (!nav) return;
    const controlsContainer = nav.querySelector('.nav-controls') || nav;
    // Avoid adding multiple toggles if the script is loaded more than once.
    if (document.getElementById('denseToggle')) return;
    // Build the label and checkbox elements.
    const label = document.createElement('label');
    label.title = 'Toggle compact tables';
    label.style.display = 'flex';
    label.style.alignItems = 'center';
    label.style.gap = '0.25rem';
    // Add some left padding to separate from adjacent controls
    label.style.paddingLeft = '0.5rem';
    const input = document.createElement('input');
    input.type = 'checkbox';
    input.id = 'denseToggle';
    input.style.width = '1rem';
    input.style.height = '1rem';
    // Retrieve saved state from localStorage and apply to body class.  If no
    // preference has been stored yet (null), default to enabled.  This
    // provides a compact view by default on first load.  Persist the
    // default so subsequent loads are consistent.  Use a try/catch to
    // guard against browsers that block localStorage.
    try {
      const saved = localStorage.getItem('showtime:denseTables');
      if (saved === '1') {
        input.checked = true;
        document.body.classList.add('dense');
      } else if (saved === null) {
        // No stored preference: default to checked
        input.checked = true;
        document.body.classList.add('dense');
        localStorage.setItem('showtime:denseTables', '1');
      }
    } catch (_) {
      // If localStorage is unavailable, still default to dense
      input.checked = true;
      document.body.classList.add('dense');
    }
    const span = document.createElement('span');
    span.textContent = 'Dense tables';
    span.style.fontSize = '0.8rem';
    // Prevent text selection on double click
    span.style.userSelect = 'none';
    label.appendChild(input);
    label.appendChild(span);
    // Append the toggle to the nav controls
    controlsContainer.appendChild(label);
    // Listen for changes and toggle the `dense` class accordingly
    input.addEventListener('change', e => {
      const checked = e.target.checked;
      document.body.classList.toggle('dense', checked);
      try {
        localStorage.setItem('showtime:denseTables', checked ? '1' : '0');
      } catch (_) {}
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initDenseToggle);
  } else {
    initDenseToggle();
  }
})();


// header-controls.js
// Generic header controls script
// This script inserts functionality for the First/Last show selectors and the
// date picker on pages that do not have their own schedule or prime logic.
// It initialises multi‑date support, populates the dropdowns with sensible
// defaults, synchronises them with the global ShowtimeState and updates
// state when the user makes changes.  It also adds handlers to the
// previous/next day buttons to adjust the current date.
(function() {
  const ShowtimeState = window.ShowtimeState;
  function initHeaderControls() {
    if (!ShowtimeState) return;
    // Ensure per‑date scheduling is initialised
    try {
      ShowtimeState.initDateSupport();
    } catch (_) {}
    const firstSel = document.getElementById('firstShowGlobalSelect');
    const lastSel = document.getElementById('lastShowGlobalSelect');
    const dateInput = document.getElementById('scheduleDateGlobal');
    const prevBtn = document.getElementById('prevDateGlobalBtn');
    const nextBtn = document.getElementById('nextDateGlobalBtn');
    // Populate the First/Last show dropdowns with 30‑minute increments.
    function populateTimeSelectors() {
      if (!firstSel || !lastSel) return;
      // Generate first show options: 05:00 through 19:00 (7:00pm) in 30‑minute steps
      const times = [];
      let t = ShowtimeState.dtFromHM('05:00');
      const end = ShowtimeState.dtFromHM('19:00');
      while (t <= end) {
        times.push(ShowtimeState.hmFromDate(t));
        t = new Date(t.getTime() + 30 * 60000);
      }
      // Generate last show options covering 20:00 through 02:00 (next day) in 30‑minute steps
      const lastTimes = ['20:00','20:30','21:00','21:30','22:00','22:30','23:00','23:30','00:00','00:30','01:00','01:30','02:00'];
      // Clear existing options
      firstSel.innerHTML = '';
      lastSel.innerHTML = '';
      times.forEach(hm => {
        const opt = document.createElement('option');
        opt.value = hm;
        opt.textContent = ShowtimeState.fmtHM(hm);
        firstSel.appendChild(opt);
      });
      lastTimes.forEach(hm => {
        const opt = document.createElement('option');
        opt.value = hm;
        opt.textContent = ShowtimeState.fmtHM(hm);
        lastSel.appendChild(opt);
      });
      // Set selected values from state if present
      try {
        if (ShowtimeState.state.firstShowHM) firstSel.value = ShowtimeState.state.firstShowHM;
        if (ShowtimeState.state.lastShowHM) lastSel.value = ShowtimeState.state.lastShowHM;
      } catch (_) {}
    }
    populateTimeSelectors();
    // Update state when the user changes the first/last show times
    if (firstSel) {
      firstSel.addEventListener('change', () => {
        try {
          ShowtimeState.state.firstShowHM = firstSel.value;
          ShowtimeState.save();
        } catch (_) {}
      });
    }
    if (lastSel) {
      lastSel.addEventListener('change', () => {
        try {
          ShowtimeState.state.lastShowHM = lastSel.value;
          ShowtimeState.save();
        } catch (_) {}
      });
    }
    // Date picker synchronisation
    if (dateInput) {
      // Set the current date in MM/DD/YYYY on load
      try {
        const current = ShowtimeState.getCurrentDate();
        if (current) dateInput.value = ShowtimeState.isoToMMDD(current);
      } catch (_) {}
      // When the user changes the date, convert to ISO and update state
      dateInput.addEventListener('change', () => {
        const inputVal = dateInput.value;
        if (!inputVal) return;
        let iso = null;
        try {
          iso = ShowtimeState.mmddToIso(inputVal);
        } catch (_) {}
        if (!iso) {
          alert('Invalid date format. Please use MM/DD/YYYY.');
          return;
        }
        try {
          dateInput.value = ShowtimeState.isoToMMDD(iso);
          ShowtimeState.setDate(iso);
        } catch (_) {}
      });
      // Update the input when the date changes from other components
      window.addEventListener('showtimeDateChanged', () => {
        try {
          const cur = ShowtimeState.getCurrentDate();
          if (cur) dateInput.value = ShowtimeState.isoToMMDD(cur);
        } catch (_) {}
        // When the date changes, refresh the first/last show selectors so
        // they reflect the times associated with the new date.  The
        // populateTimeSelectors function updates the option lists and
        // selects the stored values from state.  Without this, the
        // selectors would retain the previous date's values even
        // though the underlying state has changed.
        try {
          populateTimeSelectors();
        } catch (_) {}
      });
    }
    // Helper to shift the current date by +/- 1 day
    function shiftDate(delta) {
      try {
        const curIso = ShowtimeState.getCurrentDate();
        let d = curIso ? new Date(curIso) : new Date();
        if (isNaN(d)) d = new Date();
        d.setDate(d.getDate() + delta);
        const iso = d.toISOString().slice(0, 10);
        ShowtimeState.setDate(iso);
        if (dateInput) dateInput.value = ShowtimeState.isoToMMDD(iso);
      } catch (_) {}
    }
    if (prevBtn) prevBtn.addEventListener('click', () => shiftDate(-1));
    if (nextBtn) nextBtn.addEventListener('click', () => shiftDate(1));
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initHeaderControls);
  } else {
    initHeaderControls();
  }
})();


// order-panel.js
// Order Panel: collapsible order list visible on every page.
// This script creates a toggle button and an overlay panel that displays
// the start‑time order of shows with up/down nudge controls. It reads
// from the global ShowtimeState and writes overrides via
// ShowtimeState.updateShowStart. The panel is hidden by default and
// appears when the toggle button is clicked. When visible, it
// re‑renders whenever state changes.

(() => {
  const ShowtimeState = window.ShowtimeState;
  if (!ShowtimeState) return;
  function initOrderPanel() {
    // Track which show is currently selected in the order panel. When a row
    // is clicked, we store its id here and re-render to apply a purple
    // highlight. This parallels the original React implementation where
    // the active show was highlighted.
    let activeShowId = null;
    // Insert toggle button into the nav bar. If a nav is present,
    // append the button; otherwise insert at top of body.
    const nav = document.querySelector('nav');
    const toggleBtn = document.createElement('button');
    toggleBtn.id = 'orderPanelToggleBtn';
    toggleBtn.textContent = 'Show Order';
    // Style the toggle button similarly to other header buttons.  Do not
    // assign ml-auto here; placement is handled when the button is
    // appended to the navigation controls container below.
    toggleBtn.className = 'px-3 py-1 bg-indigo-700 text-white rounded-lg hover:bg-indigo-800 text-sm';
    // Insert the toggle button into a navigation controls container if
    // available; otherwise append it at the end of the nav.  Pages that
    // define a `.nav-controls` container will group all controls on a
    // dedicated row below the navigation links.  This ensures the Show/Hide
    // Order button stays with the other controls and doesn't push
    // navigation links off screen.
    if (nav) {
      const controlsContainer = nav.querySelector('.nav-controls');
      if (controlsContainer) {
        controlsContainer.appendChild(toggleBtn);
      } else {
        nav.appendChild(toggleBtn);
      }
    } else {
      document.body.insertBefore(toggleBtn, document.body.firstChild);
    }
    // Create panel container. It may be initially hidden depending on saved state.
    const panel = document.createElement('div');
    panel.id = 'orderPanel';
    // Style the panel as a sidebar within the page flow rather than an overlay.
    // We omit position classes (`fixed top-0 bottom-0 right-0`) so that the panel
    // participates in the normal flex layout and pushes the main content to
    // the left when visible.  The width matches the React version (~28rem).
    // Increase panel width slightly from ~28rem to 30rem so that the
    // start‑time order list has more breathing room.  With the main tables
    // narrowed, the page still has space to accommodate a wider panel.
    // Increase the minimum width of the order panel slightly so header labels
    // remain on one line.  Using 34rem provides extra breathing room compared
    // to the prior 30rem width.  See issue reported by users when labels
    // wrapped prematurely.
    panel.className = 'hidden bg-white border-l border-gray-300 shadow-lg w-[34rem] flex flex-col rounded-l-lg';
    // Make the panel focusable so it can capture keyboard events when needed.
    panel.tabIndex = 0;
    // Prevent the panel from shrinking horizontally when the viewport
    // narrows.  Without this, flexbox can reduce the panel width and
    // cause the header labels to wrap onto multiple lines.  Setting
    // flexShrink to 0 ensures the panel retains its intrinsic width and
    // keeps the Start‑Clean‑Aud‑Film‑Nudge header on a single line.
    panel.style.flexShrink = '0';
    // Prepare header‑level nudge buttons.  These will be appended to the
    // header after both the title and a right group container are created.
    // We declare them here so the click handlers can be attached after
    // nudgeShow is defined later in this file.
    let headerNudgeUpBtn = null;
    let headerNudgeDownBtn = null;

    // Add header with close button
    const header = document.createElement('div');
    // Use the dynamic gradient header class so the order panel header updates
    // with the selected theme colours. The grad-header class is defined in
    // theme.css and uses CSS variables controlled by the swatch picker.
    header.className = 'flex justify-between items-center grad-header px-3 py-2 rounded-t-lg';
    const title = document.createElement('span');
    title.textContent = 'Start‑Time Order';
    title.className = 'font-semibold text-sm';
    const closeBtn = document.createElement('button');
    closeBtn.className = 'text-white hover:text-gray-200';
    closeBtn.textContent = '×';
    // When the close button is clicked, collapse the panel and persist the state
    closeBtn.addEventListener('click', () => {
      applyPanelState(false);
    });
    // Create container for header nudge buttons and close button.  The
    // container groups the nudge controls with the close button so that
    // they remain aligned on the right side of the header.  Space between
    // the title and this group is handled by the parent flex layout.
    const headerButtons = document.createElement('div');
    headerButtons.className = 'flex items-center space-x-1';
    // Create the header nudge buttons but do not attach handlers yet.  We
    // assign them to the declared variables so they are accessible later.
    headerNudgeUpBtn = document.createElement('button');
    // Style header-level nudge buttons with a dark text colour so the ▲/▼ icons
    // are visible against the white background even when the parent header
    // inherits a white font colour. Without an explicit text colour, the
    // buttons inherit the header’s white font colour and the arrows become
    // invisible on the white button background (see issue reported by user).
    headerNudgeUpBtn.className = 'inline-flex items-center border rounded-lg px-2 py-0.5 bg-white hover:bg-gray-50 shadow-sm text-sm text-gray-700';
    headerNudgeUpBtn.textContent = '▲';
    headerNudgeDownBtn = document.createElement('button');
    headerNudgeDownBtn.className = 'inline-flex items-center border rounded-lg px-2 py-0.5 bg-white hover:bg-gray-50 shadow-sm text-sm text-gray-700';
    headerNudgeDownBtn.textContent = '▼';
    // Append buttons to the header button group
    headerButtons.appendChild(headerNudgeUpBtn);
    headerButtons.appendChild(headerNudgeDownBtn);
    // Append close button after nudge buttons
    headerButtons.appendChild(closeBtn);
    // Assemble header: title on left, button group on right
    header.appendChild(title);
    header.appendChild(headerButtons);
    panel.appendChild(header);
    // Add table container
    const container = document.createElement('div');
    container.className = 'overflow-y-auto';
    // Create table
    const table = document.createElement('table');
    table.className = 'min-w-full divide-y divide-gray-200 text-xs';
    // Build header row
    const thead = document.createElement('thead');
    thead.className = 'bg-gray-100';
    const headerRow = document.createElement('tr');
    ['Start','Clean','Aud','Film','Nudge'].forEach(label => {
      const th = document.createElement('th');
      th.className = 'px-3 py-1 text-left uppercase tracking-wide text-gray-600';
      th.textContent = label;
      headerRow.appendChild(th);
    });
    thead.appendChild(headerRow);
    table.appendChild(thead);
    // Body for rows
    const tbody = document.createElement('tbody');
    tbody.id = 'orderPanelBody';
    table.appendChild(tbody);
    container.appendChild(table);
    panel.appendChild(container);
    // Do not immediately append the panel to the body.  It will be inserted
    // into a content wrapper later so that it aligns with the main content.

    // The panel is no longer absolutely positioned; it will be placed into
    // a flex wrapper alongside the main content.  We therefore omit the
    // previous positioning logic that adjusted its top offset relative to
    // the navigation bar and swatch row.

    // Helper to apply the open/closed state to the panel and adjust the
    // surrounding layout. When the panel is visible the content wrapper
    // displays its children horizontally (main content and panel), and
    // the main content grows to fill remaining space. When hidden the
    // wrapper collapses to a single column and the panel is removed from
    // the flex flow via the `hidden` class.
    function applyPanelState(open) {
      const wrapper = document.getElementById('contentWrapper');
      const main = document.getElementById('mainContent');
      if (open) {
        panel.classList.remove('hidden');
        toggleBtn.textContent = 'Hide Order';
        if (wrapper) wrapper.classList.add('with-order');
        if (main) main.classList.add('flex-grow');
        render();
        // Focus the panel so that it can receive keyboard events (arrow navigation).  
        // Without focusing, keydown events may be captured by other parts of the page.
        try {
          panel.focus();
        } catch {}
      } else {
        panel.classList.add('hidden');
        toggleBtn.textContent = 'Show Order';
        if (wrapper) wrapper.classList.remove('with-order');
        if (main) main.classList.remove('flex-grow');
      }
      // Persist the state
      if (ShowtimeState.state) {
        ShowtimeState.state.showOrderPanel = open;
        ShowtimeState.save();
      }
    }

    /**
     * Build the structural wrapper for the page so that the order panel can sit
     * beside the main content.  This function finds the navigation bar and
     * optional swatch row, then wraps all subsequent body children into
     * a `contentWrapper` element.  Inside the wrapper we create a
     * `mainContent` container for the existing page content and append the
     * order panel.  A small stylesheet is injected on first run to
     * implement the flex behaviour when the panel is visible.
     */
    function createContentWrapper() {
      // Avoid re‑creating the wrapper if it already exists
      if (document.getElementById('contentWrapper')) return;
      // Identify nav and swatch row
      const navEl = document.querySelector('nav');
      const swatchButton = document.querySelector('.swatch');
      const swatchRow = swatchButton ? swatchButton.parentElement : null;
      // Determine insertion point after which the wrapper should be inserted
      let insertAfter = null;
      if (swatchRow && swatchRow.parentElement === document.body && navEl && swatchRow.previousElementSibling === navEl) {
        insertAfter = swatchRow;
      } else if (navEl && navEl.parentElement === document.body) {
        insertAfter = navEl;
      } else {
        insertAfter = null;
      }
      // Create wrapper and main containers
      const wrapper = document.createElement('div');
      wrapper.id = 'contentWrapper';
      wrapper.className = 'w-full';
      const main = document.createElement('div');
      main.id = 'mainContent';
      // Move all siblings after insertion point into main container
      let startNode = insertAfter ? insertAfter.nextSibling : document.body.firstChild;
      const toMove = [];
      while (startNode) {
        const next = startNode.nextSibling;
        toMove.push(startNode);
        startNode = next;
      }
      toMove.forEach(node => {
        main.appendChild(node);
      });
      // Append main and panel into wrapper
      wrapper.appendChild(main);
      wrapper.appendChild(panel);
      // Insert wrapper into DOM
      if (insertAfter) {
        insertAfter.parentElement.insertBefore(wrapper, insertAfter.nextSibling);
      } else {
        document.body.insertBefore(wrapper, document.body.firstChild);
      }
      // Prevent horizontal scrolling when the order panel is visible.  Without
      // this, the combined width of the nav bar and the content wrapper can
      // exceed the viewport when the panel is open, resulting in a horizontal
      // scrollbar.  Setting overflow-x to hidden on the body hides this scroll
      // bar and mirrors the behaviour of the original React implementation.
      document.body.style.overflowX = 'hidden';
      // Inject CSS rules once to control layout when panel is visible
      if (!document.getElementById('orderPanelStyles')) {
        const style = document.createElement('style');
        style.id = 'orderPanelStyles';
        style.textContent = `
#contentWrapper.with-order {
  display: flex;
}
#contentWrapper.with-order #mainContent {
  flex-grow: 1;
}
#contentWrapper:not(.with-order) {
  display: block;
}
/* Prevent wrapping of the header cells inside the order panel table. */
#orderPanel table th {
  white-space: nowrap;
}
        `;
        document.head.appendChild(style);
      }
    }

    // Helper to normalize times: treat times before 5:00a as next day.
    function normalizeDate(dt) {
      const n = new Date(dt);
      if (n.getHours() < 5) {
        n.setDate(n.getDate() + 1);
      }
      return n;
    }
    // Compute time gap between current show and next show in same auditorium.
    function cleanGap(current, shows) {
      let next = null;
      const currNormStart = normalizeDate(current.start);
      shows.forEach(rec => {
        if (rec.audId === current.audId) {
          const recNormStart = normalizeDate(rec.start);
          if (recNormStart > currNormStart) {
            if (!next || recNormStart < normalizeDate(next.start)) {
              next = rec;
            }
          }
        }
      });
      if (!next) return '';
      const mins = Math.floor((normalizeDate(next.start) - normalizeDate(current.end)) / 60000);
      return mins;
    }
    function formatCleanLabel(mins) {
      if (mins === '') return '';
      if (mins >= 60) {
        const h = Math.floor(mins / 60);
        const m = mins % 60;
        return `${h}h${String(m).padStart(2,'0')}m`;
      }
      return `${mins}m`;
    }
    function nudgeShow(rec, dir) {
      const newDate = new Date(rec.start.getTime() + dir * 5 * 60000);
      const hm = ShowtimeState.hmFromDate(newDate);
      ShowtimeState.updateShowStart(rec.id, hm);
      // Fire storage event manually to notify other components in same page
      try {
        const evt = new Event('storage');
        window.dispatchEvent(evt);
      } catch {}
      render();
    }

    // Attach click handlers to the header‑level nudge buttons once nudgeShow is defined.
    // These handlers adjust the start time of the currently active show (selected row)
    // by ±5 minutes. They rely on the global activeShowId, normalizeDate helper and
    // ShowtimeState.getAllShows() to find the corresponding record. Use a
    // data‑bound attribute to avoid reattaching listeners on subsequent renders.
    if (headerNudgeUpBtn && !headerNudgeUpBtn.hasAttribute('data-bound')) {
      headerNudgeUpBtn.setAttribute('data-bound', 'true');
      headerNudgeUpBtn.addEventListener('click', (e) => {
        // Prevent click from bubbling to the header or other handlers
        e.stopPropagation();
        // If no show is active, do nothing
        if (!activeShowId) return;
        // Build sorted list of shows as done in render()
        const shows = ShowtimeState.getAllShows().slice().sort((a, b) => {
          const an = normalizeDate(a.start);
          const bn = normalizeDate(b.start);
          return an - bn;
        });
        const rec = shows.find(r => r.id === activeShowId);
        if (!rec) return;
        // Nudge backwards by 5 minutes
        nudgeShow(rec, -1);
      });
    }
    if (headerNudgeDownBtn && !headerNudgeDownBtn.hasAttribute('data-bound')) {
      headerNudgeDownBtn.setAttribute('data-bound', 'true');
      headerNudgeDownBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        if (!activeShowId) return;
        const shows = ShowtimeState.getAllShows().slice().sort((a, b) => {
          const an = normalizeDate(a.start);
          const bn = normalizeDate(b.start);
          return an - bn;
        });
        const rec = shows.find(r => r.id === activeShowId);
        if (!rec) return;
        // Nudge forwards by 5 minutes
        nudgeShow(rec, 1);
      });
    }
    function render() {
      // Ensure prime rows exist if necessary (copied from order.js)
      (function ensurePrimeRows() {
        const state = ShowtimeState.state;
        if (!state.primeRows || state.primeRows.length === 0) {
          const rows = [];
          (state.bookings || []).forEach(b => {
            if (!b.filmId) return;
            rows.push({
              rowId: `PRB-${b.id}`,
              bookingId: b.id,
              slot: b.slot,
              filmId: b.filmId,
              audId: null,
              primeHM: ''
            });
          });
          if (rows.length > 0) {
            state.primeRows = rows;
            ShowtimeState.save();
          }
        }
      })();
      const allShows = ShowtimeState.getAllShows();
      // Sort shows chronologically
      const shows = allShows.slice().sort((a, b) => {
        const an = normalizeDate(a.start);
        const bn = normalizeDate(b.start);
        return an - bn;
      });
      // Render rows
      tbody.innerHTML = '';
      shows.forEach((rec, idx) => {
        const tr = document.createElement('tr');
        // Tag the row with filmId for highlighting.  When a film is selected
        // from the highlight dropdown, rows matching this filmId will
        // receive the film-highlight class.  rec.filmId may be absent for
        // manual shows; in that case the dataset is not set.
        if (rec.filmId) {
          tr.dataset.filmid = String(rec.filmId);
        }
        // Apply a purple ring and light background when this row is active
        const baseClass = 'hover:bg-gray-50';
        const activeClass = 'ring-2 ring-purple-400 bg-purple-50';
        tr.className = (rec.id === activeShowId) ? `${baseClass} ${activeClass}` : baseClass;
        // Add a thin medium‑grey bottom border when the next show starts in a
        // different hour. A subtle grey (#9ca3af) helps visual separation
        // of hour blocks without the starkness of black.  See issue #.
        if (idx < shows.length - 1) {
          const currHour = normalizeDate(rec.start).getHours();
          const nextHour = normalizeDate(shows[idx + 1].start).getHours();
          if (currHour !== nextHour) {
            tr.style.borderBottom = '1px solid #9ca3af';
          }
        }
        // When a row is clicked, set it as active and re-render to update
        tr.addEventListener('click', () => {
          // Update the active show id locally
          activeShowId = rec.id;
          // Notify other components of the active show change so the
          // schedule grid can highlight the corresponding cell. We
          // dispatch a custom event with the show id.
          try {
            const evt = new CustomEvent('activeShowChange', { detail: { showId: rec.id } });
            window.dispatchEvent(evt);
          } catch {}
          render();
        });
        // Start
        const tdStart = document.createElement('td');
        tdStart.className = 'px-3 py-1 font-mono tabular-nums';
        tdStart.textContent = ShowtimeState.to12(rec.start);
        tr.appendChild(tdStart);
        // Clean gap
        const gap = cleanGap(rec, shows);
        const tdClean = document.createElement('td');
        tdClean.className = 'px-3 py-1 font-mono tabular-nums';
        const label = formatCleanLabel(gap);
        if (label && gap < 15) {
          const span = document.createElement('span');
          span.className = 'bg-yellow-100 rounded px-1';
          span.textContent = label;
          tdClean.appendChild(span);
        } else {
          tdClean.textContent = label;
        }
        tr.appendChild(tdClean);
        // Auditorium
        const tdAud = document.createElement('td');
        tdAud.className = 'px-3 py-1';
        tdAud.textContent = rec.audName || '';
        tr.appendChild(tdAud);
        // Film
        const tdFilm = document.createElement('td');
        tdFilm.className = 'px-3 py-1';
        tdFilm.textContent = rec.filmTitle || '';
        tr.appendChild(tdFilm);
        // Nudge
        const tdNudge = document.createElement('td');
        tdNudge.className = 'px-3 py-1';
        const btnUp = document.createElement('button');
        // Increase the corner radius for nudge buttons to match other button styles
        btnUp.className = 'inline-flex items-center border rounded-lg px-2 py-0.5 mr-1 bg-white hover:bg-gray-50 shadow-sm';
        btnUp.textContent = '▲';
        btnUp.addEventListener('click', (e) => {
          e.stopPropagation();
          nudgeShow(rec, -1);
        });
        const btnDown = document.createElement('button');
        btnDown.className = 'inline-flex items-center border rounded-lg px-2 py-0.5 bg-white hover:bg-gray-50 shadow-sm';
        btnDown.textContent = '▼';
        btnDown.addEventListener('click', (e) => {
          e.stopPropagation();
          nudgeShow(rec, 1);
        });
        tdNudge.appendChild(btnUp);
        tdNudge.appendChild(btnDown);
        tr.appendChild(tdNudge);
        tbody.appendChild(tr);
      });

      // After building the order panel rows, apply film highlighting.
      // This highlights rows whose filmId matches the selected film
      // from the global highlight selector.  The helper is defined in
      // app.js and will no-op if undefined.
      if (typeof window.applyFilmHighlight === 'function') {
        window.applyFilmHighlight();
      }
    }

    // Listen for cross‑component show highlight changes. When the schedule
    // grid sets a show as active (e.g. by focusing a showtime dropdown),
    // update the order panel’s active row and re-render so the purple
    // highlight appears in sync. Without this, the order panel would
    // continue to show whatever row was last clicked. Only re-render when
    // the id actually changes to avoid unnecessary work.
    window.addEventListener('activeShowChange', (e) => {
      const id = e && e.detail && e.detail.showId;
      if (!id) return;
      if (activeShowId === id) return;
      activeShowId = id;
      render();
    });
    // Toggle panel visibility
    toggleBtn.addEventListener('click', () => {
      // Determine current state and toggle
      const isHidden = panel.classList.contains('hidden');
      applyPanelState(isHidden);
    });
    // Re-render on storage events to reflect changes from other pages. The native
    // storage event only fires on tabs other than the one performing the save.
    window.addEventListener('storage', () => {
      if (!panel.classList.contains('hidden')) {
        render();
      }
    });
    // Also listen for the custom showtimeStateUpdated event which is
    // dispatched in app.js after each save. This allows the panel to
    // update immediately within the same tab when schedule grid edits
    // occur. Without this, manual changes on the schedule page would
    // require a navigation or manual refresh to propagate here.
    window.addEventListener('showtimeStateUpdated', () => {
      if (!panel.classList.contains('hidden')) {
        render();
      }
    });

    // Keyboard navigation for the start‑time order panel.  When the panel is visible,
    // allow the user to move the active selection up or down using the
    // ArrowUp and ArrowDown keys.  This enhances accessibility and
    // matches the behaviour of the original application.  Only handle
    // arrow keys when focus is not inside a form field or the schedule grid.
    document.addEventListener('keydown', (e) => {
      // Only process up/down arrows when the order panel is visible
      if (panel.classList.contains('hidden')) return;
      if (e.key !== 'ArrowUp' && e.key !== 'ArrowDown') return;
      const activeEl = document.activeElement;
      // Ignore key events originating from input, select, textarea or contenteditable elements
      const tag = activeEl && activeEl.tagName ? activeEl.tagName.toLowerCase() : '';
      if (tag === 'input' || tag === 'select' || tag === 'textarea' || (activeEl && activeEl.isContentEditable)) return;
      // Ignore if focused inside the schedule grid (to avoid interfering with grid navigation)
      try {
        if (activeEl && activeEl.closest && (activeEl.closest('#gridBody') || activeEl.closest('#scheduleGrid'))) return;
      } catch {}
      // Prevent default browser scrolling behaviour
      e.preventDefault();
      // Build sorted list of shows as in render()
      const shows = ShowtimeState.getAllShows().slice().sort((a, b) => {
        const an = normalizeDate(a.start);
        const bn = normalizeDate(b.start);
        return an - bn;
      });
      if (shows.length === 0) return;
      // Find current active index; if none, start at beginning or end depending on direction
      let idx = shows.findIndex(r => r.id === activeShowId);
      if (idx === -1) {
        idx = (e.key === 'ArrowDown') ? 0 : shows.length - 1;
      } else {
        idx = idx + (e.key === 'ArrowDown' ? 1 : -1);
        if (idx < 0) idx = shows.length - 1;
        if (idx >= shows.length) idx = 0;
      }
      const newRec = shows[idx];
      if (newRec) {
        activeShowId = newRec.id;
        // Notify other components of the change
        try {
          const evt = new CustomEvent('activeShowChange', { detail: { showId: newRec.id } });
          window.dispatchEvent(evt);
        } catch {}
        // Re-render the panel to highlight the new selection
        render();
      }
    });
    // Build the wrapper and insert the panel into the page flow.  This must
    // run before we apply any visibility state so that the panel resides
    // inside the correct container.  Without this call the panel would
    // remain unattached and toggling would fail.
    createContentWrapper();

    // Automatically open or close the panel based on saved state when the page loads.
    // Read showOrderPanel from state; if true, open the panel. We defer the
    // call slightly to allow the wrapper to render, but no measurement of
    // widths is needed because flex handles sizing.
    const initialOpen = ShowtimeState.state && ShowtimeState.state.showOrderPanel;
    if (initialOpen !== false) {
      setTimeout(() => applyPanelState(true), 0);
    }
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initOrderPanel);
  } else {
    initOrderPanel();
  }
})();


// data.js
// Data export/import functionality for Showtime Builder
// Provides buttons to export the entire state to JSON or a CSV of all shows,
// and to import a previously exported JSON file to restore the schedule.

(() => {

function initDataControls() {
  const ShowtimeState = window.ShowtimeState;
  // Ensure state is loaded before interacting
  try { ShowtimeState.load(); } catch (e) { /* ignore if not present */ }

  const btnJson = document.getElementById('exportJsonBtn');
  const btnCsv = document.getElementById('exportCsvBtn');
  const inputFile = document.getElementById('importFileInput');

  const importTextBtn = document.getElementById('importTextBtn');
  const importTextArea = document.getElementById('importText');

  if (btnJson) {
    btnJson.addEventListener('click', () => {
      // Retrieve the full persisted state
      const data = ShowtimeState.state;
      const jsonStr = JSON.stringify(data, null, 2);
      const blob = new Blob([jsonStr], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'showtime-data.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    });
  }

  if (btnCsv) {
    btnCsv.addEventListener('click', () => {
      // Build a CSV across all dates containing movie title, film format, auditorium name,
      // start time and date. Sort by date then auditorium then start time.
      const state = ShowtimeState.state || {};
      const scheds = state.scheduleByDate && typeof state.scheduleByDate === 'object' ? Object.keys(state.scheduleByDate) : [];
      // If no schedules exist, simply export an empty CSV with headers.
      let records = [];
      const origDate = state.currentDate;
      // Iterate through each date, load its schedule and gather shows
      const dates = scheds.slice().sort();
      dates.forEach(date => {
        try {
          // Load schedule for this date without persisting changes.  This sets
          // state.currentDate and populates prime/extra rows and manual shows.
          ShowtimeState.loadSchedule(date);
          const shows = ShowtimeState.getAllShows ? ShowtimeState.getAllShows() : [];
          shows.forEach(rec => {
            records.push({ date, rec });
          });
        } catch (_) { /* ignore errors to avoid breaking the export */ }
      });
      // Restore original date
      if (origDate) {
        try {
          ShowtimeState.loadSchedule(origDate);
        } catch (_) {}
      }
      // Sort by date, then auditorium name, then start time
      records.sort((a, b) => {
        if (a.date < b.date) return -1;
        if (a.date > b.date) return 1;
        const aAud = (a.rec.audName || '').toLowerCase();
        const bAud = (b.rec.audName || '').toLowerCase();
        if (aAud < bAud) return -1;
        if (aAud > bAud) return 1;
        return (a.rec.start || 0) - (b.rec.start || 0);
      });
      // Build CSV header
      let csv = 'Movie,Format,Auditorium,Start Time,Date\n';
      const esc = (v) => {
        if (v == null) return '';
        const s = String(v);
        return s.includes(',') ? '"' + s.replace(/"/g, '""') + '"' : s;
      };
      records.forEach(item => {
        const { date, rec } = item;
        // Lookup film details by ID.  Fall back to rec.filmTitle if id not found.
        let filmTitle = rec.filmTitle || '';
        let filmFormat = '';
        try {
          if (ShowtimeState.state && Array.isArray(ShowtimeState.state.films)) {
            const film = ShowtimeState.state.films.find(f => f.id === rec.filmId);
            if (film) {
              filmTitle = film.title || filmTitle;
              filmFormat = film.format || '';
            }
          }
        } catch (_) {}
        const auditorium = rec.audName || '';
        // Convert start to 12‑hour time (e.g. 10:00am) using existing helper if available
        let startStr = '';
        try {
          startStr = ShowtimeState.to12 ? ShowtimeState.to12(rec.start) : '';
        } catch (_) {}
        csv += `${esc(filmTitle)},${esc(filmFormat)},${esc(auditorium)},${esc(startStr)},${esc(date)}\n`;
      });
      // Create and download the CSV file
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'showtime-schedule.csv';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    });
  }

  if (inputFile) {
    inputFile.addEventListener('change', (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function() {
        try {
          const data = JSON.parse(reader.result);
          if (data && typeof data === 'object') {
            // Persist the imported state directly into localStorage.  We avoid
            // calling ShowtimeState.save() here because it writes the internal
            // state variable (which we cannot mutate from this context) back to
            // storage, effectively discarding the imported data.  Writing
            // directly ensures that subsequent loads hydrate from the new state.
            try {
              localStorage.setItem('showtime:persist', JSON.stringify(data));
            } catch (_) {
              /* ignore storage errors */
            }
            // Update the externally exposed state property for completeness,
            // but note that most pages rely on the internal state loaded via
            // ShowtimeState.load(), so this assignment alone is insufficient.
            ShowtimeState.state = data;
            // Inform the user and reload the application to apply the imported data.
            alert('Data imported successfully. The application will reload to apply your changes.');
            setTimeout(() => {
              location.href = 'index.html';
            }, 200);
          } else {
            alert('Invalid JSON file.');
          }
        } catch (err) {
          alert('Failed to parse JSON: ' + err.message);
        }
      };
      reader.readAsText(file);
    });
  }

  if (importTextBtn && importTextArea) {
    importTextBtn.addEventListener('click', () => {
      const text = importTextArea.value.trim();
      if (!text) {
        alert('Please paste JSON into the textbox first.');
        return;
      }
      let data;
      try {
        data = JSON.parse(text);
      } catch (err) {
        alert('Invalid JSON: ' + err.message);
        return;
      }
      if (data && typeof data === 'object') {
        // Persist the imported state to localStorage without calling
        // ShowtimeState.save(). See file import handler for details.
        try {
          localStorage.setItem('showtime:persist', JSON.stringify(data));
        } catch (_) {
          /* ignore storage errors */
        }
        ShowtimeState.state = data;
        alert('Pasted data imported successfully. The application will reload to apply your changes.');
        setTimeout(() => {
          location.href = 'index.html';
        }, 200);
      } else {
        alert('JSON must be an object representing the saved state.');
      }
    });
  }

  // Handle clearing all schedules when the button exists. This resets
  // schedules across all dates while preserving auditoriums and bookings.
  const clearAllBtn = document.getElementById('clearAllSchedulesBtn');
  if (clearAllBtn) {
    clearAllBtn.addEventListener('click', () => {
      if (!confirm('Are you sure you want to clear all schedules? This will remove all showtimes for every date.')) {
        return;
      }
      if (typeof ShowtimeState.clearAllSchedules === 'function') {
        ShowtimeState.clearAllSchedules();
        alert('All schedules have been cleared.');
        // Optionally reload the page to reflect the cleared state on schedule pages
        // but not necessary on the home page.
      } else {
        alert('Clear schedules function not available.');
      }
    });
  }

  // Handle clearing all bookings and showtimes when the button exists.
  // This removes every booking and resets schedule data across every date.
  // It preserves auditorium and film definitions but resets the state to a blank schedule and bookings list.
  const clearBookingsTimesBtn = document.getElementById('clearBookingsTimesBtn');
  if (clearBookingsTimesBtn) {
    clearBookingsTimesBtn.addEventListener('click', () => {
      if (!confirm('Are you sure you want to clear all bookings and showtimes? This will remove all bookings and showtimes across every date.')) {
        return;
      }
      if (typeof ShowtimeState.clearBookingsAndTimes === 'function') {
        ShowtimeState.clearBookingsAndTimes();
        alert('All bookings and showtimes have been cleared.');
        // Optionally reload page to reflect changes; omitted for home page.
      } else {
        alert('Clear bookings and times function not available.');
      }
    });
  }
}

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initDataControls);
} else {
  initDataControls();
}

})();


  </script>
  <!-- Script for bulk bookings input.  Parses pasted lines and updates the
       ShowtimeState with new films and bookings.  Handles blank format values,
       runtime/slot parsing and reuses existing blank booking rows when
       available. -->
  <script>
    function initBulkBookingsInput() {
      const textarea = document.getElementById('bulkBookingsInput');
      const addBtn = document.getElementById('addBulkBookingsBtn');
      if (!textarea || !addBtn) return;
      addBtn.addEventListener('click', () => {
        const raw = textarea.value || '';
        // Trim leading/trailing whitespace and normalise line breaks
        const lines = raw.trim().split(/\n+/).map(l => l.trim()).filter(l => l);
        if (lines.length === 0) {
          alert('Please paste at least one booking.');
          return;
        }
        // Load current state; this will initialise if needed
        const state = ShowtimeState.state;
        let filmIndexCounter = 1;
        // Determine numeric parts of film and booking IDs to generate unique IDs
        const filmNums = state.films
          .map(f => {
            const m = String(f.id).match(/^F(\d+)/);
            return m ? parseInt(m[1], 10) : null;
          })
          .filter(n => n !== null);
        let nextFilmNum = filmNums.length ? Math.max(...filmNums) + 1 : 1;
        const bookingNums = state.bookings
          .map(b => {
            const m = String(b.id).match(/^B(\d+)/);
            return m ? parseInt(m[1], 10) : null;
          })
          .filter(n => n !== null);
        let nextBookingNum = bookingNums.length ? Math.max(...bookingNums) + 1 : 1;
        // Determine the next slot number if user omits slot (not supported yet) but keep for future
        const existingSlots = state.bookings
          .map(b => parseInt(b.slot, 10))
          .filter(n => !isNaN(n));
        let nextSlotNum = existingSlots.length ? Math.max(...existingSlots) + 1 : 1;
        let addedCount = 0;
        // Attempt to detect a header row on the first line.  Recognise common
        // synonyms for title, runtime/duration and slot.  If detected, build a
        // mapping of column names to indexes and skip the header when parsing.
        let headerMap = null;
        if (lines.length > 0) {
          const firstParts = lines[0].split(/[\t,]/).map(p => p.trim());
          const lowerParts = firstParts.map(p => p.toLowerCase());
          const map = {};
          lowerParts.forEach((h, idx) => {
            if (['title', 'film title', 'film', 'attraction'].includes(h)) {
              map.title = idx;
            } else if (['format', 'fmt'].includes(h)) {
              // Only treat an explicit format column (Format/Fmt) as the film format.  Do not
              // treat print or print_ as format because these refer to separate tracking columns.
              map.format = idx;
            } else if (['runtime', 'run time', 'duration'].includes(h)) {
              map.runtime = idx;
            } else if (['slot', 'screen', 'slot number', 'slot#'].includes(h)) {
              map.slot = idx;
            } else if (['comments', 'comment', 'notes'].includes(h)) {
              map.comments = idx;
            }
          });
          // We consider this a header if we found at least title, runtime and slot columns.
          if (map.title !== undefined && map.runtime !== undefined && map.slot !== undefined) {
            headerMap = map;
            // Remove the header line from the data lines
            lines.shift();
          }
        }
        // Helper function to parse a row based on either the header map or the
        // default comma/tab separated format.  Returns null if the row cannot be parsed.
        function parseRow(row) {
          if (!row) return null;
          const cols = row.split(/[\t,]/).map(p => p.trim());
          let title = '';
          let format = '';
          let runtimeVal = '';
          let slotVal = '';
          let commentsVal = '';
          if (headerMap) {
            // Extract values by header index, falling back to empty strings
            title = (cols[headerMap.title] || '').trim();
            format = headerMap.format !== undefined ? (cols[headerMap.format] || '').trim() : '';
            runtimeVal = (cols[headerMap.runtime] || '').trim();
            slotVal = (cols[headerMap.slot] || '').trim();
            commentsVal = headerMap.comments !== undefined ? (cols[headerMap.comments] || '').trim() : '';
            // If no explicit format column, attempt to split title on colon to derive
            // format and title only when the prefix is a recognised format (IMAX, 4DX, SX, 3D, RPX).
            if (!format && title.includes(':')) {
              const idx = title.indexOf(':');
              const maybeFmt = title.substring(0, idx).trim();
              const validFormats = ['imax', '4dx', 'sx', '3d', 'rpx'];
              if (validFormats.includes(maybeFmt.toLowerCase())) {
                format = maybeFmt;
                title = title.substring(idx + 1).trim();
              }
            }
          } else {
            // Default behaviour: expect at least 3 parts: title[, format], runtime, slot
            if (cols.length < 3) return null;
            // The last two parts are runtime and slot
            slotVal = cols.pop().trim();
            runtimeVal = cols.pop().trim();
            // Remaining parts form title and optional format.  The first is title,
            // second is format; any additional parts are part of the title.
            if (cols.length === 0) return null;
            if (cols.length === 1) {
              title = cols[0];
              format = '';
            } else {
              title = cols[0];
              format = cols[1] || '';
              if (cols.length > 2) {
                title += ', ' + cols.slice(2).join(', ');
              }
            }
            // Attempt to derive format from title only when the prefix is a recognised format (IMAX, 4DX, SX, 3D, RPX).
            if (!format && title.includes(':')) {
              const idx = title.indexOf(':');
              const maybeFmt = title.substring(0, idx).trim();
              const validFormats = ['imax', '4dx', 'sx', '3d', 'rpx'];
              if (validFormats.includes(maybeFmt.toLowerCase())) {
                format = maybeFmt;
                title = title.substring(idx + 1).trim();
              }
            }
            commentsVal = '';
          }
          // Parse runtime as integer minutes
          const runtime = parseInt(runtimeVal || '', 10);
          // Trim title to a maximum of 18 characters when importing bookings.  This
          // truncation preserves the leftmost portion of the title to ensure that
          // long titles do not overflow limited column widths in the bookings and
          // schedule grids.  See user request to limit imported titles to 18
          // characters.
          if (title) {
            title = title.substring(0, 18);
          }
          if (!title || isNaN(runtime) || !slotVal) {
            return null;
          }
          return { title, format, runtime, slot: slotVal, comments: commentsVal };
        }
        lines.forEach(line => {
          const parsed = parseRow(line);
          if (!parsed) return;
          const { title, format, runtime, slot, comments } = parsed;
          // Find existing film by title (case insensitive) and format if provided
          const titleLC = title.toLowerCase();
          let film = state.films.find(f => f.title && f.title.toLowerCase() === titleLC && (format ? ((f.format || '').toLowerCase() === format.toLowerCase()) : true));
          // If film exists but runtime differs, update runtime; also update format if provided
          if (film) {
            if (film.runtime !== runtime) {
              film.runtime = runtime;
            }
            if (format && (!film.format || film.format.toLowerCase() !== format.toLowerCase())) {
              film.format = format;
            }
            // Clear any existing priority on reused films to avoid automatically populating
            // the Priority column.  We want imported films to have blank priority so
            // users can assign a value manually.
            film.priority = '';
          } else {
            // Create new film record.  Do not preset the priority; leave it
            // blank so that the Priority column is not auto-populated.  This
            // ensures users can assign priorities manually after import.
            const newFilmId = 'F' + nextFilmNum++;
            film = {
              id: newFilmId,
              title: title,
              runtime: runtime,
              trailer: 20,
              clean: 20,
              priority: '',
              rating: '',
              format: format,
            };
            state.films.push(film);
          }
          // Determine if there is an existing blank booking row (film title is empty)
          let blankIndex = -1;
          for (let i = 0; i < state.bookings.length; i++) {
            const b = state.bookings[i];
            const f = ShowtimeState.filmById(b.filmId);
            if (!f || !f.title) {
              blankIndex = i;
              break;
            }
          }
          let booking;
          if (blankIndex !== -1) {
            // Reuse blank row.  Update slot and filmId, and clear out
            // any pre-set week or weeksOut values so that Week column is not
            // auto-populated.  Also preserve or set notes from comments.
            booking = state.bookings[blankIndex];
            booking.slot = slot;
            booking.filmId = film.id;
            // Clear week and weeksOut to avoid auto-filling the Week column
            booking.week = '';
            booking.weeksOut = '';
            if (comments) {
              booking.notes = comments;
            }
          } else {
            // Create new booking.  Do not preset the week number or weeksOut; leave them blank
            // so that the Week column is not automatically filled.  Notes are carried over if comments present.
            const newBookingId = 'B' + nextBookingNum++;
            booking = {
              id: newBookingId,
              week: '',
              slot: slot,
              filmId: film.id,
              notes: comments || '',
              weeksOut: '',
            };
            state.bookings.push(booking);
          }
          addedCount++;
        });
        // If any bookings added, persist state and alert user
        if (addedCount > 0) {
          ShowtimeState.save();
          // Persist the updated state and reload pages on other tabs by dispatching storage event
          window.dispatchEvent(new StorageEvent('storage', { key: 'showtime:persist', newValue: JSON.stringify(state) }));
          alert(`Added ${addedCount} booking${addedCount === 1 ? '' : 's'} successfully.`);
          // Clear textarea
          textarea.value = '';
          // Refresh the film highlight dropdown and apply highlight in case new films
          // were added.  These functions are defined globally in app.js.
          try {
            if (typeof window.refreshFilmHighlightOptions === 'function') {
              window.refreshFilmHighlightOptions();
            }
            if (typeof window.applyFilmHighlight === 'function') {
              window.applyFilmHighlight();
            }
          } catch (e) {}
        } else {
          alert('No valid bookings were parsed. Please check your input format.');
        }
      });
    });
  </script>

  <!-- Persist and restore site information (name and number).  On page load,
       populate the input fields from the application state.  When the
       user edits either field, update the state and save it to
       localStorage.  This ensures that site details appear in JSON
       exports and reload automatically on subsequent visits. -->
  <script>
    function initSiteInfoControls() {
      // Ensure state is initialised
      try { ShowtimeState.load(); } catch (e) { /* ignore */ }
      const nameInput = document.getElementById('siteNameInput');
      const numInput = document.getElementById('siteNumberInput');
      if (nameInput) {
        nameInput.value = (ShowtimeState.state && ShowtimeState.state.siteName) || '';
        nameInput.addEventListener('input', () => {
          ShowtimeState.state.siteName = nameInput.value;
          ShowtimeState.save();
        });
      }
      if (numInput) {
        numInput.value = (ShowtimeState.state && ShowtimeState.state.siteNumber) || '';
        numInput.addEventListener('input', () => {
          ShowtimeState.state.siteNumber = numInput.value;
          ShowtimeState.save();
        });
      }
    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initBulkBookingsInput);
      document.addEventListener('DOMContentLoaded', initSiteInfoControls);
    } else {
      initBulkBookingsInput();
      initSiteInfoControls();
    }
  </script>
</body>
</html>
